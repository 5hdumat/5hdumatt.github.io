<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Http Header on 5hdumat</title><link>https://5hdumat.github.io/tags/http-header/</link><description>Recent content in Http Header on 5hdumat</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 25 Aug 2021 00:17:20 +0900</lastBuildDate><atom:link href="https://5hdumat.github.io/tags/http-header/index.xml" rel="self" type="application/rss+xml"/><item><title>[HTTP 일반헤더] HTTP 헤더엔 무엇이 있을까?</title><link>https://5hdumat.github.io/posts/network/http-header-info/</link><pubDate>Wed, 25 Aug 2021 00:17:20 +0900</pubDate><guid>https://5hdumat.github.io/posts/network/http-header-info/</guid><description>일반적인 헤더 from 유저 에이전트의 이메일 정보
일반적으로 잘 사용하진 않는다. 검색 엔진 같은 곳에서, 주로 사용 요청에서 사용 referer (중요) 이전 웹 페이지 주소
참고로 referer는 단어 referrer의 오타이다 :(
현재 요청된 페이지의 이전 웹 페이지 주소 A -&amp;gt; B로 이동하는 경우 B를 요청할 때 referer: A를 포함해서 요청 referer를 사용해 유입 경로 분석 가능 요청에서 사용 구글링을 통해 좋아하는 음악을 검색해서 들어가면 referer이 google로 되어있다.</description></item><item><title>[HTTP 일반헤더] 전송 방식</title><link>https://5hdumat.github.io/posts/network/http-header-transmission-method/</link><pubDate>Tue, 24 Aug 2021 23:57:15 +0900</pubDate><guid>https://5hdumat.github.io/posts/network/http-header-transmission-method/</guid><description>전송 방식 전송 방식은 단순하게 4가지로 분류할 수 있다.
단순 전송 압축 전송 분할 전송 범위 전송 한가지 씩 간단하게 살펴보자.
서버가 Message-Body에 대한 Content-Length를 알 수 있을 때 그냥 단순하게 요청하고 내려받는 방식 단순 전송 방식을 압축하여 보내는 방식 용량을 줄이기 위해 사용 압축 전송 방식을 사용하는 서버는 Content-Encoding을 헤더에 추가해서 응답해야 한다. chunk는 덩어리를 의미한다. 아래 예제의 숫자는 바이트를 의미` 한 번에 전송하는 방식은 모든 메시지 바디가 로드될 때까지 대기해야 하지만 분할 전송 방식은 서버가 바이트와 내용을 쪼개서 응답하기 때문에 클라이언트가 그때그때 표현할 수 있다.</description></item><item><title>[HTTP 일반헤더] 컨텐츠 협상</title><link>https://5hdumat.github.io/posts/network/contents-negotiation/</link><pubDate>Mon, 23 Aug 2021 00:28:10 +0900</pubDate><guid>https://5hdumat.github.io/posts/network/contents-negotiation/</guid><description>컨텐츠 협상 (Contents Negotiation) 컨텐츠 협상이란 동일한 URI에서 리소스의 서로 다른 버전을 서브하기 위해 사용되는 메커니즘으로, 사용자 에이전트(브라우저)가 사용자에게 제일 잘 맞는 것이 무엇인지(예를 들어, 문서의 언어, 이미지 포맷 혹은 컨텐츠 인코딩에 있어 어떤 것이 적절한지)를 명시할 수 있다.
즉, 클라이언트가 선호하는 표현 요청이며, 협상 헤더는 요청시에만 사용한다.
Accept: 클라이언트가 선호하는 미디어 타입으로 요청 Accept-Charset: 클라이언트가 선호하는 문자 인코딩으로 요청 Accept-Encoding: 클라이언트가 선호하는 압축 인코딩으로 요청 Aceept-Language: 클라이언트가 선호하는 자연 언어로 요청 Aceept-Language를 예로 들어보자.</description></item><item><title>[HTTP 일반헤더] HTTP 헤더 개요</title><link>https://5hdumat.github.io/posts/network/http-header-outline/</link><pubDate>Sat, 21 Aug 2021 02:33:59 +0900</pubDate><guid>https://5hdumat.github.io/posts/network/http-header-outline/</guid><description>HTTP 헤더 개요 앞서 간단히 정리했었던 HTTP 메시지 내용을 다시 한번 정리해보자.
HTTP 헤더 HTTP 전송에 필요한 모든 부가정보를 헤더가 포함한다.
예) 메시지 바대의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보 캐시 관리 정보 등
HTTP 헤더 예제 header-field는 아래의 형태로 사용 (헷갈리면 위 예제를 참고하자) field-name &amp;ldquo;:&amp;rdquo; OWS field-value OWS (OWS: 띄어쓰기) field-name은 대소문자 구분이 없다. 표준 헤더 필드가 굉장히 많고, 필요시 임의의 헤더를 추가할 수도 있다.</description></item></channel></rss>