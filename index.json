[{"content":"HTTP 헤더엔 어떤 항목들이 있을까? from  유저 에이전트의 이메일 정보\n  일반적으로 잘 사용하진 않는다. 검색 엔진 같은 곳에서, 주로 사용 요청에서 사용  referer (중요)  이전 웹 페이지 주소\n참고로 referer는 단어 referrer의 오타이다 :(\n  현재 요청된 페이지의 이전 웹 페이지 주소 A -\u0026gt; B로 이동하는 경우 B를 요청할 때 referer: A를 포함해서 요청 referer를 사용해 유입 경로 분석 가능 요청에서 사용  구글링을 통해 좋아하는 음악을 검색해서 들어가면 referer이 google로 되어있다. 유튜브에 들어가기 이전의 계기를 알 수 있으며, 이 정보는 보통 유입 경로를 분석할 때 많이 사용한다. Server  요청을 처리하는 Origin 서버의 소프트웨어 정보\n  사실 HTTP 요청을 보내게 되면 중간에 여러 프록시 서버를 거치게 된다. 실제 에플리케이션에서 클라이언트 요청에 대한 표현 데이터를 만들어 주는 마지막 서버를 origin 서버라고 한다.  Date  메시지가 발생한 날짜와 시간\n  Date: Tue, 15 Nov 1994 08:12:31 GMT 응답에서 사용  ","permalink":"https://5hdumat.github.io/posts/network/http-header-info/","summary":"HTTP 헤더엔 어떤 항목들이 있을까? from  유저 에이전트의 이메일 정보\n  일반적으로 잘 사용하진 않는다. 검색 엔진 같은 곳에서, 주로 사용 요청에서 사용  referer (중요)  이전 웹 페이지 주소\n참고로 referer는 단어 referrer의 오타이다 :(\n  현재 요청된 페이지의 이전 웹 페이지 주소 A -\u0026gt; B로 이동하는 경우 B를 요청할 때 referer: A를 포함해서 요청 referer를 사용해 유입 경로 분석 가능 요청에서 사용  구글링을 통해 좋아하는 음악을 검색해서 들어가면 referer이 google로 되어있다.","title":"[HTTP 일반헤더] HTTP 헤더엔 무엇이 있을까?"},{"content":"전송 방식 전송 방식은 단순하게 4가지로 분류할 수 있다.\n 단순 전송 압축 전송 분할 전송 범위 전송  한가지 씩 간단하게 살펴보자.\n단순 전송  서버가 Message-Body에 대한 Content-Length를 알 수 있을 때 그냥 단순하게 요청하고 내려받는 방식  압축 전송  단순 전송 방식을 압축하여 보내는 방식 용량을 줄이기 위해 사용 압축 전송 방식을 사용하는 서버는 Content-Encoding을 헤더에 추가해서 응답해야 한다.  분할 전송  chunk는 덩어리를 의미한다. 아래 예제의 숫자는 바이트를 의미 한 번에 전송하는 방식은 모든 메시지 바디가 로드될 때까지 대기해야 하지만 분할 전송 방식은 서버가 바이트와 내용을 쪼개서 응답하기 때문에 클라이언트가 그때그때 표현할 수 있다. Content-Length를 사용할 수 없다.  범위 전송  범위를 지정해서 리소스를 요청할 수 있다. Content-Range를 사용하여 리소스 범위를 지정한다.  예) 이미지 리소스를 받다가 장애가 발생했을 경우 리소스가 받아진 부분을 제외한 나머지 리소스 범위를 지정하여 재요청할 때    ","permalink":"https://5hdumat.github.io/posts/network/http-header-transmission-method/","summary":"전송 방식 전송 방식은 단순하게 4가지로 분류할 수 있다.\n 단순 전송 압축 전송 분할 전송 범위 전송  한가지 씩 간단하게 살펴보자.\n단순 전송  서버가 Message-Body에 대한 Content-Length를 알 수 있을 때 그냥 단순하게 요청하고 내려받는 방식  압축 전송  단순 전송 방식을 압축하여 보내는 방식 용량을 줄이기 위해 사용 압축 전송 방식을 사용하는 서버는 Content-Encoding을 헤더에 추가해서 응답해야 한다.  분할 전송  chunk는 덩어리를 의미한다. 아래 예제의 숫자는 바이트를 의미 한 번에 전송하는 방식은 모든 메시지 바디가 로드될 때까지 대기해야 하지만 분할 전송 방식은 서버가 바이트와 내용을 쪼개서 응답하기 때문에 클라이언트가 그때그때 표현할 수 있다.","title":"[HTTP 일반헤더] 전송 방식"},{"content":"컨텐츠 협상 (Contents Negotiation)  컨텐츠 협상이란 동일한 URI에서 리소스의 서로 다른 버전을 서브하기 위해 사용되는 메커니즘으로, 사용자 에이전트(브라우저)가 사용자에게 제일 잘 맞는 것이 무엇인지(예를 들어, 문서의 언어, 이미지 포맷 혹은 컨텐츠 인코딩에 있어 어떤 것이 적절한지)를 명시할 수 있다.\n 즉, 클라이언트가 선호하는 표현 요청이며, 협상 헤더는 요청시에만 사용한다.\n Accept: 클라이언트가 선호하는 미디어 타입으로 요청 Accept-Charset: 클라이언트가 선호하는 문자 인코딩으로 요청 Accept-Encoding: 클라이언트가 선호하는 압축 인코딩으로 요청 Aceept-Language: 클라이언트가 선호하는 자연 언어로 요청  Aceept-Language를 예로 들어보자. 아래 예제는 한국어 브라우저를 사용하는 클라이언트가 외국 이벤트 사이트에 접속했을 때의 상황이다.\nAccept-Language 적용 전 위 예제에서 클라이언트는 리소스 경로만 서버에게 요청하고 그 외 아무런 정보도 요청하지 않았다. 서버는 어떻게 응답했을까? 다중 언어 지원 서버임에도 서버는 영어로 응답했다. 컨텐츠 협상이 이루어지지 않았기 때문이다. 영알못 한국인 클라이언트라면 난감한 상황일 것이다. (본인 소개 아님)\n컨텐츠 협상이 이루어졌다면 뭐가 달라졌을지 예제를 살펴보자.\nAccept-Language 적용 후 클라이언트가 Accept-Language: ko라는 표현 헤더를 포함해 요청했다. 서버는 한국어도 지원하기 때문에 클라이언트가 원하는 Content-Language를 찾아 응답했다.\n작은 부분 같지만 클라이언트 입장에선 사용성이 극대화 되었을 것이다.\nAccept-Language 복잡한 예시 클라이언트는 한국인인데 서버가 지원하는 언어는 독일어와 영어인 경우는 어떻게 할까?\n아무래도 독일어보단 영어가 나을 것 같다. 하지만 다중 언어 지원 서버의 기본값은 독일어이므로 독일어로 응답이 올 것이다.\n협상과 우선순위 위 예시와 같은 상황을 해결하기 위해선 우선순위라는게 필요하다.\n우선순위 요청 헤더 예시 GET /event Aceept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7  우선순위는 Quality Values(q)값을 사용한다. 0 ~ 1 범위 이며, 클수록 높은 우선순위를 갖는다. 생략 시 기본값은 1이다. Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,e n;q=0.7 라고 요청했다 가정  순위별로 나열하면 아래와 같다.  1순위. ko-KR;q=1 (q생략) 2순위. ko;q=0.9 3순위. en-US;q=0.8 4순위. en;q=0.7      우선순위 요청 헤더를 포함했을 때 어떤게 달라졌을까?\n클라이언트의 자연 언어 선호도에 따라 영어로 내어준것을 확인할 수 있다. 실제 웹 브라우저로 요청 시 아래와 같이 협상 헤더 Aceept-Language에 우선순위가 포함된 것을 확인할 수 있다.\nhello 구글링 예제  또한 내용이 구체적일수록 우선한다.\nGET /event Accept: text/*, text/plain, text/plain;format=flowed, */* 위 예제 우선순위는 아래와 같다.  text/plain;format=flowed text/plain text/* /  정리  Accept: 클라이언트가 선호하는 미디어 타입으로 요청 Accept-Charset: 클라이언트가 선호하는 문자 인코딩으로 요청 Accept-Encoding: 클라이언트가 선호하는 압축 인코딩으로 요청 Aceept-Language: 클라이언트가 선호하는 자연 언어로 요청  위 모든 협상 헤더 항목은 서버에게 선호도에 따른 컨텐츠 협상을 요구할 수있다. 하지만 클라이언트의 요구사항에 맞춰 서버가 모든 기능을 제공할 순 없다.\n컨텐츠 협상은 클라이언트와 서버간의 약속이 되어있다 가정한다.\n","permalink":"https://5hdumat.github.io/posts/network/http-header-contents-negotiation/","summary":"컨텐츠 협상 (Contents Negotiation)  컨텐츠 협상이란 동일한 URI에서 리소스의 서로 다른 버전을 서브하기 위해 사용되는 메커니즘으로, 사용자 에이전트(브라우저)가 사용자에게 제일 잘 맞는 것이 무엇인지(예를 들어, 문서의 언어, 이미지 포맷 혹은 컨텐츠 인코딩에 있어 어떤 것이 적절한지)를 명시할 수 있다.\n 즉, 클라이언트가 선호하는 표현 요청이며, 협상 헤더는 요청시에만 사용한다.\n Accept: 클라이언트가 선호하는 미디어 타입으로 요청 Accept-Charset: 클라이언트가 선호하는 문자 인코딩으로 요청 Accept-Encoding: 클라이언트가 선호하는 압축 인코딩으로 요청 Aceept-Language: 클라이언트가 선호하는 자연 언어로 요청  Aceept-Language를 예로 들어보자.","title":"[HTTP 일반헤더] 컨텐츠 협상"},{"content":"@WebServlet 애노테이션을 이용한 서블릿 배치 설정 Servlet 3.0 사양부터는 애노테이션으로 서블릿 배치 정보를 설정할 수 있다. web.xml 대신 애노테이션을 이용해 배치 정보를 작성해 보자.\n 다음과 같이 서블릿 정의와 URL 매핑을 설정 영역을 주석처리 한다.  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;display-name\u0026gt;web03\u0026lt;/display-name\u0026gt; \u0026lt;!-- \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;Calculator\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;lesson03.servlets.CalculatorServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;Calculator\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Calculator\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; --\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.html\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;index.htm\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;default.html\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;default.htm\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;default.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; \u0026lt;/web-app\u0026gt;   CalculatorServlet 클래스에 @WebServlet 애노테이션을 작성한다.  @WebServlet(\u0026#34;/Calculator\u0026#34;) public class CalculatorServlet extends GenericServlet { ... } @WebServlet 애노테이션의 주요 속성 @WebServlet 애노테이션을 사용할 수 있는 주요 속성은 다음과 같다.\n name   서블릿의 이름을 설정하는 속성이다. 기본값은 빈 문자열(\u0026quot;\u0026quot;) 이다.\n @WebServlet(name=\u0026#34;서블릿이름\u0026#34;)   urlPatterns   서블릿의 URL 목록을 설정하는 속성이다. 속성값으로 String 배열이 온다. 기본값은 빈 배열이다.\n // 서블릿에 대해 한 개의 URL을 설정하는 경우 @WebServlet(urlPatterns=\u0026#34;/Calculator\u0026#34;) // 일반적인 문자열로 표기 @WebServlet(urlPatterns={\u0026#34;/Calculator\u0026#34;}) // 중괄호를 이용하여 배열로 표기  // 서블릿에 대해 여러 개의 URL을 설정하는 경우 @WebServlet(urlPatterns={\u0026#34;/Calculator\u0026#34;, \u0026#34;/Calculator.do\u0026#34;, \u0026#34;/Calculator.action\u0026#34;})   value   urlPatterns와 같은 용도이다. 속성 이름은 생략 가능하다.\n // 서블릿에 대해 한 개의 URL을 설정하는 경우 @WebServlet(value=\u0026#34;/Calculator\u0026#34;) @WebServlet(\u0026#34;/Calculator\u0026#34;) // 속성명 \u0026#39;value\u0026#39; 생략 가능   기타   만약 다음과 같이 value 속성 외에 다른 속성의 값도 함께 설정한다면 value 속성의 이름을 생략할 수 없다.\n // 서블릿에 대해 한 개의 URL을 설정하는 경우 @WebServlet(value=\u0026#34;/calc\u0026#34;, name=\u0026#34;Calculator\u0026#34;) // 가능 @WebServlet(\u0026#34;/calc\u0026#34;, name=\u0026#34;Calculator\u0026#34;) // 불가능 ","permalink":"https://5hdumat.github.io/posts/servlet/generic-annotation/","summary":"@WebServlet 애노테이션을 이용한 서블릿 배치 설정 Servlet 3.0 사양부터는 애노테이션으로 서블릿 배치 정보를 설정할 수 있다. web.xml 대신 애노테이션을 이용해 배치 정보를 작성해 보자.\n 다음과 같이 서블릿 정의와 URL 매핑을 설정 영역을 주석처리 한다.  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;display-name\u0026gt;web03\u0026lt;/display-name\u0026gt; \u0026lt;!-- \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;Calculator\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;lesson03.servlets.CalculatorServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;Calculator\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Calculator\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; --\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.html\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;index.htm\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;default.html\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;default.htm\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;default.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; \u0026lt;/web-app\u0026gt;   CalculatorServlet 클래스에 @WebServlet 애노테이션을 작성한다.","title":"[서블릿 프로그래밍 기본] @WebServlet 애노테이션"},{"content":" 개발환경: IntelliJ IDEA 2021.2 (Utimate Edition)\n 목표  GenericServlet 추상 클래스를 활용하여 서블릿을 만들 수 있다. 웹 브라우저와 서블릿간의 CGI를 이해한다.  GenericServlet? 이전 포스트에선 서블릿 클래스를 만들 때 Servlet 인터페이스를 구현했다. 인터페이스를 구현하려면 선언된 모든 메서드를 구현해야 하는데 이 방식에는 문제점이 있다.\n 사실 Servlet 인터페이스에 선언된 다섯 개의 메서드 중 반드시 구현해야 하는 메서드는 클라이언트가 요청할 때마다 호출되는 service() 메서드이다. init() 의 경우 서블릿이 생성될 때 한 번 호출되는데, 서블릿을 위해 특별히 준비해야 하는 작업이 없다면 굳이 구현할 필요가 없다. destroy()도 마찬가지이다.  그럼에도 우리는 인터페이스를 구현해야하는 클래스는 반드시 인터페이스에 선언된 모든 메서드를 구현해야 한다는 자바의 법칙으로 인해 빈 메서드라도 구현해야 했다.\n이러한 불편을 해소하기 위해 등장한 것이 GenericServlet이다.\nGenericServlet의 용도 GenericServlet은 추상 클래스라는 말로 짐작할 수 있듯이 하위 클래스에게 공통의 필드와 메서드를 상속해 주고자 존재한다. 즉 서블릿 클래스가 필요로 하는 init(), destroy(), getServletConfig(), getServletInfo() 를 미리 구현하여 상속해 준다. service() 는 어차피 각 서블릿 클래스마다 별도로 구현해야 하기 때문에 GenericServlet에서는 구현하지 않는다.\n결과적으로 우리는 Servlet 인터페이스의 메서드 중 service() 만 구현하면 된다.\n이전 포스트에서 만든 HelloWorld 클래스가 GenericServlet을 상속 받았다면 코드가 다음과 같이 달라졌을 것이다.\nServlet interface 구현 package lesson03.servlets; import java.io.IOException; import javax.servlet.Servlet; import javax.servlet.ServletConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; public class HelloWorld implements Servlet { ServletConfig config; @Override public void init(ServletConfig config) throws ServletException { System.out.println(\u0026#34;init() 호출됨\u0026#34;); this.config = config; } @Override public void destroy() { System.out.println(\u0026#34;destroy() 호출됨\u0026#34;); } @Override public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException { System.out.println(\u0026#34;service() 호출됨\u0026#34;); } @Override public ServletConfig getServletConfig() { System.out.println(\u0026#34;getServletConfig() 호출됨\u0026#34;); return this.config; } @Override public String getServletInfo() { System.out.println(\u0026#34;getServletInfo() 호출됨\u0026#34;); return \u0026#34;version=1.0;author=eomjinyoung;copyright=eomjinyoung 2013\u0026#34;; } } GenericServlet 추상 클래스 상속 package lesson03.servlets; import java.io.IOException; import javax.servlet.*; public class HelloWorld extends GenericServlet { @Override public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException { System.out.println(\u0026#34;service() 호출됨\u0026#34;); } }  GenericServlet을 활용한 계산기 서블릿 작성 GenericServlet 활용법과 웹 브라우저로 입·출력 하는 방법을 배워보자.\n1. lesson03.servlets 패키지에 CalculatorServlet 클래스 생성\n2. Calculator 클래스는 GenericServlet의 service() 메서드를 구현해야 한다고 경고가 뜨고있다.\n3. [Implement methods]를 눌러 다음과 같이 메서드를 구현해주자.\npackage lesson03.servlets; import javax.servlet.GenericServlet; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import java.io.IOException; public class CalculatorServlet extends GenericServlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { } }  Servlet 인터페이스를 직접 구현하던 때 보다 코드가 훨씬 간결해졌다.\n위 예제 코드를 보면 다음과 같이 service() 메서드를 오버라이드 하고 있다. Servlet 인터페이스에 선언된 다섯 개의 메서드 중 service()를 제외한 나머지 메서드는 이미 GenericServlet에서 구현했기 때문에, 개발자는 오직 service() 메서드 구현에만 몰두하면 된다.\n아래 다이어그램은 GenericServlet 클래스가 Servlet 및 ServletConfig 인터페이스를 구현함을 보여준다.\n4. service() 안에 다음과 같이 사칙연산을 수행하는 명령문을 작성한다.\npackage lesson03.servlets; import javax.servlet.GenericServlet; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import java.io.IOException; import java.io.PrintWriter; public class CalculatorServlet extends GenericServlet { private static final long serialVersionUID = 1L; @Override public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException { int a = Integer.parseInt( request.getParameter(\u0026#34;a\u0026#34;) ); int b = Integer.parseInt( request.getParameter(\u0026#34;b\u0026#34;) ); response.setContentType(\u0026#34;text/plain\u0026#34;); response.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); PrintWriter writer = response.getWriter(); writer.println(\u0026#34;a=\u0026#34; + a + \u0026#34;,\u0026#34; + \u0026#34;b=\u0026#34; + b + \u0026#34;의 계산결과 입니다.\u0026#34;); writer.println(\u0026#34;a + b = \u0026#34; + (a + b)); writer.println(\u0026#34;a - b = \u0026#34; + (a - b)); writer.println(\u0026#34;a * b = \u0026#34; + (a * b)); writer.println(\u0026#34;a / b = \u0026#34; + ((float)a / (float)b)); writer.println(\u0026#34;a % b = \u0026#34; + (a % b)); } }  명령문에 쓰여진 몇가지 주요 기능들을 살펴보도록 하자.\nServletRequest\n service()의 매개변수 중 ServletRequest 객체는 클라이언트의 요청 정보를 다룰 때 사용한다.\n 다음 표는 ServletRequest 객체의 주요 메서드를 정리한 것이다.\n   메서드 설명     getRemoteAddr() 서비스를 요청한 클라이언트의 IP 주소를 반환   getScheme() 클라이언트가 요청한 URI 형식 Scheme을 반환한다. 즉 URL에서 \u0026lsquo;:\u0026rsquo; 문자 전에 오는 값을 반환한다. URL에서 스킴의 의미는 자원을 식별하는 최상위 분류 기호이다. 스킴의 예로 http, https, ftp, file, news 등이 있다. 간혹 URI 스킴을 URI 프로토콜로 말하는 경우도 있는데 엄연히 잘못된 것이다. http, ftp는 프로토콜 이름이 맞지만, file이나 news는 프로토콜 이름이 아니다.   getProtocol() 요청 프로토콜의 이름과 버전을 반환한다 (예) HTTP/1.1   getParameter() GET이나 POST 요청으로 들어온 매개변수 값을 꺼낼 때 사용   getParameterNames() 요청 정보에서 매개변수 이름만 추출하여 반환   getParameterValues() 요청 정보에서 매개변수 값만 추출하여 반환   getParameterMap() 요청 정보에서 매개변수들을 Map 객체에 담아 반환   setCharacterEncoding() POST 요청의 매개변수에 대해 문자 집합을 설정한다. 기본값은 ISO-8859-1로 설정되어 있다. 매개변수의 문자 집합을 정확히 지정해야만 제대로 변환된 유니코드 값을 반환한다. 매개변수의 문자 집합을 지정하지 않으면 무조건 ISO-8859-1이라 가정하고 유니코드로 반환한다. 주의할 점은 처음 getParameter()를 호출하기 전에 이 메서드를 먼저 호출해야만 적용 된다.    ServletResponse\n ServletResponse 객체는 응답과 관련된 기능을 제공한다. 클라이언트에게 출력하는 데이터의 인코딩 타입을 설정하고, 문자집합을 지정하며, 출력 데이터를 임시 보관하는 버퍼의 크기를 조정하거나, 데이터를 출력하기 위해 출력 스트림을 준비할 때 이 객체를 사용한다.\n 다음 항목은 ServletResponse 객체의 주요 메서드를 정리한 것이다.\n  setContentType()\nresponse.setContentType(\u0026#34;text/plain\u0026#34;);  출력할 데이터의 인코딩 형식과 문자 집합을 지정한다.\n클라이언트에게 출력할 데이터의 정보를 알려주어야 클라이언트는 그 형식에 맞추어 올바르게 화면에 출력(Rendering)할 수 있다. 예를 들어 HTML 형식이면 태그 규칙에 맞추어 화면에 출력할 것이고, XML 형식이면 각 태그를 트리 노트로 표현할 것이다.    setCharacterEncoding()\nresponse.setContentEncoding(\u0026#34;UTF-8\u0026#34;);  출력할 데이터의 문자 집합을 지정한다. 기본값은 ISO-8859-1이다.\n위 예제 코드는 출력할 데이터의 문자 집합을 \u0026lsquo;UTF-8\u0026rsquo;로 설정하고 있다. 즉 데이터를 출력할 때 유니코드 값을 UTF-8 형식으로 변환하라는 뜻이다. 만약 문자 집합을 지정하지 않는다면 출력하는 모든 문자를 영어로 간주하므로 한글은 \u0026lsquo;?\u0026lsquo;문자로 변환되어 출력될 것이다.    setContentType() 문자 집합\nresponse.setContentType(\u0026#34;text/plain;chartset=UTF-8\u0026#34;);  출력 데이터의 문자 집합은 위 예제와 같이 setContentType()을 사용할 수도 있다.    setWriter()\nPrintWriter writer = response.getWriter();  클라이언트로 출력할 수 있도록 출력 스트림 객체를 반환한다.\n주의할 점은 setContentType() 이나 setCharacterEncoding()을 먼저 호출해야 한다. 그래야만 정상적으로 유니코드가 지정된 문자 집합으로 변환된다.    5. web.xml에 CalculatorServlet의 배치 정보를 추가한다.\nServlet 3.0 사양부터는 애노테이션으로 서블릿 배치 정보를 설정할 수 있다. 링크\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;display-name\u0026gt;web03\u0026lt;/display-name\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;Calculator\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;lesson03.servlets.CalculatorServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;Calculator\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Calculator\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.html\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;index.htm\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;default.html\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;default.htm\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;default.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; \u0026lt;/web-app\u0026gt;  6. 톰캣 실행 -\u0026gt; CalculatorServlet에 GET 요청 -\u0026gt; 실행 결과 확인\n서블릿 실행 결과는 다음과 같다.\n","permalink":"https://5hdumat.github.io/posts/servlet/generic-servlet/","summary":"개발환경: IntelliJ IDEA 2021.2 (Utimate Edition)\n 목표  GenericServlet 추상 클래스를 활용하여 서블릿을 만들 수 있다. 웹 브라우저와 서블릿간의 CGI를 이해한다.  GenericServlet? 이전 포스트에선 서블릿 클래스를 만들 때 Servlet 인터페이스를 구현했다. 인터페이스를 구현하려면 선언된 모든 메서드를 구현해야 하는데 이 방식에는 문제점이 있다.\n 사실 Servlet 인터페이스에 선언된 다섯 개의 메서드 중 반드시 구현해야 하는 메서드는 클라이언트가 요청할 때마다 호출되는 service() 메서드이다. init() 의 경우 서블릿이 생성될 때 한 번 호출되는데, 서블릿을 위해 특별히 준비해야 하는 작업이 없다면 굳이 구현할 필요가 없다.","title":"[서블릿 프로그래밍 기본] GenericServlet"},{"content":" 개발환경: IntelliJ IDEA 2021.2 (Utimate Edition)\n 목표  서블릿 프로그래밍을 통해 웹 애플리케이션 만드는 방법을 숙지한다. Servlet 인터페이스를 이해한다.  서블릿 클래스 만들기 다음과 같이 servlets 패키지에 javax.servlet.Servlet 인터페이스를 구현한 HelloWorld 클래스를 만들었다.\nweb/src/lesson03.servlets/HelloWorld.java package lesson03.servlets; import java.io.IOException; import javax.servlet.Servlet; import javax.servlet.ServletConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; public class HelloWorld implements Servlet { ServletConfig config; @Override public void init(ServletConfig config) throws ServletException { System.out.println(\u0026#34;init() 호출됨\u0026#34;); this.config = config; } @Override public void destroy() { System.out.println(\u0026#34;destroy() 호출됨\u0026#34;); } @Override public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException { System.out.println(\u0026#34;service() 호출됨\u0026#34;); } @Override public ServletConfig getServletConfig() { System.out.println(\u0026#34;getServletConfig() 호출됨\u0026#34;); return this.config; } @Override public String getServletInfo() { System.out.println(\u0026#34;getServletInfo() 호출됨\u0026#34;); return \u0026#34;version=1.0;author=eomjinyoung;copyright=eomjinyoung 2013\u0026#34;; } }  서블릿 클래스는 반드시 javax.servlet.Servlet 인터페이스를 구현해야 한다. 아래 예제처럼 서블릿 컨테이너1가 서블릿에 대해 호출할 메서드를 정의한 것이 Servlet 인터페이스이다.\nServlet 인터페이스의 생명주기 메서드  Servlet 인터페이스에 정의된 다섯 가지 메서드 중 서블릿의 생성과 실행, 소멸, 즉 생명주기 Lifecycle과 관련된 메서드가 init(), service(), destroy()이다.\n   init()\n서블릿 컨테이너가 서블릿을 생성한 후 초기화 작업을 수행하기 위해 호출하는 메서드이다.\n서블릿이 클라이언트의 요청을 처리하기 전에 준비할 작업이 있다면 이 메서드에 작성해야한다. 예를 들어 이 메서드가 호출될 때 데이터베이스에 연결하거나 외부 스토리지 서버와의 연결, 프로퍼티 로딩 등 클라이언트 요청을 처리하는데 필요한 자원을 미리 준비할 수 있어야 한다.\n  servive()\n클라이언트가 요청할 때 마다 호출되는 메서드이다.\n실질적으로 서비스 작업을 수행하는 메서드이며, 바로 이 메서드에 서블릿이 해야 할 일을 작성하면 된다. 참고로 위 예제 소스는 단지 메서드가 호출되었음을 확인하기 위해 서버 실행 창으로 간단한 문구를 출력한 것이므로, 웹 브라우저 창에 는 어떤 값도 출력되지 않는다.\n  destory()\n서블릿 컨테이너가 종료되거나 웹 애플리케이션이 멈출 때 또는 해당 서블릿을 비활성화 시킬 때 호출된다.\n이 메서드에는 서비스 수행을 위해 확보했던 자원을 해제한다거나 데이터를 저장하는 등의 마무리 작업을 작성하면 된다.\n  Servlet 인터페이스의 기타 메서드  서블릿 생명주기와 관련된 메서드 외에 두 개의 보조 메서드가 더 있다. 이 메서드들은 서블릿 정보를 추출할 필요가 있을 때 호출하는 메서드이다.\n   getServletConfig()\n서블릿 설정 정보를 다루는 ServletConfig 객체를 반환한다.\n이 객체를 통해 서블릿 이름과 서블릿 초기 매개변수 값, 서블릿 환경정보를 얻을 수 있다. 예제 소스처럼 init()가 호출될 때 매개변수로 받은 이 객체를 인스턴스 변수에 저장해 두었다가 이 메서드가 호출될 때 반환한다.\n  getServletInfo()\n서블릿을 작성한 사람에 대한 정보라든가 서블릿 버전, 권리 등을 담은 문자열을 반환한다. 리턴 값이 반드시 예제 소스처럼 형식이 같을 필요는 없다.\n  이 메서드들은 서블릿 컨테이너의 관리자 페이지에서 서블릿 정보를 출력할 때도 사용된다.\n Servlet 배치 정보 작성 배치 설명서 파일(web.xml)을 열고 다음과 같이 HelloWorld 서블릿 배치 정보를 추가한다.\nweb03/Web/WEB-INF/web.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;display-name\u0026gt;web03\u0026lt;/display-name\u0026gt; \u0026lt;!-- 서블릿 선언 --\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;Hello\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;lesson03.servlets.HelloWorld\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!-- 서블릿 URL과 연결 --\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;Hello\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.html\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;index.htm\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;default.html\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;default.htm\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;default.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; \u0026lt;/web-app\u0026gt;  web.xml 파일을 배치 기술서(Deployment Descriptor) 또는 약어로 \u0026lsquo;DD 파일\u0026rsquo; 이라고 부른다.\n웹 애플리케이션의 배치 정보를 담고 있는 파일이다. 따라서 서블릿을 만들었으면 DD 파일에 배치 정보를 등록해야 한다.\n클라이언트에서 서블릿에 실행 요청을 하면 서블릿 컨테이너가 DD 파일에 등록된 서블릿을 찾는다.\n 서블릿 선언부  \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;Hello\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;lesson03.servlets.HelloWorld\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-name\u0026gt;은 서블릿 별명을 설정한다. 서블릿 별명은 클래스 이름일 필요도 없고 비어있어도 된다. \u0026lt;servlet-class\u0026gt;는 패키지 이름을 포함한 서블릿 클래스명을 설정한다.\n 서블릿 URL 부여  클라이언트에서 서블릿의 실행을 요청할 때는 URL을 사용한다. 따라서 서블릿에 URL을 부여해야 클라이언트에서 요청할 수 있다. \u0026lt;servlet-mapping\u0026gt; 태그는 서블릿과 URL을 매핑할 때 사용한다.\n\u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;Hello\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;은 \u0026lt;servlet\u0026gt; 태그에서 정의한 서블릿 별명이 온다. \u0026lt;url-pattern\u0026gt;은 서블릿을 요청할 때 클라이언트가 사용할 URL을 설정한다. /Hello에서 /는 컨텍스트 루트(애플리케이션 루트)를 의미한다.\n 서블릿 실행 HelloWorld 서블릿을 실행해 보자.\n그냥 톰캣을 실행했더니 정상적으로 화면이 노출되었다.\n아무래도 서블릿 컨테이너인 톰캣 세팅 과정에서 artifacts 설정을 했었는데, 이때 톰캣에 웹 애플리케이션 배치가 이루어진 것 같다. (이전 포스트 참고)\n💡 웹 브라우저는 그냥 빈 화면만 출력하고 있다. 예제의 System.out.println() 메서드는 클라이언트로 호출하는 것이 아니라 서버 콘솔창으로 출력하는 것이기 때문이다. 오해하지 말자.\n서블릿 구동 절차 확인 톰캣 서버의 콘솔창을 통해 서블릿 구동 절차를 확인해보자.\n위 예제와 같이 콘솔창을 확인해보면 init()이 호출된 후 service()가 호출된 것을 알 수 있다.\n또한 웹 브라우저 주소창을 여러번 새로고침하면 위 예제와 같이 service()만 호출되는것을 알 수 있다. 그 이유는 이미 서블릿 컨테이너가 찾고자하는 인스턴스가 존재하기 때문이다.\n서블릿 컨테이너는 클라이언트로부터 요청을 받으면 해당 서블릿을 찾아 본다. 서블릿이 없다면 인스턴스를 생성한다. 한번 인스턴스가 생성되면 웹 애플리케이션을 종료할때까지 계속 유지하기 때문에 서블릿 컨테이너는 더 이상 인스턴스를 생성하지 않는다.\n톰캣을 종료하면 destroy()가 호출되는 것을 확인 할 수 있다.\n정리  클라이언트의 요청이 들어오면 서블릿 컨테이너는 서블릿을 찾는다. 만약 서블릿 인스턴스(객체)가 없다면, 서블릿 클래스를 로딩하고 인스턴스를 생성한 후 생성자를 호출한다. 그리고 서블릿 초기화 메서드인 init()을 호출한다. 클라이언트 요청을 처리하는 service() 메서드를 호출한다. 메서드 이름을 보면 이미 그 용도를 짐작할 수 있다. 즉 클라이언트의 요청에 대해 서비스를 제공한다는 의미이다. service() 메서드에서 만든 결과를 HTTP 프로토콜에 맞추어 클라이언트에 응답하는 것으로 요청처리를 완료한다. 시스템 운영자가 서블릿 컨테이너를 종료하거나, 웹 애플리케이션을 종료한다면, 서블릿 컨테이너는 종료되기 전에 서블릿이 마무리 작업을 수행할 수 있도록 생성된 모든 서블릿에 대해 destroy() 메서드를 호출한다.  운영 서버 배치하기 실제 운영하는 서버에 배치할 때는 배치할 파일들을 하나의 웹 아카이브 파일(.war)로 만들어서 배치 폴더에 복사한다. 먼저 웹 아카이브(Web Archive) 파일 만드는 방법부터 알아보자.\n1. [File] -\u0026gt; [Project Structure\u0026hellip;]\n2. [+] -\u0026gt; [Web Application: Archive] -\u0026gt; [For \u0026lsquo;Project Name:war exploded\u0026rsquo;]\n3. [Build] -\u0026gt; [Build Artifacts\u0026hellip;] -\u0026gt; [Build Artifact] 팝업 -\u0026gt; 2번절에서 생성한 Artifact Build 한다.\n4. .war 파일이 정상적으로 생성되었음을 확인할 수 있다.\nWeb ARchive 파일이 준비되었으면 운영 서버 배치 과정을 익혀보자.\n5. 톰캣 서버가 설치된 폴더에 있는 /webapps 디렉터리에 생성된 .war파일을 붙여넣고, 톰캣 실행 명령어를 사용하여 서버를 실행 시킨다. (본인은 유닉스 환경이라 startup.sh 명령어를 사용했다.)\n6. 톰캣 배치 폴더에 web03_war 폴더가 새로 만들어졌다.\n서블릿 컨테이너가 war03.war 파일을 실행하기 위해 압축해제하면서 만들어진 폴더이다. 참고로 webapps는 웹 애플리케이션을 배치하기 위한 폴더이다.\n7. 톰캣 서버 실행 후 경로에 접속한다.\n위 서블릿 실행 예제의 웹 애플리케이션 서버와 동일하게 정상 접속된다.\n  Java EE 기술 중에서 서블릿, JSP 등 웹 관련 부분만 구한 서버도 있다. 이런 서버를 \u0026lsquo;서블릿 컨테이너\u0026rsquo; 또는 \u0026lsquo;웹 컨테이너\u0026rsquo;라고 한다. 아파치 재단의 Tomcat, Caucho의 Resin, 오픈 프로젝트의 Jetty 등이 있다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/servlet/servlet-programing-basic-step2/","summary":"개발환경: IntelliJ IDEA 2021.2 (Utimate Edition)\n 목표  서블릿 프로그래밍을 통해 웹 애플리케이션 만드는 방법을 숙지한다. Servlet 인터페이스를 이해한다.  서블릿 클래스 만들기 다음과 같이 servlets 패키지에 javax.servlet.Servlet 인터페이스를 구현한 HelloWorld 클래스를 만들었다.\nweb/src/lesson03.servlets/HelloWorld.java package lesson03.servlets; import java.io.IOException; import javax.servlet.Servlet; import javax.servlet.ServletConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; public class HelloWorld implements Servlet { ServletConfig config; @Override public void init(ServletConfig config) throws ServletException { System.out.println(\u0026#34;init() 호출됨\u0026#34;); this.config = config; } @Override public void destroy() { System.","title":"[서블릿 프로그래밍 기본] 서블릿 인터페이스"},{"content":"HTTP 헤더 개요 앞서 간단히 정리했었던 HTTP 메시지 내용을 다시 한번 정리해보자.\nHTTP 헤더  HTTP 전송에 필요한 모든 부가정보를 헤더가 포함한다.\n예) 메시지 바대의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보 캐시 관리 정보 등\n HTTP 헤더 예제  header-field는 아래의 형태로 사용 (헷갈리면 위 예제를 참고하자)  field-name \u0026ldquo;:\u0026rdquo; OWS field-value OWS (OWS: 띄어쓰기) field-name은 대소문자 구분이 없다.   표준 헤더 필드가 굉장히 많고, 필요시 임의의 헤더를 추가할 수도 있다.  HTTP 표준 변화  RFC723x 변화  1999년 RFC2616 표준이 폐기되고, 2014년 RFC7230~7235로 HTTP 표준이 개정되면서 엔티티(Entity)라는 용어가 표현(Representation)이라는 용어로 대체    RFC7230 스펙  RFC2616에서 쓰이던 엔티티(Entity)라는 용어가 표현(Representation)이라는 용어로 대체 메시지 본문(Message Body)을 통해 표현 데이터 전달, 메시지 본문을 페이로드(Payload)라고도 한다. 표현은 요청이나 응답에서 전달할 실제 데이터를 의미한다.  표현(Representation) = 표현 헤더(Representation Metadata) + 표현 데이터(Representation Data)   표현 헤더는 표현 데이터를 해석할 수 있는 정보를 제공한다.  데이터 유형(html, json), 데이터 길이, 압축 정보 등    왜 표현이라고 정의 했을까?\n예를 들어 회원 조회 내역을 HTML로 제공해준다 가정해보자. DB에 저장되어있는 회원 리소스를 HTTP로 전송할 때 HTML, JSON 등으로 다양하게 표현할 수 있다. 그래서 실제 전달 데이터를 표현이라고 정의했다.\n표현  표현 헤더는 전송, 응답 둘 다 사용할 수 있다.\n  Content-Type: 표현 데이터의 형식 Content-Encoding: 표현 데이터의 압축 방식 Content-Language: 표현 데이터의 자연 언어 Content-Length: 표현 데이터의 길이  Content-Length는 사실 표현이라고 보긴 어렵고 메시지 본문(Payload) 헤더로 분류    하나씩 자세하게 살펴보자.\nContent-Type 표현 데이터의 형식 설명\n 미디어 타입, 문자 인코딩  예) text/html; charset=utf-8, application/json(기본 utf-8), image/png    Content-Encoding  표현 데이터에 대한 인코딩\n  표현 데이터를 압축하기 위해 사용 데이터를 전달하는 곳에서 압축 후 인코딩 헤더를 추가한다.  데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제하기 때문이다.  예) gzip, deflate, identity      Content-Language  표현 데이터의 자연 언어\n  표현 데이터의 자연 언어를 표현  한국 클라이언트로 애플 공식 사이트 접속 시 Content-Language: en으로 응답이 오면 국가 또는 지역을 선택하세요와 같은 부가 서비스를 위한 헤더로도 사용할 수 있다.    Content-Length  표현 데이터의 길이\n  바이트 단위 Transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안된다.  ","permalink":"https://5hdumat.github.io/posts/network/http-header-outline/","summary":"HTTP 헤더 개요 앞서 간단히 정리했었던 HTTP 메시지 내용을 다시 한번 정리해보자.\nHTTP 헤더  HTTP 전송에 필요한 모든 부가정보를 헤더가 포함한다.\n예) 메시지 바대의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보 캐시 관리 정보 등\n HTTP 헤더 예제  header-field는 아래의 형태로 사용 (헷갈리면 위 예제를 참고하자)  field-name \u0026ldquo;:\u0026rdquo; OWS field-value OWS (OWS: 띄어쓰기) field-name은 대소문자 구분이 없다.   표준 헤더 필드가 굉장히 많고, 필요시 임의의 헤더를 추가할 수도 있다.","title":"[HTTP 일반헤더] HTTP 헤더 개요"},{"content":" 개발환경: IntelliJ IDEA 2021.2 (Utimate Edition)\n 목표  서블릿 프로그래밍을 통해 웹 애플리케이션 만드는 방법을 숙지한다. Servlet 인터페이스를 이해한다.  웹 프로젝트 준비 책은 이클립스 예제만 있어 IntelliJ Dynamic Web Project 생성 방법을 따로 숙지해야 했다.\n프로젝트 생성  1. [New Project] -\u0026gt; [SDK만 선택] -\u0026gt; [Next]\n   2. [프로젝트 명과 경로 지정] -\u0026gt; [Finish]\n 3. [생성된 프로젝트 오른쪽 클릭] -\u0026gt; [Add Framework Support\u0026hellip;]\n 4. [Web Application (4.0) 체크] -\u0026gt; [Versions 선택] -\u0026gt; [OK]\nweb.xml은 필요에 따라 선택한다.\n 5. 웹 프로젝트 생성 완료\n[Eclipse Dynamic Project]와 비슷한 폴더 구조가 생성되었다.\n  src\n자바 소스 파일을 두는 폴더이다.\n앞으로 이 폴더에 서블릿 클래스나 필터, 리스너 등 필요한 모든 자바 클래스 파일을 둘 것이다. .properties도 이 폴더에 둔다.\n  web\nEclipse의 WebContent와 동일하다.\nHTML, CSS, JavaScript, JSP, 이미지 파일 등 웹 콘텐츠를 두는 폴더이다. 웹 애플리케이션 서버에 배치할 때 이 폴더의 내용물이 그대로 복사된다.\n  Web / Web-INF\n웹 애플리케이션의 설정과 관련된 파일을 두는 폴더이다.\n이 폴더에 있는 파일은 클라이언트에서 요철할 수 없다. 따라서 HTML이나 JavaScript, CSS 등 클라이언트에서 요청할 수 있는 파일을 이 폴더에 두어서는 안된다.\n  Web / Web-INF / web.xml\n웹 애플리케이션 배치 설명서(Deployment Descriptor) 파일이다. 영어 표현을 줄여서 DD 파일이라고도 부른다.\n서블릿이나 필터, 리스너, 매개변수, 기본 웹 페이지 등 웹 애플리케이션 컴포넌트들의 배치 정보를 이 파일에 작성한다. 서블릿 컨테이너는 클라이언트의 요청을 처리할 때 이 파일의 정보를 참고하여 서블릿 클래스를 찾거나 필터를 실행하는 등의 작업을 수행한다.\n  Web / Web-INF / lib\n자바 아카이브(Archive) 파일(.jar)을 두는 폴더이다. IntelliJ의 경우 필요하면 디렉토리를 추가 생성하면 된다.\n아카이브 파일은 클래스 파일(.class)과 프로퍼티 파일(.properties)들을 모아 놓은 보관소 파일이다. 이러한 이유로 Java ARchive의 합성어를 확장자명 .jar로 사용하고 있다.\n    6. [Add Configuration] -\u0026gt; [설치된 톰캣으로 서버 설정]   하단 [Fix] 클릭\n [artifacts] 설정 -\u0026gt; [OK]]\n    7. 톰캣 실행 후 정상 확인\n서블릿 클래스 생성 버튼을 찾을 수 없다면?   [src] -\u0026gt; [New] -\u0026gt; [Servlet] -\u0026gt; ?\n  [project] 오른쪽 클릭 -\u0026gt; [Open Module Settings]\n  [Libraries] -\u0026gt; [From Maven\u0026hellip;] 클릭\n  [javax.servlet] 검색 후 버전 선택\n  [OK] -\u0026gt; [모듈 선택]\n      서블릿 클래스를 생성할 수 있게 되었다.\n우리는 책의 예제대로 lesson03 패키지 생성 후 HelloWorld 서블릿 클래스를 생성하도록 하자.\n  프로젝트 준비가 끝났으니 다음 포스트에서 서블릿을 직접 만들어보고 구동 원리를 이해해보도록 하자.\n","permalink":"https://5hdumat.github.io/posts/servlet/servlet-programing-basic/","summary":"개발환경: IntelliJ IDEA 2021.2 (Utimate Edition)\n 목표  서블릿 프로그래밍을 통해 웹 애플리케이션 만드는 방법을 숙지한다. Servlet 인터페이스를 이해한다.  웹 프로젝트 준비 책은 이클립스 예제만 있어 IntelliJ Dynamic Web Project 생성 방법을 따로 숙지해야 했다.\n프로젝트 생성  1. [New Project] -\u0026gt; [SDK만 선택] -\u0026gt; [Next]\n   2. [프로젝트 명과 경로 지정] -\u0026gt; [Finish]\n 3. [생성된 프로젝트 오른쪽 클릭] -\u0026gt; [Add Framework Support\u0026hellip;]\n 4.","title":"[서블릿 프로그래밍 기본] 프로젝트 준비"},{"content":"서블릿을 알기전에 웹 애플리케이션을 공부하다 보면 CGI 프로그램이라는 용어를 만나게 된다. 여기서 우리는 CGI 프로그램이 무엇인지 알아보고 CGI 프로그램은 Servlet과 어떤 관계가 있는지 살펴본다.\nCGI의 이해 사용자가 직접 아이콘을 클릭하거나 명령 창(또는 터미널)을 통해 실행시키는 프로그램을 일반적으로 애플리케이션이라고 한다. 반면에 사용자가 웹 서버를 통해 간접적으로 실행시키는 프로그램을 웹 애플리케이션이라고 한다.\n웹 애플리케이션의 실행은 다음 그림과 같이 웹 브라우저가 웹 서버에게 실행을 요청한다.\nCGI 규칙 예제를 살펴보자.\n 클라이언트가 웹서버에 요청한다. 웹 서버는 클라이언트가 요청한 프로그램을 찾아서 실행한다. (CGI 규칙) 프로그램은 작업을 수행한 후 그 결과를 웹 서버에게 응답한다. (CGI 규칙) 웹 서버는 그 결과를 HTTP 형식에 맞추어 웹 브라우저에게 응답한다.  이때 웹 서버와 프로그램 사이의 데이터를 주고받는 규칙을 CGI(Common Gateway Interface)라고 한다.\nCGI는 왜 생겼을까? 웹 서버는 서버에 저장되어 있는 정적 컨텐츠(html, 이미지)만 제공할 수 있다. 초창기 웹 사이트는 대부분 정적인 웹사이트였다.\n하지만 사람들은 웹 서버가 클라이언트의 요구에 따라 동적으로 컨텐츠를 만들어 제공할 수 있게 되길 원했다. 그래서 동적 컨텐츠를 생성할 수 있는 프로그램을 만들게 되었다.\n이렇게 생겨난 프로그램과 웹 서버 간에 데이터를 주고 받을 수 있는 규격을 CGI라고 하며, CGI 규칙에 따라 웹 서버와 데이터를 주고 받도록 작성된 프로그램을 CGI 프로그램이라고 한다.\n 서블릿과 서블릿 컨테이너 서블릿 (Servlet)  자바로 만든 CGI 프로그램을 서블릿 (Servlet) 이라고 한다.\n 자바 서블릿이 다른 CGI 프로그램과 다른 점은, 웹 서버와 직접 데이터를 주고받지 않으며, 전문 프로그램에 의해 관리된다는 것이다.\n서블릿 컨테이너 (Servlet Container)  서블릿의 생성과 실행, 소멸 등 생명주기를 관리하는 프로그램을 서블릿 컨테이너 (Servlet Container) 라고 한다.\n 서블릿 컨테이너가 서블릿을 대신하여 CGI 규칙에 따라 웹 서버와 데이터를 주고 받는다. 따라서 서블릿 개발자는 더 이상 CGI 규칙에 대해 알 필요가 없다.\n대신 우리는 아래의 예제처럼 서블릿과 서블릿 컨테이너 사이의 규칙을 알아야 한다.\n먼저 서블릿, JSP와 Java EE의 관계를 이해하고, WAS(Web Application Server)가 무엇인지 간략하게 알아보자.\nJava EE 기술들  JAVA EE(Java Enterprise Edition)는 기업용 애플리케이션과 클라우드 애플리케이션 개발에 필요한 여러 가지 복합적인 기술들을 정의하고 모아 놓은 것이다.\n Servlet, JSP(Java Server Page) 도 Java EE에 포함되어 있는 하위 기술들이며, 웹을 기반으로 한 클라이언트·서버 기술을 정의하고 있다. 1\n즉, 자바로 웹 애플리케이션을 개발한다는 것은 바로 이 서블릿과 JSP 기술을 사용하여 애플리케이션을 개발한다는 의미이다.\nWAS와 서블릿 컨테이너  WAS\n  위 예제 처럼 서블릿 컨테이너와 같이 웹 기술을 기반으로 동작되는 애플리케이션 서버를 WAS(Web Application Server) 라고 한다. WAS는 웹 기반 애플리케이션의 생성과 실행, 소멸을 관리한다.\nJava에서 말하는 WAS란, Java EE 기술 사양을 준수하여 만든 서버를 카리킨다. 다른 말로 Java EE 구현체(Implementation)2 라고도 한다.\n 서블릿 컨테이너   Java EE 기술 중에서 서블릿, JSP 등 웹 관련 부분만 구현한 서버도 있다. 이런 서버를 서블릿 컨테이너 또는 웹 컨테이너라고 한다. 대표적으로 아파치 재단의 톰캣, Caucho의 Resin, 오픈 프로젝트 Jetty 등이 있다.\n    Java EE Servlet/JSP Tomcat JBoss WebLogic JEUS     JavaEE 8 4.0 / 2.3 9.0.x      JavaEE 7 3.1 / 2.3 8.5.x      JavaEE 6 3.0 / 2.2 7.0.x 7.x(all) / 6.x(almost) 12.x 6.x   JavaEE 5 2.5 / 2.1 6.0.x 5.0 10.x 6.x      버전별 Java EE 기술 목록은 링크에서 확인할 수 있다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 상용 제품으로는 티맥스소프트의 제우스(JEUS), 오라클의 웹로직(WebLogic), IBM의 웹스피어(WebSphere), 레드햇의 제이보스 엔터프라이즈(JBoss Enterprise) 등이 있다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/servlet/servlet/","summary":"서블릿을 알기전에 웹 애플리케이션을 공부하다 보면 CGI 프로그램이라는 용어를 만나게 된다. 여기서 우리는 CGI 프로그램이 무엇인지 알아보고 CGI 프로그램은 Servlet과 어떤 관계가 있는지 살펴본다.\nCGI의 이해 사용자가 직접 아이콘을 클릭하거나 명령 창(또는 터미널)을 통해 실행시키는 프로그램을 일반적으로 애플리케이션이라고 한다. 반면에 사용자가 웹 서버를 통해 간접적으로 실행시키는 프로그램을 웹 애플리케이션이라고 한다.\n웹 애플리케이션의 실행은 다음 그림과 같이 웹 브라우저가 웹 서버에게 실행을 요청한다.\nCGI 규칙 예제를 살펴보자.\n 클라이언트가 웹서버에 요청한다. 웹 서버는 클라이언트가 요청한 프로그램을 찾아서 실행한다.","title":"서블릿(Servlet) 이란?"},{"content":"HTTP 상태코드  클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능\n  1xx (Informational): 요청이 수신되어 처리중 (거의 사용하지 않으므로 생략) 2xx (Successful): 요청 정상 처리 3xx (Redirection): 요청을 완료하려면 추가 행동이 필요 4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함  만약 모르는 상태 코드가 나타나면?  클라이언트는 상위 상태코드로 해석해서 처리한다.\n클라이언트 입장에서 상태코드에 대한 이해가 어려울 경우 큰 범위로 이해하면 된다.\n  299 ??? -\u0026gt; 2xx(Successful) 451 ??? -\u0026gt; 4xx(Client Error) 599 ??? -\u0026gt; 5xx(Server Error)  상태코드별 특징 2xx (Successful)  클라이언트의 요청을 성공적으로 처리했다는 의미\n   200 OK\n 서버가 클라이언트의 요청을 성공적으로 처리했다는 의미        201 Created\n 서버에 새로운 리소스가 정상적으로 생성되었다는 의미     클라이언트가 POST로 리소스 생성 요청 서버는 새로운 리소스를 생성 서버는 새로 생성된 리소스 경로를 Location 헤더 필드에 기입한 후 응답\n(이때까지 클라이언트는 리소스 URI를 알지 못한다.) 클라이언트는 서버 응답의 헤더 필드(Location)로 리소스 URI 식별      202 Accepted\n 요청이 접수되었으나 처리가 완료되지 않았음을 의미  배치 처리 응답으로 사용\n예) 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리하는 경우      204 No Content\n 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음을 의미  웹 문서 편집기 save 버튼을 예로들 수 있다.  save 버튼의 결과로 아무 내용이 없어도 된다. save 버튼을 눌러도 같은 화면을 유지해야 한다. 즉, 결과 내용 없이 204 메시지 만으로 성공을 인식할 수 있다        2xx (Successful) 정리 성공 응답을 다양하게 한다고 무조건 좋은것만은 아니다.\n너무 다양한 응답은 클라이언트에서 신경써야할게 너무 많기 때문이다.\n실무에선 200, 201 정도로 범위를 좁혀서 사용하기도 한다.\n 3xx (Redirection)  요청을 완료하기 위해 유저 에이전트(브라우저)에서 추가 조치가 필요한 경우를 의미\n서버가 클라이언트에 재요청 응답을 보낸다.\n 리다이렉션의 이해 웹 브라우저는 3xx 응답 결과에 Location 헤더 정보가 있으면, Location 경로로 자동 이동시킨다.\n이를 리다이렉트(Redirect)라고 한다.\n자동 리다이렉트의 흐름  클라이언트가 서버의 /event 경로로 요청을 보낸다. 서버는 리소스 경로가 바뀌었음을 클라이언트에 응답한다.\n응답 헤더에 상태코드와 바뀐 리소스 경로를 담아 응답 웹 브라우저는 서버의 응답에 따라 다시 요청한다. 서버는 정상적인 리소스 경로로 요청한 클라이언트에게 데이터를 반환한다.  리다이렉션 종류   영구 리다이렉션 (301, 308)\n  특정 리소스의 URI가 영구적으로 이동했다는 의미\n  리소스가 바뀌기 전 URL은 사용할 수 없다.\n  리소스가 바뀌었다는 서버의 응답에 따라 검색 엔진 등에서 변경을 인지하고 리다이렉트한다.\n  301 Moved Permanently\n 리다이렉트 요청 시 클라이언트의 요청 메서드가 GET으로 변하고, 본문이 제거될 수도 있다. (MAY)\n    308 Permanent Redirect\n 301과 기능은 같음 리다이렉트 요청 시 클라이언트의 요청 메서드와 본문 유지을 유지한다.\n     💡 301의 명확하지 않은 스펙때문에 308 스펙이 나오게 되었지만, 보통 실무에선 바뀐 리소스에 대한 요청 메서드를 유지할 필요가 없다.\n대부분 바뀐 페이지의 내부 파라미터나 정보들이 달라지기 때문이다. 이러한 이유로 보통 301 상태코드를 많이 사용한다.\n      일시적인 리다이렉션 (302, 307, 303)\n  리소스의 URI가 일시적으로 변경되었다는 의미\n  영구 리다이렉션과 다르게 검색 엔진 등에서 URL을 변경하면 안된다.\n  302 Found\n 리다이렉트 요청 시 클라이언트의 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있다. (MAY)\n     💡 클라이언트의 요청 메서드가 유지되도록 의도했으나, 스펙이 디테일하게 적혀있지 않아 의도한 스펙과 다르게 브라우저 구현이 이루어졌다.\n이러한 이슈때문에 307, 303 스펙이 나오게 되었다.\n   307 Temporary Redirect\n 302와 기능은 같음. 리다이렉트 요청 시 요청 메서드와 본문이 유지되어야 한다. (MUST NOT)    303 See Other\n 302와 기능은 같음 클라이언트가 요청한 리소스를 다른 URI에서 GET 요청을 통해 얻어야 함을 의미한다.    PRG: Post/Redirect/Get\n 위 예제는 PRG 사용 전 예제이다.\n클라이언트의 마지막 요청이 이루어진 후 새로고침을 했더니 재요청 되었다. 중복 주문이 발생한 것이다.\n 원칙적으로 이러한 이슈를 예방하려면 서버에서 주문번호 사용 여부에 따라 폐기하고 재사용을 못하게 하는 등의 예외처리가 이루어져야 한다. 하지만 예외처리는 하면 할수록 좋다했다.\n 클라이언트 차원에서 추가적인 방지가 어떻게 가능한지 알아보자.\n  위 예제는 PRG 사용 후 예제이다. 단계별로 알아보자.\n  클라이언트가 서버에 주문 요청 (POST) 서버는 응답을 200 OK가 아닌 302 Found 혹은 303 See Other로 응답 브라우저는 상태 코드를 감지하고 /order-result/19로 자동 리다이렉트 (GET) 서버는 주문 데이터를 쌓는게 아닌 19번 주문 정보를 조회하여 주문완료 HTML 화면을 만들어 200 OK 응답 URL이이미 POST -\u0026gt; GET으로 리다이렉트 되면서 새로 고침이 이루어져도 GET으로 결과 화면만 조회     302, 307, 303? 그래서 뭘 써야 하나요?\n   잠깐 정리\n 302 Found -\u0026gt; 요청 메서드가 GET으로 변할 수 있음 307 Temporary Redirect -\u0026gt; 요청 메서드가 변하면 안됨 303 See Other -\u0026gt; 요청 메서드를 GET으로 변경    역사\n 처음 302 스펙의 의도는 HTTP 메서드를 유지하는 것이었다. 하지만 많은 웹 브라우저가 이 표준을 위반하는 방식으로 구현 되어 원래 요청에 사용된 유형(예: POST)에 관계없이 새 요청의 요청 메서드를 GET으로 변경한다. 이러한 이유로 HTTP/1.1(RFC 2616)은 두 동작 사이를 명확하게 하기 위해 새로운 상태 코드 307, 303을 추가했다.1    현실\n 307, 303을 권장하지만 현실적으로 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용  즉 자동 리다이렉트 시 GET으로 변해도 되면 그냥 302를 사용해도 큰 문제는 없다.           특수 리다이렉션\n 304 Not Modified   캐시를 목적으로 사용한다.\n참고로 대부분의 브라우저는 HTTP conditional request를 사용하여 자동 캐시 기능을 지원한다.\n  조건부 GET, HEAD 요청 시 보통 304 상태 코드를 사용한다. 클라이언트가 조건부 GET 요청을 실행하고 접근이 허용되었지만 문서가 수정되지 않았다면, 서버는 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다. 304 응답은 메시지-바디 를 절대 포함하면 안된다. (로컬 캐시를 사용해야 한다는 서버의 요청이 명확하기 때문이다.)     4xx (Client Error)  클라이언트의 요청에 잘못된 문법등으로 서버가 요청을 수행할 수 없다는 의미\n 4xx 상태 코드는 오류의 원인이 클라이언트에 있다. 중요한 점은 클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에 똑같은 요청으로 재시도가 이루어져도 계속 실패한다는 점이다.     400 (Bad Request)\n 클라이언트의 요청에 잘못된 문법등으로 서버가 요청을 수행할 수 없다는 의미 요청 구문, 메시지 등의 오류 클라이언트는 요청 내용을 재검토하고 다시 보내야한다.  예) 요청 파라미터가 잘못되었거나, API 스펙이 맞지 않을 때      401 (Unauthorized)\n 클라이언트가 해당 리소스에 대한 인증이 필요하다는 의미 인증(Authentication) 되지 않았을때 응답 서버는 401 오류 발생 시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명해야한다. 참고  인증(Authentication): 본인이 누구인지 확인하는 과정 (로그인) 인가(Authorication): 권한 부여 (Admin 권한 처럼 특정 리소스에 접근할 수 있는 권한, 인증이 있어야 인가가 있다.)\n-\u0026gt; 본인은 마치 서버가 어서와~이제이션 하는 것 같다고 외웠다.      403 (Forbidden)\n 서버가 요청을 이해했지만 승인을 거부했다는 의미 주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우 이 상태코드로 응답한다.  예) Admin 등급이 아닌 사용자가 로그인은 했지만, 어드민 등급의 리소스에 접근하려고 하는 경우      404 (Not Found)\n 요청 리소스를 찾을 수 없다는 의미 추가적으로 클라이언트가 권한이 부족한 리소스에 접근할 때 서버가 404 상태코드를 사용한기도 한다.     5xx (Server Error)  서버 문제로 오류가 발생했다는 의미\n서버에 문제가 있기 때문에 재시도하면 성공할 수도 있다.\n   500 (Internal Server Error)\n 서버 문제로 오류 발생가 발생했다는 의미 무언가 애매한 서버오류일 때 통상 500 상태코드로 반환한다.    503 (Service Unavailable)\n 서비스 이용 불가를 의미 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없을 때 사용한다. Retry-After 헤더 필드로 얼마뒤에 복구되는지 포함시켜 응답할 수 있다. 보통 오류 픽스에 대한 예상시간은 예측할 수 없기 때문에 보통 500에러로 많이 사용한다.    5xx (Server Error) 정리 정말 서버에 어떤 이슈나 장애가 발생했을 때만 5xx 오류를 사용해야 한다.\n(NullException이나 DB장애 등)\n예를들어 클라이언트의 요청이 API 스펙상 문제가없을 때 비즈니스 로직에서 예외처리 가능한 케이스인지 판단하여 서버단에서 예외처리를 진행해야한다.\n  https://en.wikipedia.org/wiki/HTTP_302\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/network/http-status-code/","summary":"HTTP 상태코드  클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능\n  1xx (Informational): 요청이 수신되어 처리중 (거의 사용하지 않으므로 생략) 2xx (Successful): 요청 정상 처리 3xx (Redirection): 요청을 완료하려면 추가 행동이 필요 4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함  만약 모르는 상태 코드가 나타나면?  클라이언트는 상위 상태코드로 해석해서 처리한다.\n클라이언트 입장에서 상태코드에 대한 이해가 어려울 경우 큰 범위로 이해하면 된다.","title":"HTTP 상태 코드"},{"content":"목표  회원 관리용 API 설계  POST, PUT의 차이점을 이해한다. GET, POST만 지원하는 HTML FORM 태그 제약조건 속에서의 사용법을 숙지한다.    HTTP API 설계 예시 POST 기반 등록  회원 관리 시스템 API를 설계한다고 가정해보자.\n  회원 목록 /members -\u0026gt; GET 회원 등록 /members -\u0026gt; POST 회원 조회 /members/{id} -\u0026gt; GET 회원 수정 /members/{id} -\u0026gt; PATCH, PUT, POST 회원 삭제 /members/{id} -\u0026gt; DELETE  이전 포스트에서 URI는 리소스를 식별하는 통합된 방법이라고 배웠다.\n 중요한 포인트는 URI 설계는 항상 리소스 기반으로 해야한다는 것이다.\n리소스가 아닌 행위를 식별하고자 할 땐 HTTP 메서드(GET, POST, DELETE 등)를 활용한다.\n POST 기반 리소스 등록 특징   리소스 생성 요청 시 클라이언트는 등록될 리소스의 URI를 모른다.\n PUT과의 차이점이다. POST /members    요청을 받은 서버는 새로 등록된 리소스 URI를 생성하여 전달한다.\n HTTP/1.1 201 Created\nLocation: /members/100    컬렉션(Collection)\n 서버가 관리하는 리소스 디렉토리를 컬렉션이라 한다.  서버가 리소스 URI를 생성하고 관리한다. 위 예제에선 /members 를 컬렉션이라 한다.       PUT 기반 등록  원격지의 파일을 관리하는 파일 관리 시스템 API를 설계한다고 가정해보자.\n  파일 목록 /files -\u0026gt; GET 파일 조회 /files/{filename} -\u0026gt; GET 파일 등록 /files/{filename} -\u0026gt; PUT 파일 삭제 /files/{filename} -\u0026gt; DELETE 파일 대량 등록 /files -\u0026gt; POST  위 예제는 새로운 자원을 등록할때 PUT 메서드를 사용했다.\nPOST와 어떤 차이점이 있는걸까?\nPUT 기반 등록 특징  클라이언트가 리소스 URI를 알고 있어야 한다.  POST와의 차이점이다. PUT은 아래 예제와 같이 요청 할때 리소스 URI를 지정하여 요청한다.  PUT /files/{filename}     클라이언트가 직접 리소스 URI를 관리한다. 이런 관리 방식을 스토어(Store)라고 한다.  클라이언트가 관리하는 리소스 저장소를 스토어라고 한다. 클라이언트가 리소스 URI를 알고 관리한다. 위 예제에선 /files 를 스토어라고 한다.    PUT과 POST의 차이점을 비교해보았다.\n실무에선 보통 POST 기반의 신규 자원 등록을 많이 사용한다.\nHTML FORM 사용  HTML FORM은 GET, POST만 지원한다.\nAJAX 등을 활용하면 다양한 메서드로 API 통신이 가능하지만 이번 포스트에선 순수 HTML FORM만을 다룬다.\n  회원 목록 /members -\u0026gt; GET 회원 등록 폼 /members/new -\u0026gt; GET 회원 등록 /members/new -\u0026gt; POST 회원 조회 /members/{id} -\u0026gt; GET 회원 수정 폼 /members/{id}/edit -\u0026gt; GET 회원 수정 /members/{id}/edit -\u0026gt; POST 회원 삭제 /members/{id}/delete -\u0026gt; POST  GET, POST만을 이용한 회원 관리 URI 설계 예시이다.\n위와 같은 제약조건 속에서 해결하기 애매한 부분은 /new, /edit, /delete와 같이 동사로 된 리소스 경로를 사용하여 해결했다.\n이렇게 동사로 된 리소스 경로를 컨트롤 URI라고 부른다.\n주의점 실무에선 컨트롤 URI가 굉장히 많이 사용되고 있다. 하지만 컨트롤 URI를 절대 남용해선 안된다.\n우리는 최대한 리소스라는 개념을 가지고 URI 설계를 이뤄나가야 하며, 리소스 기준으로 식별이 불가능할 때만 컨트롤 URI를 사용해야 한다.\n정리  POST 기반 등록  서버가 리소스 URI 결정   PUT 기반 등록  클라이언트가 리소스 URI 결정   순수 HTML FORM 사용 HTTP 메서드만으론 해결하기 애매한 부분은 동사로 된 리소스 경로를 사용  참고하면 좋은 URI 설계 개념   문서(document)\n 단일 개념(파일 하나, 객체 인스턴스, 데이터베이스 row)\n/members/100, /files/star.jpg    컬렉션(collecion)\n 서버가 관리하는 리소스 디렉터리 서버가 리소스의 URI를 생성하고 관리\n/members    스토어(store)\n 클라이언트가 관리하는 자원 저장소 클라이언트가 리소스의 URI를 알고 관리\n/files    컨트롤러(controller), 컨트롤 URI\n 문서, 컬렉션, 스토어로 최대한 해결해본 후 더 이상 해결이 어려운 추가 프로세스 실행 동사를 직접 사용\n/members/{id}/delete    ","permalink":"https://5hdumat.github.io/posts/network/http-api-design/","summary":"목표  회원 관리용 API 설계  POST, PUT의 차이점을 이해한다. GET, POST만 지원하는 HTML FORM 태그 제약조건 속에서의 사용법을 숙지한다.    HTTP API 설계 예시 POST 기반 등록  회원 관리 시스템 API를 설계한다고 가정해보자.\n  회원 목록 /members -\u0026gt; GET 회원 등록 /members -\u0026gt; POST 회원 조회 /members/{id} -\u0026gt; GET 회원 수정 /members/{id} -\u0026gt; PATCH, PUT, POST 회원 삭제 /members/{id} -\u0026gt; DELETE  이전 포스트에서 URI는 리소스를 식별하는 통합된 방법이라고 배웠다.","title":"HTTP API 설계"},{"content":"데이터 전송 방식  데이터 전송 방식은 크기 2가지가 있다.\n   쿼리 파라미터를 통한 데이터 전송\n GET  정적 데이터 조회 (이미지, 정적 텍스트 문서 등) 검색 필터를 이용한 목록 조회 (리스스 조회 및 정렬)      메시지 바디를 통한 데이터 전송\n POST, PUT, PATCH  회원 가입, 상품 주문, 리소스 등록, 리소스 변경      데이터 전송 예시 상황 서버에 데이터가 전송되는 4가지 상황을 알아보자.\n정적 데이터 조회  쿼리 파라미터 없이 /static/star.jpg와 같이 단순 URI 경로만을 이용해 리소스를 조회한다.\n  보통 이미지, 정적 텍스트 문서와 같은 정적 데이터를 조회할 때 사용한다. 조회이므로 보통 GET 메서드를 사용한다.  동적 데이터 조회 정적 데이터 조회는 단순 이미지나 텍스트 문서를 조회할 때 사용하기 때문에 쿼리 파라미터가 필요하지 않았다.\n그렇다면 쿼리 파라미터는 언제 쓰이는 걸까?\nhello라는 검색어를 통해 구글링하는 예제이다.\n쿼리 파라미터 q=hello\u0026amp;hl=ko가 리소스 경로뒤에 나열되어있다.\n 주로 검색 시 조회 조건을 줄여주는 필터, 조회 데이터를 정렬하는 정렬 조건에 사용한다. 조회이므로 보통 GET 메서드를 사용한다.  HTML form 데이터 전송 HTML form 태그를 이용한 데이터 전송 과정을 알아보자.\n참고로 form 태그는 GET / POST 메서드만 지원한다.\n1. GET / POST 데이터 전송 위 예제는 간단한 회원가입 요청/응답 예제이다.\n우리가 주의깊게 봐야할 부분은 응답 헤더와 메시지 바디이다.\nContent-Type: applicaton/x-www-form-urlencoded username=kim\u0026amp;age=20    form 태그의 입력값은 기본적으로 applicaton/x-www-form-urlencoded 형식으로 인코딩되어 보내진다.\n 예) abc김 -\u0026gt; abc%EA%b9%80    공백 라인 다음 메시지 바디 영역에 username=kim\u0026amp;age=20라는 데이터가 출력되어있다.\n POST 방식이기 때문이다.  GET 메서드는 요청 데이터가 URL에 포함되기 때문에 메시지 바디가 비어있었다.\nform method를 get으로 바꿨을 때 예제이다.\n      2. multipart/form-data 방식의 POST 전송 웹 서버에 바이너리 데이터를 보내수 있도록 고안된 multipart 인코딩 방식이다.\n바이너리 데이터 전송 예제\n form 태그의 enctype 속성이 multipart/form-data로 지정되어 있다.  form 태그의 exctype의 기본 속성은 applicaton/x-www-form-urlencoded이기 때문이다.   응답 헤더의 Content-Type에 미디어 형식과 파트 구분자가 정의되어있다.  예제의 파트 구분자는 boundary=-----XXX 이다.    boundary=\u0026mdash;\u0026ndash;XXX?\nGET / POST 방식은 데이터를 전달할 때 Key=value 형태를 사용한다.\n매개변수의 Key, Value는 \u0026amp;, =로 분리한다.\n이 방식은 문자 데이터를 보낼 때는 문제가 없지만, 이미지나 동영상과 같은 바이너리 데이터를 보낼 때는 문제가 발생할 수 있다.\n바이너리 데이터 안에 \u0026amp;, =가 포함되어 있다면 잘못 해석될 수 있기 때문이다.\n이러한 문제점을 해결하고 매개변수를 정확히 구분하기 위해 파트 구분자를 사용하게 되었다.\n참고로 구분자는 브라우저가 임의로 생성한다.\nHTTP API 데이터 전송 백엔드 시스템끼리 통신할 때 사용한다.\nServer To Server  앱 클라이언트  아이폰, 안드로이드에서 서버로 데이터를 전송할 때 주로 사용   웹 클라이언트  Javascript를 통한 통신에 사용 (AJAX)  AJAX는 Asynchronous JavaScript and XML의 약자로 과거에는 xml이 표준이었다.\n하지만 현재는 Content-Type: apllication/json을 주로 사용한다. (사실상 표준)      ","permalink":"https://5hdumat.github.io/posts/network/http-method-uses/","summary":"데이터 전송 방식  데이터 전송 방식은 크기 2가지가 있다.\n   쿼리 파라미터를 통한 데이터 전송\n GET  정적 데이터 조회 (이미지, 정적 텍스트 문서 등) 검색 필터를 이용한 목록 조회 (리스스 조회 및 정렬)      메시지 바디를 통한 데이터 전송\n POST, PUT, PATCH  회원 가입, 상품 주문, 리소스 등록, 리소스 변경      데이터 전송 예시 상황 서버에 데이터가 전송되는 4가지 상황을 알아보자.","title":"HTTP 메서드 활용"},{"content":"HTTP 주요 메서드 종류 HTTP 메서드는 클라이언트가 서버에 요청을 할 때 서버로부터 기대하는 행동이다.\n주로 많이 사용하는 HTTP 메서드는 아래와 같다.\nGET GET은 리소스를 조회하기 위한 메서드이다.\n서버에 query(쿼리 파라미터, 쿼리 스트링)형태로 데이터를 전달한다.\n(메시지 바디를 통해 데이터를 전달할 수 있지만, 지원하지 않는 서버들이 많아 권장하지 않는다.)\n리소스 조회 과정을 살펴보자.\n  리소스 조회 예제\n   GET 메서드와 함께 /members/100 경로(path)의 리소스를 서버에 요청한다.\n    메시지를 전달받은 서버는 DBMS에서 요청받은 조건의 데이터를 조회한다.    특정 형태(예제는 JSON)의 데이터로 파싱 후 응답 메시지를 만들어 클라이언트에 전달한다.\n    클라이언트는 서버로부터 메시지를 전달받는다.    사용자가 보는 화면에 렌더링된다.      GET 메서드의 문제점과 해결방안\n 보안에 좋지 않다.\nHTTP 메서드를 공부해본 사람이라면 누구나 다 알 것이다. GET 요청은 웹브라우저의 주소창에 사용자가 입력한 정보가 그대로 노출되기 때문에 보안 문제가 발생할 수 있다.\n로그인이나 개인정보 관리와 같이 보안을 요구하는 작업에는 GET 메서드를 사용하지 않는다. 바이너리 데이터를 전송할 수 없다.\nGET 요청으로 아예 작업이 불가능한 경우도 있다. 바이너리 파일을 전송하는 경우이다. 이미지나 동영상과 같은 바이너리 파일 데이터는 URL에 붙여서 보낼 수 없다.\nBASE-64 Encoding 방식을 이용해 바이너리 데이터를 문자화 할 순 있겠지만, URI나 헤더 정보가 너무 크면 웹서버에서 처리할 수 없기 때문에 적합하지 않다.\n이와 같은 이슈는 POST 메서드와 multipart 방식으로 해결할 수 있다.    POST POST는 의미가 굉장히 많다.\n보통 클라이언트가 요청한 데이터를 서버로부터 처리해달라는 의미정도로 이해하면 된다.\n서버는 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행하며, 서버와 클라이언트는 상호 요청/응답에 대한 약속이 되어있어야 한다\n(주로 신규 리소스 등록, 프로세스 처리 등에 사용)\n신규 리소스 등록 처리 과정을 살펴보자.\n 신규 리소스 등록 예제    클라이언트는 POST 방식으로 서버의 /members 경로에 메시지 바디를 전달한다.\n(예제는 신규 리소스 등록에 대한 약속이 되어있음을 전제로 한다.)\n    POST 방식으로 데이터를 전달받은 서버는 100번이라는 신규 리소스 식별자를 생성한다.\n    서버는 생성된 신규 리소스에 대한 정보를 클라이언트에 전송한다.\n   응답 메시지에 포함된 데이터  응답 상태(201 created, 200도 무관)  201 상태값일 경우 보통 Location이라는 자원 생성 경로를 포함한다.   등록된 리소스 데이터        POST에서 요청 데이터를 어떻게 처리한다는 뜻일까? POST가 실제로 어떻게 사용되고 있는지 예시를 살펴보자.\n HTML 양식에 입력된 데이터를 서버측 데이터 처리 프로세스에 제공  HTML FORM에 입력한 정보로 회원 가입, 주문 등의 행위를 할 때 사용   게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시  게시판 글쓰기, 댓글 달기 등   서버가 아직 실별하지 않은 새 리소스 생성  신규 주문 생성   기존 자원에 데이터 추가  문서 내용 수정 및 추가    이 예시의 핵심은 (위 예제의 /members와 같은) 리소스 URI에 POST 요청을 전달받은 서버가\n요청 데이터를 어떻게 처리할지 리소스마다 스스로 정해야 한다.\n즉, POST 리소스 처리 방식은 정해진 방법이 없다.\nPOST 정리  새 리소스 생성(등록)  서버가 아직 식별하지 않는 새 리소스 생성   요청 데이터 처리 (굉장히 중요한 부분이다.)  단순히 데이터를 생성하거나, 변경하는 것을 넘어 프로세스를 처리해야 하는 경우에도 사용된다.  예) 주문 -\u0026gt; 결제완료 -\u0026gt; 배달시작 -\u0026gt; 배달완료\n단순한 값 변경을 넘어 프로세스 상태가 지속적으로 변경되는 단계에서도 POST가 쓰인다.   POST의 결과로 새로운 리소스가 생성되지 않을 수도 있다.  예) POST /orders/{orderId}/start-delivery  이전 포스트에서 URI 설계는 분명 리소스를 기준으로 해야한다고 했지만 실무에선 리소스만으로 모든 URI를 설계할 순 없다.\n(리소스만으로 설계된 URI는 굉장히 이상적인 케이스이다.)\n예제의 /start-delivery와 같이 어떤 행위(동사)를 포함하는 URI를 컨트롤 URI라고 한다.       다른 메서드로 처리하기 애매한 경우  예) JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우  이런 경우 조회이지만 메시지 바디에 조회용 데이터를 포함하여 POST로 요청해야한다.      POST 메서드는 거의 모든 행위에서 사용 가능하지만 리소스 조회는 GET 메서드를 사용해야 한다.\n(GET 메서드는 서버가 캐싱을 하기 때문이다. 반면 POST 메서드는 캐싱이 어렵다.)\nPOST 메서드를 이용한 데이터 조회는 정말 어쩔 수 없을 때만 사용하도록 하자.\nPUT PUT은 리소스를 대체할때 사용하는 메서드이다.\n디렉터리에 파일을 붙여 넣으면 동일한 파일이 있을때 덮어쓰기 되는 것과 동일하다.\n 리소스 대체 예제   리소스가 있는 경우\n1. 클라이언트가 /members/100의 경로에 리소스 전달한다.\n이때 중요한 점은 클라이언트가 리소스의 위치를 알고있다는 것이다.\n 2. 서버는 클라이언트의 요청에 따라 가지고 있던 리소스를 대체한다.\n  리소스가 없는 경우\n1. 클라이언트가 /members/100의 경로에 리소스 전달한다.\n클라이언트 요청은 서버에 리소스가 있든 없든 동일하다.\n 2. 서버는 리소스가 없으면 신규 리소스를 생성한다.\n    PUT 정리  리소스 대체   리소스가 있으면 대체하고 없으면 생성한다.\n  리소스는 일부가 아닌 완전히 대체된다는 점을 기억하자.\n예제처럼 username 필드 없이 age 필드만 보냈을 경우 username 필드가 삭제된다.\n즉, PUT 메서드는 리소스 수정 용도가 아닌 기존 리소스를 완전히 갈아치울 때 사용한다.\n  클라이언트가 리소스를 식별\n 클라이언트가 리소스의 위치를 알고 URI를 지정한다.  POST와의 큰 차이점이다.        PATCH PUT 메서드는 리소스 수정 용도로는 사용하기가 어렵다.\n그래서 나온 메서드가 PATCH 메서드이다.\n 리소스 수정 예제\n  PATCH 메서드를 지원하지 않는 서버가 종종 있다. 이럴 경우 POST 메서드로 대체 가능하다.\nDELETE 리소스를 제거하기 위한 메서드이다.\n 리소스 삭제 예제\n  HTTP 메서드의 속성 아래 예제는 HTTP 메서드 속성 표이다.\n안전? 멱등? 캐시 가능? 무언가 생소한 키워드들이 보인다.\n하나씩 알아보도록 하자.\n안전(Safe) 안전은 호출을 하더라도 리소스가 변하지 않는다는 의미이다.\n예를들어 GET 메서드는 여러번 호출해도 리소스는 변하지 않으므로 안전한 메서드이다.\n Q: 지속적 호출로 로그가 쌓여서 장애가 발생해도 안전한 메서드인가? A: 안전은 리소스만 고려한다. 그런 부분까지 고려하지 않는다.  멱등(Idempotent) # f(f(x)) = f(x) 3 × 0 = 3 × 0 x 0 × 0  실수에 \u0026lsquo;0\u0026rsquo;을 몇 번 곱하든 값이 \u0026lsquo;0\u0026rsquo;인 것처럼 요청에 대한 결과가 항상 같다면 멱등으로 간주한다.\n이러한 관점에서 클라이언트가 PUT 요청을 보냈을 때를 예로 들어보자.\n클라이언트가 서버의 응답을 읽기 전 통신장애가 발생해 요청 연결이 끊겼다.\n이때 클라이언트는 재요청을 보낼 수 있으며, 원래의 요청이 정상 동작했더라도 재호출에 대한 응답값만 달라질 뿐 결과는 클라이언트의 의도와 동일할 것이다.\n즉, 멱등의 기준은 값뿐만 아니라 클라이언트의 의도와 결과가 동일한지에 대한 판단 근거가 되기도 한다.\n안전(Safe)과 멱등(Idempotent) 안전한 메소드(Safe methods)는 위에서 설명했듯이 서버 측의 리소스 정보를 변경하지 않는 메서드를 가리킨다.\n이를 멱등성과 연관지어 메서드를 생각해볼 수 있다.\n  GET: 한 번 조회하든, 두 번 조회하는 같은 결과가 조회된다.\n 멱등성을 가졌으면서 안전한 메서드이다.    PUT: 기존 리소스를 요청 리소스로 대체한다. 따라서 같은 요청을 여러번 해도 최종 결과는 같다.\n 멱등성은 가졌지만 리소스가 변경되므로 안전하지 않은 메서드이다.    DELETE: 결과를 삭제한다. 같은 요청을 여러번해도 결과는 동일하다.\n 마찬가지로 멱등성은 가졌지만 리소스가 변경되므로 안전하지 않은 메서드이다.    POST: 보통 요청 데이터를 처리하고 리소스를 생성할 때 사용한다.\n 호출 중 에러가 발생해 재요청을 했을 때 리소스가 중복으로 추가될 수 있으므로 멱등하지도 안전하지도 않은 메서드이다.    Q: 재요청 중간에 다른 곳에서 리소스를 변경해버리면?\n  A: 멱등성은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다. 여러 사용자가 있더라도 한 사용자의 동일 요청에 대해서만 고려한다.\n하지만 서버는 GET 호출 중간에 리소스가 변경되는 것을 비멱등성을 가졌다고 간주하고 멱등성 요청에 대한 부작용 즉, 비멱등성 사이드 이팩트에 대비해야한다.\n  캐시 가능(Cacheable) 요청에 대한 리소스는 한번 호출되고 난 후 기본적으로 캐싱이 된다. (웹 브라우저에 저장되는 등)\n하지만 클라이언트의 요청을 KEY로 캐싱을 하게 되는데 이는 메서드마다 구현 난이도가 다르다.\n GET, HEAD, POST, PATCH 캐시 가능  실제로는 GET, HEAD 정도만 캐싱되고 있다.  POST, PATCH는 요청 바디까지 캐시 키로 고려해야 한다. 구현이 쉽지 않다.      실무에서는 거의 GET 메서드 위주로 캐싱이 구현되어 있다.\n","permalink":"https://5hdumat.github.io/posts/network/http-method/","summary":"HTTP 주요 메서드 종류 HTTP 메서드는 클라이언트가 서버에 요청을 할 때 서버로부터 기대하는 행동이다.\n주로 많이 사용하는 HTTP 메서드는 아래와 같다.\nGET GET은 리소스를 조회하기 위한 메서드이다.\n서버에 query(쿼리 파라미터, 쿼리 스트링)형태로 데이터를 전달한다.\n(메시지 바디를 통해 데이터를 전달할 수 있지만, 지원하지 않는 서버들이 많아 권장하지 않는다.)\n리소스 조회 과정을 살펴보자.\n  리소스 조회 예제\n   GET 메서드와 함께 /members/100 경로(path)의 리소스를 서버에 요청한다.\n    메시지를 전달받은 서버는 DBMS에서 요청받은 조건의 데이터를 조회한다.","title":"HTTP 메서드"},{"content":"API URI를 만들어보자 회원 정보 관리 API를 요구사항대로 만든다고 가정해보자.\n요구사항  회원 목록 조회 회원 조회 회원 등록 회원 수정 회원 삭제  URI 설계가 끝난 후 경로가 나왔다.\n 회원 목록 조회 /read-member-list 회원 조회 /read-member-by-id 회원 등록 /create-member 회원 수정 /update-member 회원 삭제 /delete-member  뭔가 그럴듯하다. 실제 현업에서도 위와 같은 설계가 많이 이루어진다.\n하지만 이것은 좋은 URI 설계일까?\n우리는 위와 같이 설계된 URI가 좋은 설계인지에 대해서는 다시한번 고민해 봐야 한다.\n결론부터 말하자면 위와 같은 URI 설계는 좋지 않은 설계이다.\nURI 설계의 기준은 어떤 행위가 아닌 리소스를 기준으로 이루어져야 하기 때문이다.\n리소스가 의미하는게 뭘까? 위 예제처럼 회원을 등록하고 수정하고 조회하는건 리소스가 아니다.\n스타크래프트로 예로 미네라를 캐다에서 미네랄은 리소스, 캐다는 행위이다.\n즉, 회원이라는 개념 자체가 리소스다.\n리소스를 어떻게 식별하는게 좋을까? 식별하는 방법은 아래와 같다.\n1. 회원을 등록하고 수정하고 조회하는 것을 모두 배제한다.\n2. 회원이라는 리소스만 식별한다.\n3. 회원 리소스를 URI에 매핑한다. -\u0026gt; URI는 리소스만 식별\n위 내용을 토대로 URI를 다시 설계한것을 살펴보자.\n 회원 목록 조회 /members 회원 조회 /members/{id} 회원 등록 /members/{id} 회원 수정 /members/{id} 회원 삭제 /members/{id}\n참고: URI는 계층 구조상 상위를 컬렉션으로 보고 복수단어 사용 권장 (member -\u0026gt; members)  URI는 계층형 구조로 설계해야 하므로 /members 밑에 회원의 id를 넣었다.\n하지만 여기서 또 문제가 발생한다.\n 회원 목록 조회 /members 회원 조회 /members/{id} -\u0026gt; 어떻게 구분하지? 회원 등록 /members/{id} -\u0026gt; 어떻게 구분하지? 회원 수정 /members/{id} -\u0026gt; 어떻게 구분하지? 회원 삭제 /members/{id} -\u0026gt; 어떻게 구분하지?  회원의 조회, 등록, 수정, 삭제와 같은 행위는 구분이 안된다.\n리소스(회원)와 리소스를 대상으로 하는 행위(조회, 등록, 삭제, 변경)는 분리했지만 행위(메서드)는 구분하지 않았기 때문이다.\n이 문제를 해결하기 위한게 HTTP 메서드이다.\n다음 포스트에서 회원 관리 API 설계 예시를 통해 HTTP 메서드를 이해해보자.\n","permalink":"https://5hdumat.github.io/posts/network/http-api/","summary":"API URI를 만들어보자 회원 정보 관리 API를 요구사항대로 만든다고 가정해보자.\n요구사항  회원 목록 조회 회원 조회 회원 등록 회원 수정 회원 삭제  URI 설계가 끝난 후 경로가 나왔다.\n 회원 목록 조회 /read-member-list 회원 조회 /read-member-by-id 회원 등록 /create-member 회원 수정 /update-member 회원 삭제 /delete-member  뭔가 그럴듯하다. 실제 현업에서도 위와 같은 설계가 많이 이루어진다.\n하지만 이것은 좋은 URI 설계일까?\n우리는 위와 같이 설계된 URI가 좋은 설계인지에 대해서는 다시한번 고민해 봐야 한다.","title":"HTTP API를 만들어보자"},{"content":"HTTP 요청/응답 내용을 자세히 살펴보자.\nHTTP 요청 아래는 www.daum.net의 HTTP 요청 정보 일부분이다.\nGET / HTTP/1.1 Host: www.daum.net Cache-Control: max-age=0 Accept: text/html, application ... User-Agent: Mozilla/5.0 (Macint ... # 공백 Request-Line 분석 GET / HTTP/1.1   GET  요청하는 자원에 대해 웹 서버에 내리는 명령이다.\n이를 메서드라고 하는데 GET, POST, HEAD, PUT, DELETE 등이 있다.   /  자원의 식별자이다. 요청 URI라고 한다.\nHTML이나 이미지, 동영상, 애플리케이션 등이 있는 가상의 경로이다.\n웹서버는 이 식별자를 이용해 리소스를 찾는다.   HTTP/1.1  HTTP 버전은 요청 정보가 어떤 버전에 맞추어 작성됐는지 웹 서버에게 알려 준다.    Host: www.daum.net Cache-Control: max-age=0 Accept: text/html, application ... User-Agent: Mozilla/5.0 (Macint ... # 공백  HTTP 요청 헤더\n클라이언트의 요청을 서버가 처리할 때 미리 참고할 수 있는 데이터이다.\n이를 요청 헤더라고 부르며, 아래는 요청 헤더 목록이다.\n헤더에는 네 가지 종류가 있다.\n 요청이나 응답 모두 적용할 수 있는 일반 헤더(General-header) 요청에만 적용할 수 있는 요청 헤더(Reqeust-header) 응답에만 적용할 수 있는 응답 헤더(Response-header) 보내거나 받는 본문 데이터를 설명하는 엔티티 헤더(Entity-header)  다음 표는 HTTP 요청 및 응답에 사용할 수 있는 헤더를 정리한 것이다.\n표의 요청 헤더 중 우리는 User-Agent를 눈여겨볼 필요가 있다.\n클라이언트의 정보를 서버에게 알려주는 헤더인데, 웹 서버는 이 헤더를 분석하여 요청자의 OS와 브라우저를 구분한다.\n공백 라인과 요청 데이터(message-body)\nHTTP 요청 내용 중 마지막 공백 라인은 요청 헤더의 끝을 의미한다.\n위 예제는 GET 메서드를 통한 요청이므로 요청이 공백 라인으로 끝난다.\n반대로 POST 요청은 공백 라인 다음에 서버에 보낼 데이터(message-body)가 온다.\nHTTP 응답 아래는 www.daum.net의 HTTP 응답 정보 일부분이다.\nHTTP/1.1 200 OK Date: Fri, 18 Oct 2021 11:26:25 GMT Content-Type: text/html;charset=UTF-8 Content-Length: 34770 ... \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ko\u0026#34;\u0026gt; \u0026lt;Heade\u0026gt; ... Response-Line 분석 HTTP/1.1 200 OK  응답 결과에 대한 상태 정보이다. 프로토콜의 버전과 상태 코드, 설명으로 구성된다.\n자주 접하게 되는 응답 상태 코드를 정리하면 아래와 같다.\n   상태코드 상태설명     200 요청 성공적으로 처리되었다.   301 요청한 자원이 이동되었다. 헤더 정보에 이동위치를 알려줄 테니 다시 요청하라.   304 클라이언트가 임시 보관한 응답결과와 다르지 않다.   400 잘못된 요청이다.   404 요청한 자원을 찾지 못했다.   500 서버 내부에 오류가 발생하였다.    상태 코드에 대해선 차후 더 자세하게 정리하여 포스팅 할 예정이다.\nHTTP 응답 헤더\nDate: Fri, 18 Oct 2021 11:26:25 GMT Content-Type: text/html;charset=UTF-8 Content-Length: 34770 ...  위 예제는 응답 데이터를 처리할 때 참고하라고 웹브라우저에게 알려주는 응답 헤더이다.\n Content-Type  서버가 웹 브라우저에게 보내는 데이터의 형식을 나타낸다.\n웹 브라우저는 이 헤더의 값을 보고 데이터를 출력할지, 다운로드 창을 띄울지 아니면 외부 프로그램을 실행할지 결정한다.   Content-Length  웹 브라우저에게 보내는 데이터(message-body)의 크기(byte)이다.    공백 라인과 응답 데이터(message-body)\n공백 라인은 위에서 설명했듯 헤더와 응답 데이터를 구분하기 위한 구분자이다.\n공백 라인 이후 웹 서버는 HTML 형식의 응답 데이터를 웹 브라우저에게 전송한다.\n","permalink":"https://5hdumat.github.io/posts/network/http-message/","summary":"HTTP 요청/응답 내용을 자세히 살펴보자.\nHTTP 요청 아래는 www.daum.net의 HTTP 요청 정보 일부분이다.\nGET / HTTP/1.1 Host: www.daum.net Cache-Control: max-age=0 Accept: text/html, application ... User-Agent: Mozilla/5.0 (Macint ... # 공백 Request-Line 분석 GET / HTTP/1.1   GET  요청하는 자원에 대해 웹 서버에 내리는 명령이다.\n이를 메서드라고 하는데 GET, POST, HEAD, PUT, DELETE 등이 있다.   /  자원의 식별자이다. 요청 URI라고 한다.\nHTML이나 이미지, 동영상, 애플리케이션 등이 있는 가상의 경로이다.","title":"HTTP 메시지"},{"content":"지금은 HTTP 시대! 웹 프로그래밍을 하려면 웹 브라우저와 웹 서버 간의 통신 프로토콜을 이해하는 것이 필수이다.\n웹 애플리케이션은 웹을 기반으로 구동되기 때문이다.\n웹 브라우저와 웹 서버간의 통신 프로토콜을 우리는 HTTP라고 부른다.\n현재는 아래와 같이 거의 모든 데이터를 HTTP 프로토콜에 담아 전송한다.\n HTML, TEXT IMAGE, 음성, 영상, 파일 JSON, XML (API) 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용  지금은 바야흐로 HTTP의 시대이다.\nHTTP? HyperText Transfer Protocol\nHTTP는 문서간의 링크를 통해 연결할 수 있는 HTML을 전송하기 위한 프로토콜로 시작되었다.1\nHTTP의 역사  HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X HTTP/1.0 1996년: 메서드, 헤더 추가 HTTP/1.1 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전 RFC2068 (1997) -\u0026gt; RFC2616 (1999) -\u0026gt; RFC7230~7235 (2014) HTTP/2 2015년: 성능 개선 HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선  HTTP 특징 HTTP의 특징 크게 4가지로 나눠보자면 아래와 같다.\n 클라이언트 서버 구조 무상태 프로토콜(Stateless) 비연결성 HTTP 메시지  하나씩 차례대로 알아보자.\n1. 클라이언트 서버 구조 HTTP의 첫번째 중요한 특징은 클라이언트/서버 구조(CS) 로 되어있다는 점이다.\n위 예제를 해석하자면 아래와 같다.\n Request Response 구조 클라이언트는 서버에 요청을 보내고 응답 대기 서버는 요청에 대한 결과를 만들어서 응답  표면적으로는 굉장히 단순하지만 근간은 그렇지 않다.\n클라이언트와 서버를 개념적으로 분리하면서 양쪽이 독립적으로 진화할 수 있다는 점은 단순한 일이 아니다.\n이 개념이 적용되면서 비즈니스, 데이터 로직은 서버가 UI(화면)/UX(사용성)와 같은 화면구조는 클라이언트가 담당하게 되었다.\n이제 우리는 트래픽이 폭주해도 서버 아키텍쳐와 백엔드 기술을 얼마나 더 고도화하고 진화시킬수 있는지에 대해서만 고민하면 된다.\n2. 무상태 프로토콜(Statelesss) HTTP는 서버가 클라이언트의 상태를 보존하지 않는다.\n이 말을 이해하려면 우리는 상태 유지(Stateful)와 무상태성(Stateless)의 차이를 알아봐야 한다.\n  상태 유지 - Stateful 고객: 이 노트북 얼마인가요?\n점원: 100만원 입니다.\n 고객: 2개 구매하겠습니다.\n점원: 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매하시겠어요?\n 고객: 신용카드로 구매하겠습니다.\n점원: 200만원 결제 완료되었습니다.\n  너무나 일상적인 대화다. 하지만 예제를 조금 바꿔 점원이 여러명이라고 가정해보자.\n  상태 유지 - Stateful, 점원이 중간에 바뀌면? 고객: 이 노트북 얼마인가요?\n점원A: 100만원 입니다.\n 고객: 2개 구매하겠습니다.\n점원B: ?\n 고객: 신용카드로 구매하겠습니다.\n점원C: ?\n  무언가 이상하다. 고객의 요청은 점원이 바뀜에 따라 문맥이 유지되지 않는다.\n문맥이 유지되지 않는다는건 무슨 의미일까?\n  상태 유지 - Stateful, 정리 고객: 이 노트북 얼마인가요?\n점원: 100만원 입니다. (노트북 상태 유지)\n 고객: 2개 구매하겠습니다.\n점원: 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매하시겠어요 (노트북, 2개 상태 유지)\n 고객: 신용카드로 구매하겠습니다.\n점원: 200만원 결제 완료되었습니다. (노트북, 2개, 신용카드 상태 유지)\n  위 예제처럼 점원이 클라이언트의 요청을 기억하고 기억하고 문맥을 유지는 의미이다.\n문맥을 유지하고 있던 점원이 바뀌게 된다는 건 통신의 관점에선 장애가 발생한다는것과 다름이 없다.\n그럼 무상태성(Stateless)은 뭐가 다른 걸까? 이제 무상태성(Stateless)은 상태 유지(Stateful)와 어떻게 다른지 알아보자.\n무상태 - Stateless 고객: 이 노트북 얼마인가요?\n점원: 100만원 입니다.\n 고객: 노트북 2개 구매하겠습니다.\n점원: 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매하시겠어요?\n 고객: 노트북 2개를 신용카드로 구매하겠습니다.\n점원: 200만원 결제 완료되었습니다ㄴ.\n  위 예제는 점원이 바뀌더라도 고객의 마지막 말로 모든 행위를 판단할 수 있다.\n무상태성(Stateless) 은 말 그대로 점원이 고객의 상태를 유지하지 않아야 하기 때문이다.\n상태 유지와 무상태의 차이가 느껴지는가?\n상태 유지(Stateful), 무상태(Stateless) 차이  상태유지(Stateful)  중간에 다른 점원으로 바뀌면 안된다.\n(중간에 다른 점원으로 바뀔 때 상태 정보를 다른 점원에게 미리 알려줘야 한다.)    그 이유는 아래와 같다.\n예제처럼 서버1은 클라이언트A의 요청 정보를 지속적으로 유지하고 있어야한다.\n상태 유지의 문제점은 여기서 나타난다.\n서버1이 클라이언트A의 정보를 유지하고 있다보니서버1에 장애가 발생하면\n클라이언트A는 다른 서버에 요청을 처음부터 다시 시도해야한다.\n무상태(Stateless)는 어떤 차이점이 있을까?\n 무상태(Stateless)  갑자기 고객이 증가해도 점원을 대거 투입할 수 있다. 무상태는 응답 서버를 쉽게 바꿀 수 있다.  무한한 서버 증설 가능      무상태은 클라이언트A가 애초에 필요한 데이터를 모두 담아서 서버에 요청한다.\n서버는 클라이언트A의 요청에 따라 응답만 하면된다.\n중간에 서버가 장애나면?\n중계서버가 다른 서버에 요청을 똑같이 요청하면된다.\n클라이언트A의 요청에 필요한 데이터가 모두 담겨있기 때문이다.\n이 방식은 큰 장점이 있는데 수평 확장이 유리하다는 점이다.\n무상태성으로 설계가 되어있으면 트래픽이 많이 발생해도 동일한 장비를 추가 증설하여 트래픽을 감당할 수 있다.\n하지만 무상태(Stateless)도 실무 한계가 있다.\n무상태(Stateless) 실무 한계  모든 것을 무상태로 설계 할 수 있는 건 아니다.  무상태  로그인인이 필요 없는 단순한 서비스 소개 화면   상태 유지  브라우저 쿠키와 세션 상태를 유지해야하는 로그인     상태 유지가 필요한 로그인의 경우 무상태성 적용 불가 무상태를 유지하기 위해 클라이언트가 전송해야 할 데이터가 많아진다. 상태 유지는 최소한만 사용  비연결성(Connectionless) TCP/IP 연결의 경우 기본적으로 연결을 유지한다.\n예를들어 클라이언트가 여러개라고 가정해보자.\n서버는 모든 클라이언트의 요청에 따라 TCP/IP 소켓을 연결하고 유지한다.\n이 방식의 단점은 특정 클라이언트가 놀고있어도 서버는 연결 상태를 유지해야하다보니 서버 자원 소모가 많다는 점이다.\n(클라이언트가 수만개라고 가정한다면 서버는 \u0026hellip;)\n연결을 유지하지 않는 모델은?\n이 방식은 TCP/IP 소켓 연결 후 요청을 하고 응답을 받고 볼일을 끝낸 서버는 연결을 종료한다.\n서버 입장에선 연결을 유지할 필요가 없어지므로 최소한의 자원을 유지할 수 있다.\n비 연결성  HTTP는 기본이 연결을 유지하지 않는 모델 일반적으로 초 단위 이하의 빠른 속도로 응답 1시간 동안 수천명이 서비스를 해도 실제 서버에서 동시 처리하는 요청은 수십개 이하로 매우 작음  웹 브라우저에서 연속적으로 검색 버튼을 누르진 않는다.   서버 자원의 가용성을 훨씬 높힐수 있음  비 연결성 방식의 한계와 극복  TCP/IP 연결을 매번 새로 맺어야함 - 3 Way Handshake로 인한 시간 낭비 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 js, image, css 등 수많은 자원을 다운로드한다.  현재는 HTTP 지속 연결(Persistent Comnnections, Keep alive)로 문제 해결    - HTTP 초기 연결\n필요한 정보가 생길때마다 연결을 새로한다. 시간도 오래걸리고 낭비도 심하다.\n- HTTP 지속 연결(Persistent Connections)\n기본적으로 HTTP 지속 연결은 연결을 한 후 요청을 보내고 응답을 받는다.\n그 다음 연결을 유지한 상태에서 필요한 자원을 응답받는다.\n(내부 매커니즘에 따라 다르지만 보통 HTML 문서가 완전히 다운로드될 때까지 연결을 지속한다.)\n무상태(Stateless)를 기억하자 명절 KTX 예약이나 학과 수업 등록, 선착순 쿠폰 이벤트를 예로 들어보자.\n같은 시간에 수만개의 동시 요청을 서버는 감당해야 할 것이다.\n요청이 동시에 몰리기 때문에 최대한 Stateless하게 설계하는게 중요하다.\n(위에서도 언급했지만 무상태는 스케일 아웃이 유리하기 때문에 많은 트래픽이 발생해도 대응하기가 쉽다.)\nHTTP의 확장 HTTP 프로토콜은 단순히 HTML 페이지나 이미지 파일을 전송하는 차원을 넘어 원격 컴퓨터에 로딩되어 있는 함수나 객체의 메서드를 호출할 때도 사용된다.\n특히 웹 애플리케이션을 개발하다보면\n SOAP(Simple Object Access Protocol) RESTful(REpresentational State Transfer)  같은 용어를 만나게 되는데, 이는 클라이언트와 서버 사이의 서비스 요청/응답 방식을 말한다.\n이 두 가지 모두 HTTP 프로토콜을 응용하거나 확장한 기술이다.\n웹상에서 여러 사람이 문서나 파일을 더 쉽게 편집하고 다룰 수 있게 협업을 도와주는 WebDAV나 WebDAV를 응용해 캘린더 데이터를 보다 쉽게 편집하고 공유할 수 있도록 한 CalDAV같은 기술도 있다.\n이렇게 웹 기술은 HTTP 프로토콜을 중심으로 계속 확장되고 있다.\nHTTP 프록시 서버 웹 브라우저와 웹 서버 사이에 주고받는 데이터를 들여다보려면 HTTP 프록시 프로그램이 필요하다.\nHTTP 프록시 서버? 클라이언트와 서버 사이에서 통신을 중계해 주는 컴퓨터나 프로그램을 말한다.\n프록시 서버는\n 빠른 전송을 위하여 서버의 응답 결과를 캐시에 저장해둔다. 프록시 서버를 두는 두 번째 이유는 보안적인 부분인데, 첨단 기술을 다루는 회사의 경우 내부 사용자의 기밀 유출에 민감할 수밖에 없다. 이런 경우 프록시 서버를 이용하면 외부로 전달되는 데이터를 검사하여 특정 단어가 포함된 자료의 송.수신을 차단하거나 보안 팀에 경고 메시지를 보낼 수도 있다.  HTTP 프록시의 역할 프록시는 웹 브라우저가 웹 서버에게 요청하면 그 요청을 대신 받아 서버에 전달한다.\n서버에서 응답이 오면 프록시가 그 응답을 대신 받아 웹 브라우저에게 전달한다.\n이렇게 웹 브라우저와 웹 서버의 중간에서 요청이나 응답 내용을 중계한다.\n  하이퍼텍스트(Hypertext)는 참조(하이퍼링크)를 통해 독자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트이다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/network/http/","summary":"지금은 HTTP 시대! 웹 프로그래밍을 하려면 웹 브라우저와 웹 서버 간의 통신 프로토콜을 이해하는 것이 필수이다.\n웹 애플리케이션은 웹을 기반으로 구동되기 때문이다.\n웹 브라우저와 웹 서버간의 통신 프로토콜을 우리는 HTTP라고 부른다.\n현재는 아래와 같이 거의 모든 데이터를 HTTP 프로토콜에 담아 전송한다.\n HTML, TEXT IMAGE, 음성, 영상, 파일 JSON, XML (API) 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용  지금은 바야흐로 HTTP의 시대이다.\nHTTP? HyperText Transfer Protocol\nHTTP는 문서간의 링크를 통해 연결할 수 있는 HTML을 전송하기 위한 프로토콜로 시작되었다.","title":"HTTP"},{"content":"웹 브라우저 요청 흐름 위 예제와 같이 구글링 할 경우 브라우저 요청의 흐름을 알아보자.\n  1. 클라이언트는 구글 서버를 찾아야 하므로 DNS 서버를 조회하여 IP와 PORT 정보를 찾아낸다.\n  2. HTTP 요청 메시지를 생성한다. 요청 메시지의 간략한 생김새는 아래와 같다.\n GET /search?q=hello\u0026amp;hl=ko HTTP/1.1\nHOST: www.google.com    3. 생성한 HTTP 요청 메시지는 SOCKET 라이브러리를 통해 TCP/IP 계층에 전달한다.\n 이 과정에서 3 Way Handshake를 통해 구글서버와 가상연결 한다.    4. TCP/IP 계층에서 HTTP 메시지를 IP, PORT 정보와 함께 TCP/IP 패킷으로 캡슐화한다.\n 위 요청의 흐름을 그림으로 표현하면 아래와 같다.     5. 만들어진 TCP/IP 패킷을 인터넷 망을 통해 구글 서버로 전송한다.   6. 구글 서버는 전달 받은 TCP/IP 패킷을 반대로 해석한다.  구글 서버는 해석한 메시지를 읽어들여 검색엔진을 통해 데이터를 찾고 응답 메시지를 만들어낸다.\n위 예제와 같이 응답 패킷에 여러 정보를 담아 클라이언트에 똑같이 메시지를 전송한다.\n 7. 웹 브라우저는 구글서버로 부터 전달받은 HTTP 메시지를 해석하고 렌더링 한 후 사용자에게 보여준다.  ","permalink":"https://5hdumat.github.io/posts/network/web-browser-request/","summary":"웹 브라우저 요청 흐름 위 예제와 같이 구글링 할 경우 브라우저 요청의 흐름을 알아보자.\n  1. 클라이언트는 구글 서버를 찾아야 하므로 DNS 서버를 조회하여 IP와 PORT 정보를 찾아낸다.\n  2. HTTP 요청 메시지를 생성한다. 요청 메시지의 간략한 생김새는 아래와 같다.\n GET /search?q=hello\u0026amp;hl=ko HTTP/1.1\nHOST: www.google.com    3. 생성한 HTTP 요청 메시지는 SOCKET 라이브러리를 통해 TCP/IP 계층에 전달한다.\n 이 과정에서 3 Way Handshake를 통해 구글서버와 가상연결 한다.","title":"웹 브라우저 요청 흐름"},{"content":"URI(Uniform Resource Identifier) URI는 리소스를 식별하는 통합된 방법이라는 의미이다.\n사람을 식별할 때는 주민등록번호를 이용하는 것 처럼 리소스가 어디있는지 식별하는 방법을 URI라고 한다.\n Uniform: 리소스 식별하는 통일된 방식 Resource: 리소스, URI로 식별할 수 있는 모든 자원 (제한 X)\n즉, URI로 식별할 수 있는 모든 정보를 리소스라고 한다. Identifier: 다른 항복과 구분하는 데 필요한 정보\n예) 사람을 식별할 때 사용하는 주민등록번호가 사람의 Identifier가 된다.  \u0026ldquo;URI는 로케이터(locator), 이름(name) 또는 둘다 추가로 분류될 수 있다.\u0026rdquo; URI안에는 URL과 URN 방식이 포함되어 있다.\nURL? URN?  URL(Resource Locator)  우리가 일반적으로 웹 브라우저에서 사용하는 방식 리소스가 있는 위치를 지정하여 검색   URN(Resource Name)  리소스에 이름을 부여\n예) urn:isbn:1234567과 같이 검색하여 특정 서적의 ISBN 정보를 표시 URN은 이름마다 리소스가 매핑되어 있어야 하기 떄문에 실제 리소스를 찾을 수 있는 방법이 보편화 되어있지 않다. 그냥 URN 이란것도 있구나 정도로 인지만하고 넘어가자    URL 분석 scheme scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n 스키마는 주로 프로토콜 사용 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙\nhttp, https, ftp 등 http는 80 포트, https는 443 포트를 주로 사용\n포트는 생략 가능한데 생략시 http는 80 https는 443 포트가 자동 기입된다. https는 http에 강력한 보안 추가 (HTTP Secure)\n현재는 대부분의 웹사이트들이 https로 동작  userinfo scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n URL에 사용자정보를 포함해서 인증 거의 사용하지 않는다.  host scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n 호스트명 이전 포스트에서 배웠던 도메인명 또는 IP 주소를 직접 사용가능  port scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n 포트(PORT) 일반적으로 생갹, 생략시 http는 80, https는 443  path scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n 리소스가 있는 경로(path) 계층적 구조로 설계  /home/file1.jpg /members /members/100 /items/iphone12\npath만 봐도 어떤 행위를 하는지 알 수 있다.    query scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n key=value 형태 ?로 시작, \u0026amp;로 파라미터를 이어 붙일 수 있다.\n?keyA=valueA\u0026amp;keyB=valueB query parameter, query string 등으로 불린다.\n(웹서버에 제공하는 파라미터, 문자 형태)  fragment scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n html 내부 북마크 등에 사용 서버에 전송하는 정보는 아니다.  ","permalink":"https://5hdumat.github.io/posts/network/uri/","summary":"URI(Uniform Resource Identifier) URI는 리소스를 식별하는 통합된 방법이라는 의미이다.\n사람을 식별할 때는 주민등록번호를 이용하는 것 처럼 리소스가 어디있는지 식별하는 방법을 URI라고 한다.\n Uniform: 리소스 식별하는 통일된 방식 Resource: 리소스, URI로 식별할 수 있는 모든 자원 (제한 X)\n즉, URI로 식별할 수 있는 모든 정보를 리소스라고 한다. Identifier: 다른 항복과 구분하는 데 필요한 정보\n예) 사람을 식별할 때 사용하는 주민등록번호가 사람의 Identifier가 된다.  \u0026ldquo;URI는 로케이터(locator), 이름(name) 또는 둘다 추가로 분류될 수 있다.","title":"URI"},{"content":"DNS? DNS는 무엇이고 왜 사용하는 걸까?\n그 이유는 위 예제처럼 IP는 기억하기 어렵다는 점이고\n또 다른 이유는 IP는 언제든지 변경될 수 있다는 점이다.\n예를 들어 200.200.200.2로 기억해두었던 IP가 200.200.200.3으로 변경되었을 때\n기존 IP는 당연히 접근 불가능하게 된다.\n이를 해결하려면 도메인 네임 시스템(DNS, Domain Name System) 을 이용해야 한다.\nDNS의 특징 DNS는 등록한 도메인 명을 IP 주소로 변환해 준다.\n쉽게말해 중간에서 전화번호부 서버같은 서비스를 제공해 준다고 이해하면 된다.\n기철이한테 전화를 걸면 기철이의 핸드폰번호로 전화가 걸리는 것 처럼 말이다.\n예제를 통하여 더 자세하게 살펴보자.\n1. DNS 서버에 구매한 도메인을 IP와 매핑하여 등록한다. google.com -\u0026gt; 200.200.200.2\naaa.com -\u0026gt; 210.210.210.3\n도메인 명과 IP를 매핑하여 등록\n2. 클라이언트는 도메인으로 DNS 서버에 IP를 요청한다. 3. DNS 서버는 IP 주소를 전달한다. 4. 클라이언트는 전달받은 IP 서버에 접속한다. 이제 더 이상 IP를 기억할 필요도 IP 변경을 신경 쓸 필요도 없어진다.\n","permalink":"https://5hdumat.github.io/posts/network/dns/","summary":"DNS? DNS는 무엇이고 왜 사용하는 걸까?\n그 이유는 위 예제처럼 IP는 기억하기 어렵다는 점이고\n또 다른 이유는 IP는 언제든지 변경될 수 있다는 점이다.\n예를 들어 200.200.200.2로 기억해두었던 IP가 200.200.200.3으로 변경되었을 때\n기존 IP는 당연히 접근 불가능하게 된다.\n이를 해결하려면 도메인 네임 시스템(DNS, Domain Name System) 을 이용해야 한다.\nDNS의 특징 DNS는 등록한 도메인 명을 IP 주소로 변환해 준다.\n쉽게말해 중간에서 전화번호부 서버같은 서비스를 제공해 준다고 이해하면 된다.\n기철이한테 전화를 걸면 기철이의 핸드폰번호로 전화가 걸리는 것 처럼 말이다.","title":"DNS"},{"content":"PORT ? PORT는 배가 도착하는 항구라는 뜻이다.\n포트는 마치 항구와 같다. 패킷이 목적지 IP까지 안전하게 도착하도록 도와준다.\n그게 어떤 애플리케이션이든 말이다.\n예를 들면 아래와 같다.\n한번에 둘 이상 연결해야 한다면? 우리는 PC에서 한 작업만 하지 않는다.\nZOOM회의를 하면서 몰래 게임을 켜놓고 웹 브라우저로 쇼핑을 한다고 가정해보자.\n가정대로라면 클라이언트는 여러개의 서버와 통신 해야한다.\n위와 같은 상황에선 서버의 응답 패킷들이 클라이언트에 뒤죽박죽 도착할 것이다.\n(이건 클라이언트가 서버로 요청을 보낼때도 마찬가지다.)\n게임 패킷인지, 화상통화 패킷인지, 웹 브라우저의 패킷인지 IP 프로토콜만 가지고는 구분할 수 없다.\n사실 이전에 봤던 TCP/IP 패킷에 PORT 정보가 있다. 사실 TCP/IP 패킷에 출발지와 목적지의 PORT 정보가 포함되어 있어 프로세스를 구분할 수 있었다.\nIP는 목적지 서버를 찾는 것\nPORT는 목적지 서버 안에서 동작하는 프로세스를 구분하는 것이라고 이해하면 된다.\nIP는 아파트 PORT는 동,호수 IP는 아파트 PORT는 동, 호수이다.\nIP(아파트)뿐만 아니라 PORT(동, 호수)까지 열어서 연결하기 때문에\n같은 IP(아파트) 내에서 프로세스를 구분하여 패킷(택배)을 전송 할 수 있다.\n또한 PORT는 할당 범위가 정해져 있으므로 참고하자.\n 0 ~ 65535 할당 가능 0 ~ 1023: 잘 알려진 포트는 사용하지 않는 것이 좋다.  FTP - 20, 21 TELNET - 23 HTTP - 80 HTTPS - 443    ","permalink":"https://5hdumat.github.io/posts/network/port/","summary":"PORT ? PORT는 배가 도착하는 항구라는 뜻이다.\n포트는 마치 항구와 같다. 패킷이 목적지 IP까지 안전하게 도착하도록 도와준다.\n그게 어떤 애플리케이션이든 말이다.\n예를 들면 아래와 같다.\n한번에 둘 이상 연결해야 한다면? 우리는 PC에서 한 작업만 하지 않는다.\nZOOM회의를 하면서 몰래 게임을 켜놓고 웹 브라우저로 쇼핑을 한다고 가정해보자.\n가정대로라면 클라이언트는 여러개의 서버와 통신 해야한다.\n위와 같은 상황에선 서버의 응답 패킷들이 클라이언트에 뒤죽박죽 도착할 것이다.\n(이건 클라이언트가 서버로 요청을 보낼때도 마찬가지다.)\n게임 패킷인지, 화상통화 패킷인지, 웹 브라우저의 패킷인지 IP 프로토콜만 가지고는 구분할 수 없다.","title":"PORT"},{"content":"TCP? IP 프로토콜만으론 해결할 수 없는 문제점들이 있었다.\n 비연결성 (대상이 서비스 불능임에도 패킷 전송) 비신뢰성 패킷 전달 순서의 문제  이러한 문제점을 보완하고자 나온 프로토콜이 TCP, UDP 이다.\n하지만 우리는 인터넷 프로토콜 스택의 계층 구조를 먼저 살펴보아야 한다. 1\n인터넷 프로토콜 스택의 4계층을 단계별로 표현한 예제이다.\n위로갈수록 사용자와 가까운 작업을 아래로 갈수록 기계와 가까운 작업을 담당한다.\n각 계층에는 다양한 프로토콜이 있으며, TCP와 IP 프로토콜도 그중 하나이다.\n계층 구조를 살펴보자.\n 애플리케이션 계층 (Application Layer)\nHTTP, FTP, SMTP, TELNET 등  우리가 평소에도 사용하는 브라우저, 네트워크 게임, 메신저 등이 애플리케이션 계층에 놓여있다.\n이 계층은 애플리케이션에 따라 그에맞게 통신을 수행할 수 있도록 한다.\n  전송 계층 (Transport Layer)\nTCP, UDP  이번 포스트의 주인공이다.\n송신된 데이터를 수신측 애플리케이션에 확실히 전달하기 위한 프로토콜이다.\n  네트워크 계층 (Network Layer)\nIP  수신측 컴퓨터까지 데이터를 전달하기 위한 최소한의 규칙이다.\n하지만 전달된 데이터가 손상됐는지 또는 수신측이 잘 받았는지에는 관여하지 않는다.\n(비연결성, 비신뢰성, 패킷 전달 순서 문제)\n이 문제점은 바로 위 계층에 있는 TCP 프로토콜이 보완한다.\n  네트워크 인터페이스 계층 (Network Interface Layer)\n데이터 링크 계층과 물리계층을 합쳐 네트워크 인터페이스 계층이라고 지칭한다.  데이터 링크 계층은 네트워크 계층(Network Layer)과 물리 계층(Physical Layer) 간의 차이를 완전히 흡수하기 위한 프로토콜이며 대표적인 예로 이더넷(Ehernet)이 있다.\n물리 계층은 데이터를 신호로, 신호를 데이터로 변환하며 통신 매체에 의존하기 때문에 특정 프로토콜이 정해져 있지 않다.\n메신저로 Hello, world! 라는 메시지를 전송해보자 인터넷 프로토콜 스택의 4계층을 이해하기 쉽게 단순화하여 3계층으로 표현한 예제이다.\n내부적으로는 4계층으로 표현되고 있으니 헷갈려 하지 말자.\n메시지 데이터가 어떻게 전송되는지 정리하자면 아래와 같다.\n1. 채팅 프로그램에 Hello, world!를 입력한다. 2. 메시지는 Socket 라이브러리를 통해 전송 계층에 전달된다. 전송 계층에는 이 포스트의 주인공인 TCP / UDP 프로토콜이 있다.\n3. 전송 계층에 전달된 메시지(데이터 계층)에 TCP 정보가 추가된다. TCP 정보가 추가된 데이터는 다시 네트워크 계층에 전달된다.\n4. TCP 정보가 포함된 데이터를 전달받은 네트워크 계층에선 IP 정보가 또다시 추가된다. 이렇게 생성된 패킷을 IP 패킷(Packet)이라고 하며 형태는 아래와 같다. 2\n녹색으로 표시된 부분을 살펴보면 전송 제어, 순서, 검증 정보 등 여러 데이터가 추가되어있다.\n이 정보가 IP 프로토콜의 문제점을 보완해 줄 TCP 정보이다.\n이 때문에 신뢰할 수 있는 프로토콜 이라고도 하며, 전송 제어 프로토콜(Transmission Control Protocol) 이라고도 한다.\nTCP(Transmission Control Protocol)의 특징 TCP의 특징은 아래와 같다.\n 연결지향 - TCP 3 way handshake (가상연결)  TCP/IP 프로토콜로 통신하면 클라이언트 ➡ 서버, 서버 ➡ 클라이언트 양뱡향으로 탐색 과정을 거친다.\n이 탐색 과정을 TCP 3 way handshake 라고 한다.\n탐색이 끝나면 서버와 클라이언트가 논리적인 가상 연결 상태가 되며, 이는 물리적인 연결 상태는 아니다. 3\n즉, TCP는 클라이언트와 서버가 서로 연결됐다고 가정만 한 상태이다.\n 데이터 전달 보증  클라이언트가 데이터를 전송 하면 서버에서 데이터를 잘 받았다는 응답값을 전송한다.\n응답 값 전송 여부에 따라 메시지가 정상적으로 전달되지 않았을때에 대한 문제를 인지할 수 있게 된다.\n 순서 보장  서버에 전달된 패킷이 순서대로 도착하지 않았다면 서버는 문제가 된 패킷부터 재전송 요청한다.\n5. 마지막으로 IP 패킷은 물리적인 정보가 포함된 이더넷 프레임 정보가 추가되어 물리 계층으로 전달된다. UDP? 사용자 데이터그램 프로토콜(User Datagram Protocol)이라고한다.\n 기능이 거의 X 연결지향 - TCP 3 way handshake (가상연결) X 데이터 전달 보증 X 순서 보장 X  이 프로토콜을 왜 쓰지? 라는 생각이 들 수도 있겠지만 UDP 프로토콜만의 장점이 있다.\nTCP 프로토콜은 TCP 3 Way Handshake로 인한 소요 시간, 신뢰성을 보장하기 위한 여러가지 검증 정보로 인한 데이터의 크기 등의 문제가 있다.\n무엇보다도 가장 중요한 점은 인터넷 통신은 90% 이상 TCP기반 이라는 점이다.\n이전에는 신뢰할 수 있는 데이터에만 사용했던 프로토콜이었지만, 이제는 동영상과 같은 실시간 스트리밍 서비스에서도 TCP를 사용하고 있기 때문이다.\n때문에 TCP 프로토콜을 수정한다는 것은 불가능에 가깝다.\n그렇다면 어떻게 TCP 프로토콜을 최적화 할 수 있을까? UDP 프로토콜의 기능은 IP 프로토콜에 PORT만 추가된 형태로 하얀 도화지와 같다.\n이러한 이유 때문에 전송 계층이 아닌 애플리케이션 계층에서 최적화가 가능하다.\n최근 HTTP3 스펙에서는 TCP 프로토콜을 최적화하고자 UDP 프로토콜을 채택하면서 급부상하고 있는 프로토콜이다.\n  인터넷 프로토콜 스택은 인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는 통신규약(프로토콜)의 모음이다. 인터넷 프로토콜 슈트 중 TCP와 IP가 가장 많이 쓰이기 때문에 TCP/IP 프로토콜 슈트라고도 불린다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 패킷은 소화물을 뜻하는 패키지(package)와 덩어리를 뜻하는 버킷(bucket)의 합성어이다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 물리적으로 연결된다는 표현은 과거 전화국에서 전화 포트를 뽑아 연결하고자 하는 곳에 다시 연결해 주는 것과 같이 전용 랜선이 보장되는 것이다. TCP는 클라이언트와 서버가 서로 연결됐다고 가정만 한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/network/tcp-udp/","summary":"TCP? IP 프로토콜만으론 해결할 수 없는 문제점들이 있었다.\n 비연결성 (대상이 서비스 불능임에도 패킷 전송) 비신뢰성 패킷 전달 순서의 문제  이러한 문제점을 보완하고자 나온 프로토콜이 TCP, UDP 이다.\n하지만 우리는 인터넷 프로토콜 스택의 계층 구조를 먼저 살펴보아야 한다. 1\n인터넷 프로토콜 스택의 4계층을 단계별로 표현한 예제이다.\n위로갈수록 사용자와 가까운 작업을 아래로 갈수록 기계와 가까운 작업을 담당한다.\n각 계층에는 다양한 프로토콜이 있으며, TCP와 IP 프로토콜도 그중 하나이다.\n계층 구조를 살펴보자.","title":"TCP / UDP"},{"content":"인터넷상에서 컴퓨터 둘은 어떻게 통신할까? 클라이언트와 서버가 책상에 나란히 놓여있다고 가정해보자.\n그리고 클라이언트는 서버에게 Hello, world! 라는 메시지를 보내고자 한다.\n물리적으로 가까운 거리의 PC는 서로 연결된 케이블로 간단히 통신이 가능하다. 1\n이처럼 비교적 좁은 공간에 있는 기기끼리 연결한 네트워크를 우리는 LAN (Local Area Netwrok) 이라고 한다. 2\n하지만 메시지를 보내고자하는 서버가 지구 반대편에 있다면 어떻게 해야 할까?\n우리는 여러 개의 LAN이나 WAN을 연결한 전 세계 규모의 네트워크인 인터넷을 이용해야한다. 3\n인터넷 망은 단순하지 않다.\n인터넷은 서버와 서버의 연결이다. 이러한 네트워크 환경속에서 데이터는 수많은 서버를 거치게 된다.\n그렇다면 메시지가 목적지 서버까지 안전하게 전송될 수 있는 이유는 무엇일까?\n우리는 여기서 IP(인터넷 프로토콜) 이 무엇인지 짚고 넘어가야 한다.\nIP(인터넷 프로토콜) 복잡한 인터넷 망에서 데이터를 통신하기 위한 최소한의 규칙을 IP(인터넷 프로토콜) 이라 한다.\nIP(인터넷 프로토콜)을 이용한 통신 순서 1. 클라이언트와 서버에 IP 주소를 부여한다.\n2. IP 패킷을 만든다.\n출발지, 목적지 IP 정보와 함께 Hello, world! 라는 전송 데이터를 감싼다.\n택배에 출발지와 배송지 주소를 적는 것과 같다.\n3. 인터넷 망을 통해 IP 패킷을 전송한다.\n인터넷 망의 노드(서버)들은 모두 IP 프로토콜을 이해할 수 있도록 일련의 규약을 따르고있다.\n중간 노드들은 목적지가 어디있는지 서로 물어가면서 최적의 경로로 패킷을 전달하려고 할 것이다.\n4. 응답을 받은 서버는 동일한 방식으로 클라이언트에게 패킷을 전달한다.\n인터넷 망은 굉장히 복잡한 매커니즘을 따르고 있어 요청할 때와 응답할 때 거치는 노드가 다를 수 있다.\nIP(인터넷 프로토콜)의 한계 단순히 IP 주소를 부여하고 패킷을 전달하는 방식으로는 한계가 있다.\n어떤 한계점이 있을까?\n비연결성 아직까지 우리는 200.200.200.2 라는 서버가 켜져있는지 꺼져있는지 알 수 없다.\n패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷을 전송하는 건 낭비이다.\n비신뢰성 인터넷이라는건 용빼는 재주가 있는게 아니다.\n결국 패킷은 여러 서버를 거쳐 목적지로 전달된다.\n즉, 특정 노드에 문제가 생길 수 있다는 것이고, 패킷이 유실될 수 있다는 의미이다.\n패킷 전달 순서 문제 한번에 전송할 수 있는 메시지의 MTU(최대 전송 단위)는 1500 Byte 이다.\n메시지 패킷의 용량을 3000 Byte 라고 가정한다면 1500 Byte 단위 로 패킷이 나누어진다.\n클라이언트는 나누어진 패킷을 Hello, 와 World! 순으로 전달하게 될 것이다.\n문제는 여기서 발생한다.\n인터넷 망은 굉장히 복잡한 매커니즘을 따르고 있으므로 패킷들이 항상 동일한 노드를 거치지는 않는다.\n즉, 패킷의 요청 순서와 다르게 목적지 서버에 전달될 수 있다는 의미이다.\n마무리 위에 열거한 비연결성, 비신뢰성, 패킷 전달 순서 문제는 IP 프로토콜만으론 해결할 수 없다.\n다음 포스트에서 IP 프로토콜의 문제점을 보완하고자 나온 TCP, UDP 프로토콜을 다루고자 한다.\n  접속에는 주로 가는 구리선을 짜넣은 LAN 케이블을 사용한다. 케이블을 사용하지 않고 전파나 적외선 등을 사용하여 연결한 것을 \u0026lsquo;무선 LAN\u0026rsquo; 이라고 한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 반대로 지리적으로 멀리 떨어진 장소에 있는 기기를 광섬유 케이블이나 공중망(전화 회선) 등을 사용하여 연결한 것을 WAN(Wide Area Network) 이라고 한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 워크스테이션 수준의 고사양 개인용 컴퓨터가 널리 보급되고, LAN과 WAN으로 인터넷이라는 국제적인 통신망이 연결되기 시작했다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/network/internet-protocol/","summary":"인터넷상에서 컴퓨터 둘은 어떻게 통신할까? 클라이언트와 서버가 책상에 나란히 놓여있다고 가정해보자.\n그리고 클라이언트는 서버에게 Hello, world! 라는 메시지를 보내고자 한다.\n물리적으로 가까운 거리의 PC는 서로 연결된 케이블로 간단히 통신이 가능하다. 1\n이처럼 비교적 좁은 공간에 있는 기기끼리 연결한 네트워크를 우리는 LAN (Local Area Netwrok) 이라고 한다. 2\n하지만 메시지를 보내고자하는 서버가 지구 반대편에 있다면 어떻게 해야 할까?\n우리는 여러 개의 LAN이나 WAN을 연결한 전 세계 규모의 네트워크인 인터넷을 이용해야한다. 3","title":"IP (인터넷 프로토콜)"},{"content":"시간 복잡도는 왜 필요할까? 알고리즘은 어떤 문제를 해결하기 위한 일련의 과정 입니다.\n알고리즘 문제를 풀다보면 시간초과로 인해 시간복잡도를 생각해야 하는 경우가 자주 생기게되는데 동일한 문제해결 목표를 가진 알고리즘이 존재할 때 가장 시간복잡도가 가장 낮은 알고리즘을 사용 해야 시간초과 오류를 면할 수 있습니다.\n아무리 복잡한 알고리즘이라도 입력의 크기가 작으면 단시간에 끝나버리기 때문에 입력값의 크기가 충분히 클 때 그 효율성이 적나라하게 나타납니다.\n이러한 점근적 실행 시간1을 표기할 때 가장 널리쓰이는 수학적 표기법이 빅오 (big-O)입니다.\n빅오 표기법의 종류는 크게 다음과 같습니다.\nO(1) 상수 시간을 갖는 알고리즘으로 입력값 n이 주어졌을 때, 알고리즘이 문제를 해결하는데 오직 한 단계만 거칩니다. 즉, 입력값이 아무리 커도 실행 시간은 일정합니다.\n최고의 알고리즘이지만 상수값이 무한대로 커진다면 사실상 일정한 시간의 의미는 없어집니다.\nprint(\u0026#34;hello, world!\u0026#34;) a = [1, 2, 3, 4, 5] print(a[2]) # 3 위와 같이 입력값의 길이와 상관없이 데이터를 추출하는데 소요시간에 변함이 없어야합니다.\nPython 함수 및 메소드의 시간 복잡도를 정리해둔 사이트가 있으니 참고합니다.\nComplexity of Python Operations\nO(log n) 실행 시간이 입력값에 영향을 받지만 특정 조건에 따라 입력값 탐색시간이 줄어듭니다.\n아래 예제를 보시면 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어드는 것을 확인하실 수 있습니다.\na = [1, 2, 3, 4, 5, 6, 7, 8, 9] for i in range(0, len(a), 3): print(a[i]) # 1, 4, 7 O(n) 입력값만큼 실행 시간이 영향을 받으며, 알고리즘을 수행하기 위한 단계의 수와 시간이 입력값과 1:1 관계를 가집니다.\n이를 선형 시간(Linear-Time) 알고리즘이라 합니다.\na = [1, 2, 3] for n in a: print(n) # 1 2 3 O(n log n) 병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘이 이에 해당합니다.\n병합 정렬은 주어진 리스트를 하나의 해가 될 때까지 재귀적으로 나누고 다시 작은 수 부터 정렬하여 병합합니다.\n시간 복잡도는 최악의 경우 O(nlogn)으로 나누면서 log n의 시간이 소요되고, 병합하면서 n의 시간이 소요됩니다.\ninput() 데이터를 입력 받습니다.\n# O(N log N) unsorted_list = [int(x) for x in input().split()] merge_sort() n / 2로 나눠 1개의 요소가 남을때까지 재귀호출 합니다.\n# n / 2로 나눠 1개의 요소가 남을때까지 재귀호출 합니다. # 그 다음 2개씩의 요소들을 반복적으로 병합합니다. def merge_sort(unsorted_list): # if 구문을 통해 정렬되지 않은 리스트의 데이터가 1개 이하면 그대로 반환합니다. if len(unsorted_list) \u0026lt;= 1: return unsorted_list mid = len(unsorted_list) // 2 left = unsorted_list[:mid] right = unsorted_list[mid:] left1 = merge_sort(left) ## 재귀를 이용하여 왼쪽 리스트를 다시 나눕니다. right1 = merge_sort(right) ## 오른쪽도 마찬가지로 다시 나눕니다. return merge(left1, right1) merge_sort(unsorted_list)  merge() left와 right 리스트의 0번자리 부터 비교 후 작은 값을 sorted_list에 삽입합니다.\n비교가 끝난 후 남은 값을 sorted_list에 삽입합니다.\ndef merge(left, right): i = 0 j = 0 sorted_list = [] # 둘중 하나가 만족할때까지 append while i \u0026lt; len(left) and j \u0026lt; len(right): if left[i] \u0026lt; right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # 남은 값들을 넣어준다  while i \u0026lt; len(left): sorted_list.append(left[i]) i += 1 while j \u0026lt; len(right): sorted_list.append(right[j]) j += 1 return sorted_list # 리스트 예시 # merge_sort() 8 7 6 5 4 3 2 1 [8765] [4321] [87] [65] [43] [21] [8] [7] [6] [5] [4] [3] [2] [1] # merge()  [8] [7] [6] [5] [4] [3] [2] [1] [78] [56] [34] [12] [5678] [1234] 1 2 3 4 5 6 7 8 O(n²) 버블 정렬과 같은 비효율적인 정렬 알고리즘이 이에 해당합니다.\n이중 loop로 진행되는 알고리즘 이기때문에 시간 복잡도는 O(n²) 입니다.\ndef bubble_sort(l): swap = True while swap: swap = False for i in range(len(l)-1): if l[i] \u0026gt; l[i+1]: l[i], l[i+1] = l[i+1], l[i] swap = True lst = [8, 5, 3, 1, 4, 7, 9] bubble_sort(lst) O(n!) 브루트 포스로 알고리즘 문제를 풀이할 때가 이에 해당합니다.\nn=100만 되어도 n!은 9.332622e+157 입니다.\nfrom math import factorial print(factorial(100)) #933262154439441526816992388562667004907159682643816214685929638952175999932299156089414639761565182862536979208272237582511852109168640000000000000000000000000  마무리 빅오는 시간 복잡도 외에도 공간 복잡도를 표현하는 데에도 널리 쓰입니다.\n알고리즘은 시간과 공간이 트레이드오프 관계입니다. 실행 시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 사용하는 알고리즘은 실행 시간을 많이 사용합니다.\n이처럼 대부분의 경우 시간과 공간은 트레이드오프 관계이며, 이는 알고리즘의 주요한 특징 중 하나입니다.\n  시간 복잡도라고도 하며, 입력값이 무한대를 향할 때 함수 실행 시간 추이를 의미합니다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/datastructure/%EB%B9%85%EC%98%A4/","summary":"시간 복잡도는 왜 필요할까? 알고리즘은 어떤 문제를 해결하기 위한 일련의 과정 입니다.\n알고리즘 문제를 풀다보면 시간초과로 인해 시간복잡도를 생각해야 하는 경우가 자주 생기게되는데 동일한 문제해결 목표를 가진 알고리즘이 존재할 때 가장 시간복잡도가 가장 낮은 알고리즘을 사용 해야 시간초과 오류를 면할 수 있습니다.\n아무리 복잡한 알고리즘이라도 입력의 크기가 작으면 단시간에 끝나버리기 때문에 입력값의 크기가 충분히 클 때 그 효율성이 적나라하게 나타납니다.\n이러한 점근적 실행 시간1을 표기할 때 가장 널리쓰이는 수학적 표기법이 빅오 (big-O)입니다.","title":"빅오 (big-O)"},{"content":"Python 문법 인덴트 (Indent) Python의 공식 가이드 PEP 8에 따라 공백 4칸을 원칙으로 합니다.\n강제는 아니며 얼마든지 선택적으로 적용할 수는 있으나, Python 답게 이 기준을 준수하기로 합니다.\n 네이밍 컨벤션 (Naming Convention) Python의 네이밍 컨벤션은 자바와 달리 각 단어를 밑줄로 구분하는 Snake Case를 따릅니다.\n함수와 변수명 모두 Snake Case를 지향하고 있으며, Python의 철학에 따라 스네이크 코딩 스타일을 지향하도록 합니다.\ncamelCase: int = 1 # Camel Case snake_case: int = 1 # Snake Case  타입 힌트 (Type Hint) Python은 동적 타이핑 언어임에도 타입을 지정할 수 있는 타입 힌트를 지원합니다. (Python 버전 3.5 이상)\n변수 타입 지정 예시 a: str = \u0026#34;1\u0026#34; b: int = 1  타입 힌트를 사용하지 않으면 아래 예시처럼 a에는 숫자를 넘겨야하는지 문자를 넘겨야하는지 알 수 없습니다.\n이는 프로젝트 규모가 커지게 될 경우 좋지않은 가독성과 버그를 유발합니다.\n타입 힌트를 사용하지 않은 함수 예시 def fn(a):  그렇다면 어떻게 해야 타입 힌트를 사용하여 코드를 작관적으로 바꿀 수 있을까요?\n아래와 같이 파리미터가 정수형이면서 리턴값이 boolean값임을 알 수 있도록 타입 힌트를 사용하도록 합니다.\n타입 힌트를 사용한 함수 예시 def fn(a: int) -\u0026gt; bool:  강제 규약은 아니다보니 타입이 달라도 동적 할당이 될 수 있으므로 위와 같이 문자열에 정수를 할당하는 등의 사용 방식은 절대적으로 지양해야합니다.\n잘못된 동적 할당 예시 a: str = 1  추가적으로, mypy를 설치하여 타입 힌트에 오류가 없는지 자동으로 확인할 수 있습니다.\n$ pip install mypy  리스트 컴프리헨션 (List Comprehenshion) Python은 map, filter와 같은 함수형 기능을 지원하며 다음과 같은 람다 표현식도 지원합니다.\n람다 표현식 예시 list(map(lambda x: x+ 10, [1, 2, 3])) # [11, 12, 13]  람다 표현식도 굉장히 좋은 기능이지만 훨씬 더 유용한 기능은 리스트 컴프리헨션입니다.\n기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문으로 홀수인 경우 2를 곱해 출력하도록 하는 리스트 컴프리헨션 예시를 보시겠습니다.\n리스트 컴프리헨션 예시 [n * 2 for n in rnage(1, 11) if n % 2 = 1] # [2, 6, 10, 14, 18]  리스트 컴프리헨션을 사용하지 않는다면 다음과 같이 길게 풀어서 작성해야 합니다.\n리스트 컴프리헨션을 사용하지 않았을 때 예시 a = [] for n in range(1, 11): if n % 2 == 1: a.append(n * 2)  풀어서 작성한 코드는 리스트 컴프리헨션을 사용한 것에 비해 훨씬 더 길어졌고, a라는 별도의 리스트 변수 또한 필요해졌습니다.\n리스트 컴프리헨션과 비교했을 때 라인 수가 많이 증가한 것을 확인하실 수 있습니다.\n또한, 리스트 컴프리헨션이라고 해서 리스트만 지원하는 것은 아닙니다.\n딕셔너리 컴프리헨션을 사용한 예시 # 리스트 컴프리헨션 미사용 a = {} for key, value in original.items(): a[key] = value # 리스트 컴프리헨션 사용 a = {key, value for key, value in original.items()}  이처럼 딕셔너리도 컴프리헨션이 가능합니다. (파이썬 버전 2.7 이상)\n무리하게 사용할 경우 가독성을 떨어뜨릴 수 있으므로 적절히 사용하는 게 중요합니다.\n 제너레이터 (Generaotr) 제너레이터는 루프의 반복동작을 제어할 수 있는 루틴 형태를 의미합니다.\n예를들어 임의의 조건으로 숫자 1억 개를 만들어내 계산하는 프로그램을 작성한다고 가정해봅니다.\n이 경우 제너레이터가 없다면 메모리 어딘가에 만들어낸 숫자 1억 개를 보관하고 있어야하는 소모가 발생합니다.\nyield 구문을 사용하여 제너레이터를 리턴할 수 있는데, 기존의 함수는 return 구문을 맞닥뜨리면 값을 리턴하고 모든 함수의 동작을 종료했습니다.\n그러나 yield는 제너레이터가 실행 중이던 값을 내보낸다는 의미로, 중간값을 리턴한 다음 함수는 종료되지 않고 계속해서 맨 끝에 도달할 때까지 실행됩니다.\n제너레이터 사용 예시 def get_natural_number(): n = 0 while True: n += 1 yield n  제너레이터를 이용하여 100개의 값을 생성하고자 한다면 다음과 같이 100번의 next()를 수행하도록 합니다.\nnext() 사용 예시 g = get_natural_number() for _ in range(0, 100): prnit(next(g))  제너레이터는 여러 타입의 값을 하나의 함수에서 생성하는 것도 가능합니다.\n여러 타입의 값 생성 예시 def generator(): yield 1 yield \u0026#39;string\u0026#39; yield True g = generaotr() print(next(g)) # 1 print(next(g)) # \u0026#39;string\u0026#39; print(next(g)) # True  range 제니레이터의 방식을 활용하는 대표적인 함수로 range()가 존재합니다.\n주로 for 문에서 쓰이는 range() 함수의 쓰임은 다음과 같습니다.\nlist(range(5)) # [0, 1, 2, 3, 4] for i in range(5): print(i) # 0 1 2 3 4   range() 를 사용하는 이유는 메모리 효율때문입니다. 생성 조건만 정해두고 필요할 때 생성해서 꺼내 쓸 수 있기 때문입니다.\n예를들어 100만 개의 숫자를 생성해야한다면 어떻게 될까요? 메모리에서 적지 않은 공간을 차지할 것이고 생성 시간도 오래 걸릴 것입니다.\nrange 사용 예시 a = [n for n in range(1000000)] b = range(100000)  위 코드를 다음과 같이 len()으로 길이 비교를 해보면 둘 다 동일한 100만 개가 출력되며, 비교연산자에서도 True를 리턴합니다.\nrange 비교 예시 len(a) # 1000000 len(b) # 1000000 len(a) == len(b) # True  하지만 둘 사이의 메모리 점유율을 비교해보면 range 클래스를 곧바로 리턴하는 방식이 훨씬 더 적은것을 확인 할 수 있습니다\n메모리 점유율 비교 예시 sys.getsizeof(a) # 8697464 sys.getsizeof(b) # 48  range 클래스를 이용하면 값이 1억 개라도 b 변수의 메모리 점유율은 동일합니다/\n생성 조건만 보관하고 있기 때문입니다.\n게다가 인덱스로 접근 시에는 곧바로 생성하도록 구현되어 있기 때문에 다음과 같이 리스트와 거의 동일한 느낌으로 불편 없이 사용할 수 있습니다.\n인덱스 참조 예시 b[999] # 999  enumerate enumerate()는 \u0026lsquo;열거하다\u0026rsquo;는 뜻의 함수입니다.\n아래와 같이 여러가지 자료형(list, set, tuple 등)을 인덱스를 포함한 enumerate 객체로 리턴합니다.\nenumerate 사용 예시 a = [1, 2, 3, 2, 45, 2, 5] list(enumerate(a)) # [(0, 1), (1, 2), (2, 3), (3, 2), (4, 45), (5, 2), (6, 5)] a = ['a1', 'b2', 'c3']를 key, value형태로 출력하기 위해 enumerate 함수를 활용할 수 있습니다.\nenumerate 활용 예시 a = [\u0026#39;a1\u0026#39;, \u0026#39;b2\u0026#39;, \u0026#39;c3\u0026#39;] for key, value in enumerate(a): print(key, value)  print 코딩 테스트 문제 풀이 과정에서 디버깅을 할 때 가장 많이 쓰이는 명령어는 바로 print() 입니다.\n이를 좀 더 유용하게 활용할 수 있는 방법 몇 가지를 살펴봅니다.\n1) 콤마(,)로 구분하면 띄어쓰기 구분자로 값을 구분하여 출력합니다. print(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;) # A B 2) 콤마(,)를 구분자로 지정하려면 seq를 사용합니다. print(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, seq=\u0026#39;,\u0026#39;) # A,B 3) print()는 항상 줄바꿈을 합니다. 줄바꿈을 하지 않도록 제한 하려면 end를 사용합니다. print(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, end=\u0026#39; \u0026#39;) print(\u0026#39;C\u0026#39;) # A B C 4) 리스트를 한 줄에 출력하고자 할 때는 join()을 사용합니다. a = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;] \u0026#39; \u0026#39;.join(a) # A B 5) 인덱스를 활용하여 변수에 값을 더해 출력 가능합니다. idx = 1 fruit = \u0026#34;Apple\u0026#34; print(\u0026#39;{0}: {1}\u0026#39;.format(idx + 1, fruit)) # 인덱스 생략 가능: print(\u0026#34;{}: {}\u0026#34;.format(idx + 1, fruit)) # 2: Apple 6) f-string(formated string literal)을 사용하면 별도로 변수를 부여할 필요 없이 사용 가능합니다. 템플릿을 사용하듯 인라인으로 삽입할 수 있어 편리하고, .format을 부여하는 방식에 비해 훨씬 간결하고 직관적입니다.\nidx = 1 fruit = \u0026#34;Apple\u0026#34; print(f\u0026#39;{idx +1}: {fruit}\u0026#39;)  locals locals()는 로컬 스코프에 선언된 모든 변수를 조회할 수 있는 명령어입니다.\n코딩 테스트 플랫폼 문제 풀이 중에도 코디 내부에 출력해 활용할 수 있습니다.\nlocals() 호출 예시 import pprint pprint.pprint(locals())  pprint로 출력하게 되면 보기 좋게 줄바끔 처리를 해주기 때문에 가독성높은 출력문 확인이 가능합니다.\n Python의 특징 루프 (Loop) 1부터 10까지의 합을 구하는 간단한 루프 구조 예시입니다.\n예시 1 sum = 0 for i in range(1, 11): sum += i 예시 2 sum = 0 sum = sum(i for i in range(1, 11)) 예시 3 sum = sum(range(1, 11))  생산적인 언어답게 One-Liner로 처리가 가능합니다.\n한 줄 처리의 경우 깔끔하고 생산적입니다만, 지나친 사용은 가독성을 떨어트릴 수 있으므로 적절하게 사용합니다.\n제네릭 (Generic) 1 제네릭이란 클래스 내부에서 사용 할 파라미터의 타입을 외부에서 지정되게 하는 기법입니다.\n즉, 인스턴스를 생성할 때 데이터 타입을 지정하여 객체의 재활용성을 높일 수 있는 프로그래밍 스타일입니다.\ndef are_equal(a, b): return a == b are_equal(10, 10.0)  예시 코드 실행 시 따로 파라미터에 타입을 지정해주지 않았음에도 코드가 정상동작 합니다.\nPython은 동적 타이핑 언어로 제네릭이 필요하지 않기 때문입니다.\n하지만 타입을 명시해주지 않으면 가독성이 떨어지고, 버그 발생 확률이 높아진다는 단점이 있습니다.\n하여 Python 3.5 이상 버전부터 제네릭을 사용 할 수 있게 되어 다음과 같이 타입을 명시할 수 있게 되었습니다.\nfrom typing import List, TypeVar T = TypeVar(\u0026#39;T\u0026#39;, int, str, List[int]) # T는 int, str, List[int] Type 일 수 있습니다. def are_equal(a: T, b: T) -\u0026gt; T: return a + b print(are_equal(1, 3)) # [int, int] -\u0026gt; int print(are_equal(\u0026#39;item\u0026#39;, \u0026#39;4\u0026#39;)) # [str, str] -\u0026gt; str print(are_equal([10], [10.0])) # [List[int], List[int]] -\u0026gt; List[int] print(are_equal(\u0026#39;item\u0026#39;, 4)) # Err 배열 반복 foo = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] for f in foo: print(f)  다른 언어에 비해 자료형이라는 선언이 필요 없는 Python 코드는 매우 간결합니다.\n클래스 from dataclasses import dataclass @dataclass class Rectangle: weight: int price: int def area(self): return self.weight * self.price rect = Rectangle(3, 4) print(rect.area())  Python 3.7부터 dataclass를 지원합니다.\n@dataclass 데코레이션으로 타입 힌트와 함께 활용하여 다음과 같이 class를 정의 할 수 있습니다.\ndataclass를 선언하지 않아도 클래스 구현에는 문제가 없으나 선언하게 되면 여러 가지 내부 함수 기능을 자동으로 구현해주기 때문에 활용하는게 좋습니다.\n  제네릭 프로그래밍(영어: generic programming)은 데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있는 기술에 중점을 두어 재사용성을 높일 수 있는 프로그래밍 방식이다. (위키백과)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/python/python-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/","summary":"Python 문법 인덴트 (Indent) Python의 공식 가이드 PEP 8에 따라 공백 4칸을 원칙으로 합니다.\n강제는 아니며 얼마든지 선택적으로 적용할 수는 있으나, Python 답게 이 기준을 준수하기로 합니다.\n 네이밍 컨벤션 (Naming Convention) Python의 네이밍 컨벤션은 자바와 달리 각 단어를 밑줄로 구분하는 Snake Case를 따릅니다.\n함수와 변수명 모두 Snake Case를 지향하고 있으며, Python의 철학에 따라 스네이크 코딩 스타일을 지향하도록 합니다.\ncamelCase: int = 1 # Camel Case snake_case: int = 1 # Snake Case  타입 힌트 (Type Hint) Python은 동적 타이핑 언어임에도 타입을 지정할 수 있는 타입 힌트를 지원합니다.","title":"Python 살펴보기"},{"content":"언어는 Python으로 하겠습니다. 근데 이제 알고리즘을 곁들인 Python을 선택한 이유 대다수의 코딩 인터뷰에서 Python 지원, 초보자도 쉽게 접근할 수 있는 언어, 수많은 자료구조 모듈, 짧은 코드 길이와 가독성, 쉬운 문자열 핸들링, 임의 정밀도 정수형으로 신경 쓰지 않아도 되는 오버플로는 Python의 대표적인 장점들이다.\n코딩 테스트 플랫폼1 에서 언어별 타임아웃 설정이 C++, Java에 비해 굉장히 타이트하기 때문에 동일한 알고리즘임에도 파이썬으로는 풀리지 않는 (억울한) 일이 심심찮게 발생하고 있지만!\n알고리즘 최적화에 좀 더 많은 고민이 필요하기 때문에 유연한 사고와 학습을 목표로 하는 나에겐 오히려 좋은 점으로 작용하게 될 것 같다.\nPython 시작하기 (Only Mac) Python을 설치하기에 앞서 Mac OS 패키지 관리 도구인 homebrew부터 설치한다.\n homebrew 설치\n 하단의 Command를 터미널에서 실행시킨다.\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)  pyenv와 pyenv-virtualenv를 이용한 Python 개발 환경 구성\n 인터프리터 환경은 주기적인 업데이트가 이루어진다.\n업데이트가 이루어질때마다 새로운 버전의 개발 환경을 재설치하는 것은 매우 귀찮고 번거로운 일 일것이다.\nPython을 버전별로 관리 할 수 있도록 Python Version Manager인 pyenv를 설치하도록 하자.\nbrew update brew install pyenv  이어서 가상환경을 이용해 Python 프로젝트를 분리 운영 할 수 있도록 pyenv-virtualenv를 설치한다.\n프로젝트 마다 설치된 패키지 사이의 충돌을 막아 주기 위함이다.\nbrew install pyenv-virtualenv  pyenv및 pyenv-virtualenv가 정상동작 할 수 있도록 셀 설정파일에 각 프로그램의 초기화 코드를 추가하여 환경변수를 설정한다.\nCatalina 이후 버전부터 기본 셸이 zsh로 변경되었기 때문에 ~/.zshrc 파일을 수정했다.\necho $SHELL 명령어를 사용해 간단히 사용중인 쉘이 무엇인지 간단히 확일 할 수 있으니 참고하자.\nvi ~/.zshrc export PATH=$HOME/.pyenv/bin:$PATH eval \u0026#34;$(pyenv init -)\u0026#34; eval \u0026#34;$(pyenv virtualenv-init -)\u0026#34;  변경사항을 반영한다\n source ~/.zshrc #설정 저장 - zsh exec $SHELL #shell 재실행  Python을 버전에 맞게 설치한다.\n필자는 3.7.7 버전을 설치했다.\npyenv install 3.7.7  Mac OS 가 Big sur로 버전업 되면서 XCode 관련 업데이트가 있었는지 BUILD FAILED 에러가 발생했다.\n급한대로 하단 명령어를 실행하여 Python을 설치했다.\nCFLAGS=\u0026#34;-I$(brew --prefix openssl)/include -I$(brew --prefix bzip2)/include -I$(brew --prefix readline)/include -I$(xcrun --show-sdk-path)/usr/include\u0026#34; LDFLAGS=\u0026#34;-L$(brew --prefix openssl)/lib -L$(brew --prefix readline)/lib -L$(brew --prefix zlib)/lib -L$(brew --prefix bzip2)/lib\u0026#34; pyenv install --patch 3.7.7 \u0026lt; \u0026lt;(curl -sSL https://github.com/python/cpython/commit/8ea6353.patch\\?full_index\\=1)  가상환경 명령어를 상황에 맞게 실행한다.\npython -V # 2.7.7 출력 pyenv virtualenv 3.7.7 workspace # 가상환경 생성 pyenv virtualenv \u0026lt;version\u0026gt; \u0026lt;virtualenv_name\u0026gt;  pyenv activate workspace python -V # 3.7.7 출력 pyenv deactivate # 가상환경 해제하기   해커랭크 (https://www.hackerrank.com)\n코딜리티 (https://www.codility.com)\n리모트인터뷰 (https://www.remoteinterview.io)\n프로그래머스(국내) (https://www.programmers.co.kr) 등이 있다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/python/python-%EC%9E%85%EB%AC%B8%ED%95%98%EA%B8%B0/","summary":"언어는 Python으로 하겠습니다. 근데 이제 알고리즘을 곁들인 Python을 선택한 이유 대다수의 코딩 인터뷰에서 Python 지원, 초보자도 쉽게 접근할 수 있는 언어, 수많은 자료구조 모듈, 짧은 코드 길이와 가독성, 쉬운 문자열 핸들링, 임의 정밀도 정수형으로 신경 쓰지 않아도 되는 오버플로는 Python의 대표적인 장점들이다.\n코딩 테스트 플랫폼1 에서 언어별 타임아웃 설정이 C++, Java에 비해 굉장히 타이트하기 때문에 동일한 알고리즘임에도 파이썬으로는 풀리지 않는 (억울한) 일이 심심찮게 발생하고 있지만!\n알고리즘 최적화에 좀 더 많은 고민이 필요하기 때문에 유연한 사고와 학습을 목표로 하는 나에겐 오히려 좋은 점으로 작용하게 될 것 같다.","title":"Python 입문하기"}]