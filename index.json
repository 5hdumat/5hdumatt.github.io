[{"content":"Python 문법 인덴트 (Indent) Python의 공식 가이드 PEP 8에 따라 공백 4칸을 원칙으로 합니다.\n강제는 아니며 얼마든지 선택적으로 적용할 수는 있으나, Python 답게 이 기준을 준수하기로 합니다.\n 네이밍 컨벤션 (Naming Convention) Python의 네이밍 컨벤션은 자바와 달리 각 단어를 밑줄로 구분하는 Snake Case를 따릅니다.\n함수와 변수명 모두 Snake Case를 지향하고 있으며, Python의 철학에 따라 스네이크 코딩 스타일을 지향하도록 합니다.\ncamelCase: int = 1 # Camel Case snake_case: int = 1 # Snake Case  타입 힌트 (Type Hint) Python은 동적 타이핑 언어임에도 타입을 지정할 수 있는 타입 힌트를 지원합니다. (Python 버전 3.5 이상)\n변수 타입 지정 예시 a: str = \u0026#34;1\u0026#34; b: int = 1  타입 힌트를 사용하지 않으면 아래 예시처럼 a에는 숫자를 넘겨야하는지 문자를 넘겨야하는지 알 수 없습니다.\n이는 프로젝트 규모가 커지게 될 경우 좋지않은 가독성과 버그를 유발합니다.\n타입 힌트를 사용하지 않은 함수 예시 def fn(a):  그렇다면 어떻게해야 타입힌트를 사용하여 코드를 작관적으로 바꿀 수 있을까요?\n아래와 같이 파리미터가 정수형이면서 리턴값이 boolean값임을 알 수 있도록 타입 힌트를 사용하도록 합니다.\n타입 힌트를 사용한 함수 예시 def fn(a: int) -\u0026gt; bool:  강제 규약은 아니다보니 타입이 달라도 동적 할당이 될 수 있으므로 위와 같이 문자열에 정수를 할당하는 등의 사용 방식은 절대적으로 지양해야합니다.\n잘못된 동적 할당 예시 a: str = 1  추가적으로, mypy를 설치하여 타입 힌트에 오류가 없는지 자동으로 확인할 수 있습니다.\n$ pip install mypy  리스트 컴프리헨션 (List Comprehenshion) Python은 map, filter와 같은 함수형 기능을 지원하며 다음과 같은 람다 표현식도 지원합니다.\n람다 표현식 예시 list(map(lambda x: x+ 10, [1, 2, 3])) # [11, 12, 13]  람다 표현식도 굉장히 좋은 기능이지만 훨씬 더 유용한 기능은 리스트 컴프리헨션입니다.\n기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문으로 홀수인 경우 2를 곱해 출력하도록 하는 리스트 컴프리헨션 예시를 보시겠습니다.\n리스트 컴프리헨션 예시 [n * 2 for n in rnage(1, 11) if n % 2 = 1] # [2, 6, 10, 14, 18]  리스트 컴프리헨션을 사용하지 않는다면 다음과 같이 길게 풀어서 작성해야 합니다.\n리스트 컴프리헨션을 사용하지 않았을 때 예시 a = [] for n in range(1, 11): if n % 2 == 1: a.append(n * 2)  풀어서 작성한 코드는 리스트 컴프리헨션을 사용한 것에 비해 훨씬 더 길어졌고, a라는 별도의 리스트 변수 또한 필요해졌습니다.\n리스트 컴프리헨션과 비교했을 때 라인 수가 많이 증가한 것을 확인하실 수 있습니다.\n또한, 리스트 컴프리헨션이라고 해서 리스트만 지원하는 것은 아닙니다.\n딕셔너리 컴프리헨션을 사용한 예시 # 리스트 컴프리헨션 미사용 a = {} for key, value in original.items(): a[key] = value # 리스트 컴프리헨션 사용 a = {key, value for key, value in original.items()}  이처럼 딕셔너리도 컴프리헨션이 가능합니다. (파이썬 버전 2.7 이상)\n무리하게 사용할 경우 가독성을 떨어뜨릴 수 있으므로 적절히 사용하는 게 중요합니다.\n 제너레이터 (Generaotr) 제너레이터는 루프의 반복동작을 제어할 수 있는 루틴 형태를 의미합니다.\n예를들어 임의의 조건으로 숫자 1억 개를 만들어내 계산하는 프로그램을 작성한다고 가정해봅니다.\n이 경우 제너레이터가 없다면 메모리 어딘가에 만들어낸 숫자 1억 개를 보관하고 있어야하는 소모가 발생합니다.\nyield 구문을 사용하여 제너레이터를 리턴할 수 있는데, 기존의 함수는 return 구문을 맞닥뜨리면 값을 리턴하고 모든 함수의 동작을 종료했습니다.\n그러나 yield는 제너레이터가 실행 중이던 값을 내보낸다는 의미로, 중간값을 리턴한 다음 함수는 종료되지 않고 계속해서 맨 끝에 도달할 때까지 실행됩니다.\n제너레이터 사용 예시 def get_natural_number(): n = 0 while True: n += 1 yield n  제너레이터를 이용하여 100개의 값을 생성하고자 한다면 다음과 같이 100번의 next()를 수행하도록 합니다.\nnext() 사용 예시 g = get_natural_number() for _ in range(0, 100): prnit(next(g))  제너레이터는 여러 타입의 값을 하나의 함수에서 생성하는 것도 가능합니다.\n여러 타입의 값 생성 예시 def generator(): yield 1 yield \u0026#39;string\u0026#39; yield True g = generaotr() print(next(g)) # 1 print(next(g)) # \u0026#39;string\u0026#39; print(next(g)) # True  range 제니레이터의 방식을 활용하는 대표적인 함수로 range()가 존재합니다.\n주로 for 문에서 쓰이는 range() 함수의 쓰임은 다음과 같습니다.\nlist(range(5)) # [0, 1, 2, 3, 4] for i in range(5): print(i) # 0 1 2 3 4   range() 를 사용하는 이유는 메모리 효율때문입니다. 생성 조건만 정해두고 필요할 때 생성해서 꺼내 쓸 수 있기 때문입니다.\n예를들어 100만 개의 숫자를 생성해야한다면 어떻게 될까요? 메모리에서 적지 않은 공간을 차지할 것이고 생성 시간도 오래 걸릴 것입니다.\nrange 사용 예시 a = [n for n in range(1000000)] b = range(100000)  위 코드를 다음과 같이 len()으로 길이 비교를 해보면 둘 다 동일한 100만 개가 출력되며, 비교연산자에서도 True를 리턴합니다.\nrange 비교 예시 len(a) # 1000000 len(b) # 1000000 len(a) == len(b) # True  하지만 둘 사이의 메모리 점유율을 비교해보면 range 클래스를 곧바로 리턴하는 방식이 훨씬 더 적은것을 확인 할 수 있습니다\n메모리 점유율 비교 예시 sys.getsizeof(a) # 8697464 sys.getsizeof(b) # 48  range 클래스를 이용하면 값이 1억 개라도 b 변수의 메모리 점유율은 동일합니다/\n생성 조건만 보관하고 있기 때문입니다.\n게다가 인덱스로 접근 시에는 곧바로 생성하도록 구현되어 있기 때문에 다음과 같이 리스트와 거의 동일한 느낌으로 불편 없이 사용할 수 있습니다.\n인덱스 참조 예시 b[999] # 999  enumerate enumerate()는 \u0026lsquo;열거하다\u0026rsquo;는 뜻의 함수입니다.\n아래와 같이 여러가지 자료형(list, set, tuple 등)을 인덱스를 포함한 enumerate 객체로 리턴합니다.\nenumerate 사용 예시 a = [1, 2, 3, 2, 45, 2, 5] list(enumerate(a)) # [(0, 1), (1, 2), (2, 3), (3, 2), (4, 45), (5, 2), (6, 5)] a = ['a1', 'b2', 'c3']를 key, value형태로 출력하기 위해 enumerate 함수를 활용할 수 있습니다.\nenumerate 활용 예시 a = [\u0026#39;a1\u0026#39;, \u0026#39;b2\u0026#39;, \u0026#39;c3\u0026#39;] for key, value in enumerate(a): print(key, value)  print 코딩 테스트 문제 풀이 과정에서 디버깅을 할 때 가장 많이 쓰이는 명령어는 바로 print() 입니다.\n이를 좀 더 유용하게 활용할 수 있는 방법 몇 가지를 살펴봅니다.\n1) 콤마(,)로 구분하면 띄어쓰기 구분자로 값을 구분하여 출력합니다. print(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;) # A B 2) 콤마(,)를 구분자로 지정하려면 seq를 사용합니다. print(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, seq=\u0026#39;,\u0026#39;) # A,B 3) print()는 항상 줄바꿈을 합니다. 줄바꿈을 하지 않도록 제한 하려면 end를 사용합니다. print(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, end=\u0026#39; \u0026#39;) print(\u0026#39;C\u0026#39;) # A B C 4) 리스트를 한 줄에 출력하고자 할 때는 join()을 사용합니다. a = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;] \u0026#39; \u0026#39;.join(a) # A B 5) 인덱스를 활용하여 변수에 값을 더해 출력 가능합니다. idx = 1 fruit = \u0026#34;Apple\u0026#34; print(\u0026#39;{0}: {1}\u0026#39;.format(idx + 1, fruit)) # 인덱스 생략 가능: print(\u0026#34;{}: {}\u0026#34;.format(idx + 1, fruit)) # 2: Apple 6) f-string(formated string literal)을 사용하면 별도로 변수를 부여할 필요 없이 사용 가능합니다. 템플릿을 사용하듯 인라인으로 삽입할 수 있어 편리하고, .format을 부여하는 방식에 비해 훨씬 간결하고 직관적입니다.\nidx = 1 fruit = \u0026#34;Apple\u0026#34; print(f\u0026#39;{idx +1}: {fruit}\u0026#39;) locals locals()는 로컬 스코프에 선언된 모든 변수를 조회할 수 있는 명령어입니다.\n코딩 테스트 플랫폼 문제 풀이 중에도 코디 내부에 출력해 활용할 수 있습니다.\nlocals() 호출 예시 import pprint pprint.pprint(locals())  pprint로 출력하게 되면 보기 좋게 줄바끔 처리를 해주기 때문에 가독성높은 출력문 확인이 가능합니다.\n Python의 특징 루프 (Loop) 1부터 10까지의 합을 구하는 간단한 루프 구조 예시입니다.\n예시 1 sum = 0 for i in range(1, 11): sum += i 예시 2 sum = 0 sum = sum(i for i in range(1, 11)) 예시 3 sum = sum(range(1, 11))  생산적인 언어답게 One-Liner로 처리가 가능합니다.\n한 줄 처리의 경우 깔끔하고 생산적입니다만, 지나친 사용은 가독성을 떨어트릴 수 있으므로 적절하게 사용합니다.\n제네릭 (Generic) 1 제네릭이란 클래스 내부에서 사용 할 파라미터의 타입을 외부에서 지정되게 하는 기법입니다.\n즉, 인스턴스를 생성할 때 데이터 타입을 지정하여 객체의 재활용성을 높일 수 있는 프로그래밍 스타일입니다.\ndef are_equal(a, b): return a == b are_equal(10, 10.0)  예시 코드 실행 시 따로 파라미터에 타입을 지정해주지 않았음에도 코드가 정상동작 합니다.\nPython은 동적 타이핑 언어로 제네릭이 필요하지 않기 때문입니다.\n하지만 타입을 명시해주지 않으면 가독성이 떨어지고, 버그 발생 확률이 높아진다는 단점이 있습니다.\n하여 Python 3.5 이상 버전부터 제네릭을 사용 할 수 있게 되어 다음과 같이 타입을 명시할 수 있게 되었습니다.\nfrom typing import List, TypeVar T = TypeVar(\u0026#39;T\u0026#39;, int, str, List[int]) # T는 int, str, List[int] Type 일 수 있습니다. def are_equal(a: T, b: T) -\u0026gt; T: return a + b print(are_equal(1, 3)) # [int, int] -\u0026gt; int print(are_equal(\u0026#39;item\u0026#39;, \u0026#39;4\u0026#39;)) # [str, str] -\u0026gt; str print(are_equal([10], [10.0])) # [List[int], List[int]] -\u0026gt; List[int] print(are_equal(\u0026#39;item\u0026#39;, 4)) # Err 배열 반복 foo = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] for f in foo: print(f)  다른 언어에 비해 자료형이라는 선언이 필요 없는 Python 코드는 매우 간결합니다.\n클래스 from dataclasses import dataclass @dataclass class Rectangle: weight: int price: int def area(self): return self.weight * self.price rect = Rectangle(3, 4) print(rect.area())  Python 3.7부터 dataclass를 지원합니다.\n@dataclass 데코레이션으로 타입 힌트와 함께 활용하여 다음과 같이 class를 정의 할 수 있습니다.\ndataclass를 선언하지 않아도 클래스 구현에는 문제가 없으나 선언하게 되면 여러 가지 내부 함수 기능을 자동으로 구현해주기 때문에 활용하는게 좋습니다.\n  제네릭 프로그래밍(영어: generic programming)은 데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있는 기술에 중점을 두어 재사용성을 높일 수 있는 프로그래밍 방식이다. (위키백과)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/python/python-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/","summary":"Python 문법 인덴트 (Indent) Python의 공식 가이드 PEP 8에 따라 공백 4칸을 원칙으로 합니다.\n강제는 아니며 얼마든지 선택적으로 적용할 수는 있으나, Python 답게 이 기준을 준수하기로 합니다.\n 네이밍 컨벤션 (Naming Convention) Python의 네이밍 컨벤션은 자바와 달리 각 단어를 밑줄로 구분하는 Snake Case를 따릅니다.\n함수와 변수명 모두 Snake Case를 지향하고 있으며, Python의 철학에 따라 스네이크 코딩 스타일을 지향하도록 합니다.\ncamelCase: int = 1 # Camel Case snake_case: int = 1 # Snake Case  타입 힌트 (Type Hint) Python은 동적 타이핑 언어임에도 타입을 지정할 수 있는 타입 힌트를 지원합니다.","title":"Python 살펴보기"},{"content":"문제  다솜이는 은진이의 옆집에 새로 이사왔다. 다솜이는 자기 방 번호를 예쁜 플라스틱 숫자로 문에 붙이려고 한다.\n다솜이의 옆집에서는 플라스틱 숫자를 한 세트로 판다. 한 세트에는 0번부터 9번까지 숫자가 하나씩 들어있다. 다솜이의 방 번호가 주어졌을 때, 필요한 세트의 개수의 최솟값을 출력하시오.  (6은 9를 뒤집어서 이용할 수 있고, 9는 6을 뒤집어서 이용할 수 있다.)    풀이 이 문제의 키 포인트는 6과 9를 공통적으로 사용 할 수 있다는 점입니다.\n9993을 입력했을 때 number_list가 어떻게 변하는지 테이블로 표현하자면 아래와 같습니다.\n    0 1 2 3 4 5 6 7 8 9     9 0 0 0 0 0 0 0 0 0 1   9 0 0 0 0 0 0 1 0 0 1   9 0 0 0 0 0 0 1 0 0 2   3 0 0 0 1 0 0 1 0 0 2    리스트의 값을 하나씩 증가시켰을때 가장 큰 값이 필요한 세트 수 입니다.\nn = input() number_list = [0] * 10 for i in range(len(n)): num = int(n[i]) if num == 9 or num == 6: if number_list[9] \u0026gt;= number_list[6]: number_list[6] += 1 elif number_list[9] \u0026lt;= number_list[6]: number_list[9] += 1 else: number_list[num] += 1 print(max(number_list)) ","permalink":"https://5hdumat.github.io/posts/algorithm/implementation/1475/","summary":"문제  다솜이는 은진이의 옆집에 새로 이사왔다. 다솜이는 자기 방 번호를 예쁜 플라스틱 숫자로 문에 붙이려고 한다.\n다솜이의 옆집에서는 플라스틱 숫자를 한 세트로 판다. 한 세트에는 0번부터 9번까지 숫자가 하나씩 들어있다. 다솜이의 방 번호가 주어졌을 때, 필요한 세트의 개수의 최솟값을 출력하시오.  (6은 9를 뒤집어서 이용할 수 있고, 9는 6을 뒤집어서 이용할 수 있다.)    풀이 이 문제의 키 포인트는 6과 9를 공통적으로 사용 할 수 있다는 점입니다.","title":"1475번: 방 번호"},{"content":"문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  N개의 자연수 중에서 M개를 고른 수열    중복되는 수열을 한번만 출력하도록 하는 경우의 수를 보여줘야하는 문제였습니다.\n풀이 n, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n temp_list = [] output = [] def dfs(depth): if depth == m: if not tuple(temp_list) in output: output.append(tuple(temp_list)) return for i in range(n): if not visited[i]: visited[i] = True temp_list.append(number_list[i]) dfs(depth + 1) visited[i] = False temp_list.pop() dfs(0) for i in output: print(*i)  묻지도 따지지도 않고 값이 맞게 출력되길래 제출했더니 시간 초과가 반환되었습니다.\nif not tuple(temp_list) in output: 값의 포함 관계 여부를 따지는 if a in b 구문과 중복 수열로 인한 성능 이슈였습니다.\n포함 관계 여부를 따지는 과정에서 급증된 소요시간은 hash 기반으로 만들어진 set()을 사용하여 중복 데이터를 제거한 후 시간 초과를 해결할 수 있었습니다.\nhash에 대해선 차 후 블로그에 정리해두도록 하겠습니다.\nn, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n temp_list = [] output = [] def dfs(depth): if depth == m: output.append(tuple(temp_list)) return for i in range(n): if not visited[i]: visited[i] = True temp_list.append(number_list[i]) dfs(depth + 1) visited[i] = False temp_list.pop() dfs(0) output = list(set(output)) output.sort() for i in output: print(*i) 보완할 점 그럼에도 불구하고 중복 수열이슈는 해결되지 않았습니다.\noverlap이란 변수를 만들어 전에 쓰인 변수 값과 비교하도록 했습니다. (초기값 0, 자연수가 아니므로)\n위치는 탈출문 바로 아래쪽에 위치하게 했는데, 이유는 깊이가 다를 때마다 변수를 초기화해야하기 때문입니다.\n방문 여부를 확인함과 동시에 값도 이전에 쓰인 변수 값과 같은지 확인하여 dfs를 진행하기 직전에 현재의 변수 값을 넘겨주었습니다.\nn, m = list(map(int, input().split())) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n output = [] def dfs(depth): if depth == m: print(*output) return overlap = 0 for i in range(n): if not visited[i] and overlap != number_list[i]: visited[i] = True output.append(number_list[i]) overlap = number_list[i] dfs(depth + 1) visited[i] = False output.pop() dfs(0) ","permalink":"https://5hdumat.github.io/posts/algorithm/backtracking/15663/","summary":"문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  N개의 자연수 중에서 M개를 고른 수열    중복되는 수열을 한번만 출력하도록 하는 경우의 수를 보여줘야하는 문제였습니다.\n풀이 n, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n temp_list = [] output = [] def dfs(depth): if depth == m: if not tuple(temp_list) in output: output.","title":"15663번: N과 M (9)"},{"content":"문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다.  N개의 자연수 중에서 M개를 고른 수열 같은 수를 여러 번 골라도 된다. 고른 수열은 비내림차순이어야 한다.  길이가 K인 수열 A가 A1 ≤ A2 ≤ \u0026hellip; ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.      풀이 방문 체크 리스트 visited 관련 문구를 제거하여 자기 자신도 포함 할 수 있게합니다.\nidx 변수를 추가해 호출 시 idx 이하의 값은 입력받지 않도록 한 후 해결했습니다.\nn, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() output = [] def dfs(depth, idx): if depth == m: # 탈출 조건 print(*output) # *: list Unpacking 후 출력 return for i in range(idx, n): output.append(number_list[i]) dfs(depth + 1, i) output.pop() dfs(0, 0) ","permalink":"https://5hdumat.github.io/posts/algorithm/backtracking/15657/","summary":"문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다.  N개의 자연수 중에서 M개를 고른 수열 같은 수를 여러 번 골라도 된다. 고른 수열은 비내림차순이어야 한다.  길이가 K인 수열 A가 A1 ≤ A2 ≤ \u0026hellip; ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.      풀이 방문 체크 리스트 visited 관련 문구를 제거하여 자기 자신도 포함 할 수 있게합니다.","title":"15657번: N과 M (8)"},{"content":"문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다.  N개의 자연수 중에서 M개를 고른 수열 같은 수를 여러 번 골라도 된다.    풀이 방문 체크 리스트 visited 관련 문구를 제거한 후 쉽게 해결할 수 있었습니다.\nn, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() output = [] def dfs(depth): if depth == m: # 탈출 조건 print(*output) # *: list Unpacking 후 출력 return for i in range(n): output.append(number_list[i]) dfs(depth + 1) output.pop() dfs(0) ","permalink":"https://5hdumat.github.io/posts/algorithm/backtracking/15656/","summary":"문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다.  N개의 자연수 중에서 M개를 고른 수열 같은 수를 여러 번 골라도 된다.    풀이 방문 체크 리스트 visited 관련 문구를 제거한 후 쉽게 해결할 수 있었습니다.\nn, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() output = [] def dfs(depth): if depth == m: # 탈출 조건 print(*output) # *: list Unpacking 후 출력 return for i in range(n): output.","title":"15656번: N과 M (7)"},{"content":"문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다.  N개의 자연수 중에서 M개를 고른 수열 고른 수열은 오름차순이어야 한다.    풀이 number_list 변수를 리스트로 입력받아 오름차순 정렬을 해주었습니다.\n기존의 output.append(i) 구문을 output.append(number_list[i])로 변경하여 number_list 인자 값을 출력 리스트 output에 추가하였습니다.\nidx 변수를 추가하여 재귀 호출 시 idx 이하의 값은 입력받지 않도록 하였습니다.\n두 번째 문제풀이 이후 비슷한 패턴의 문제가 반복되는 것 같습니다.\nn, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n output = [] def dfs(depth, idx): if depth == m: # 탈출 조건 print(*output) # *: list Unpacking 후 출력 return for i in range(idx, n): if not visited[i]: visited[i] = True output.append(number_list[i]) dfs(depth + 1, i) visited[i] = False output.pop() dfs(0, 0) ","permalink":"https://5hdumat.github.io/posts/algorithm/backtracking/15655/","summary":"문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다.  N개의 자연수 중에서 M개를 고른 수열 고른 수열은 오름차순이어야 한다.    풀이 number_list 변수를 리스트로 입력받아 오름차순 정렬을 해주었습니다.\n기존의 output.append(i) 구문을 output.append(number_list[i])로 변경하여 number_list 인자 값을 출력 리스트 output에 추가하였습니다.\nidx 변수를 추가하여 재귀 호출 시 idx 이하의 값은 입력받지 않도록 하였습니다.\n두 번째 문제풀이 이후 비슷한 패턴의 문제가 반복되는 것 같습니다.","title":"15655번: N과 M (6)"},{"content":"문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다.  N개의 자연수 중에서 M개를 고른 수열    풀이 number_list 변수를 리스트로 입력받아 오름차순 정렬을 해주었습니다.\n기존의 output.append(i) 구문을 output.append(number_list[i])로 변경하여 number_list 인자 값을 출력 리스트에 입력하여 손쉽게 해결할 수 있었습니다.\nn, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n output = [] def dfs(depth): if depth == m: print(*output) return for i in range(n): if not visited[i]: visited[i] = True output.append(number_list[i]) # 기존 output.append(i) dfs(depth + 1) visited[i] = False output.pop() dfs(0) ","permalink":"https://5hdumat.github.io/posts/algorithm/backtracking/15654/","summary":"문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다.  N개의 자연수 중에서 M개를 고른 수열    풀이 number_list 변수를 리스트로 입력받아 오름차순 정렬을 해주었습니다.\n기존의 output.append(i) 구문을 output.append(number_list[i])로 변경하여 number_list 인자 값을 출력 리스트에 입력하여 손쉽게 해결할 수 있었습니다.\nn, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n output = [] def dfs(depth): if depth == m: print(*output) return for i in range(n): if not visited[i]: visited[i] = True output.","title":"15654번: N과 M (5)"},{"content":"문제  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 같은 수를 여러 번 골라도 된다. 고른 수열은 비내림차순이어야 한다.  길이가 K인 수열 A가 A1 ≤ A2 ≤ \u0026hellip; ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.      풀이 방문 체크 리스트 visited 관련 문구를 제거한 후 idx 변수를 추가하여 재귀 호출 시 idx 이하의 값은 입력받지 않도록 하였습니다.\nn, m = map(int, input().split()) output = [] def dfs(depth, idx): if depth == m: return for i in range(idx, n): output.append(i + 1) dfs(depth + 1, i) output.pop() dfs(0, 0) ","permalink":"https://5hdumat.github.io/posts/algorithm/backtracking/15652/","summary":"문제  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 같은 수를 여러 번 골라도 된다. 고른 수열은 비내림차순이어야 한다.  길이가 K인 수열 A가 A1 ≤ A2 ≤ \u0026hellip; ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.      풀이 방문 체크 리스트 visited 관련 문구를 제거한 후 idx 변수를 추가하여 재귀 호출 시 idx 이하의 값은 입력받지 않도록 하였습니다.","title":"15652번: N과 M (4)"},{"content":"문제  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 같은 수를 여러 번 골라도 된다.    풀이 방문 체크 리스트 visited 관련 문구를 제거한 후 쉽게 해결할 수 있었습니다.\nn, m = map(int, input().split()) output = [] def dfs(depth): if depth == m: print(*output) return for i in range(n): output.append(i + 1) dfs(depth + 1) output.pop() dfs(0) ","permalink":"https://5hdumat.github.io/posts/algorithm/backtracking/15651/","summary":"문제  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 같은 수를 여러 번 골라도 된다.    풀이 방문 체크 리스트 visited 관련 문구를 제거한 후 쉽게 해결할 수 있었습니다.\nn, m = map(int, input().split()) output = [] def dfs(depth): if depth == m: print(*output) return for i in range(n): output.append(i + 1) dfs(depth + 1) output.","title":"15651번: N과 M (3)"},{"content":"문제  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 고른 수열은 오름차순이어야 한다.    이 문제의 핵심은 1부터 N까지의 자연수 중 오름차순이면서 중복 없이 M개를 나열한 수열을 출력하는 것 이었습니다.\n예제 출력 3에서 4 4를 입력받아 자연수를 1부터 4까지 오름차순으로 그리고 중복 없이 1 2 3 4가 출력 되고 있는 것을 확인하실 수 있습니다.\n풀이 N과 M (1)의 문제 풀이에 인자 idx를 추가하여 해결했습니다.\nidx의 의미는 반복문이 어디서부터 진행되고 있는지를 알려주는 위치값으로, 재귀 호출되는 함수에서 전달받은 idx 값부터 반복분이 진행되도록 합니다.\n즉, 전달받은 idx 값 이하로는 진행되지 않도록 하기 때문에 중복 없이 오름차순 수열을 출력시킬 수 있었습니다.\nn, m = map(int, input().split()) visited = [False] * n output = [] def dfs(depth, idx): if depth == m: print(*output) return for i in range(idx, n): if not visited[i]: visited[i] = True output.append(i+1) dfs(depth + 1, i + 1) visited[i] = False output.pop() dfs(0, 0) 알게된 점 from itertools import combinations n, m = map(int, input().split()) for i in combinations(range(1, n + 1), m): print(*i) 외장 함수 combinations를 이용해 손쉽게 수열을 출력할 수 있었습니다.\n","permalink":"https://5hdumat.github.io/posts/algorithm/backtracking/15650/","summary":"문제  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 고른 수열은 오름차순이어야 한다.    이 문제의 핵심은 1부터 N까지의 자연수 중 오름차순이면서 중복 없이 M개를 나열한 수열을 출력하는 것 이었습니다.\n예제 출력 3에서 4 4를 입력받아 자연수를 1부터 4까지 오름차순으로 그리고 중복 없이 1 2 3 4가 출력 되고 있는 것을 확인하실 수 있습니다.","title":"15650번: N과 M (2)"},{"content":"문제  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열    사전 지식 DFS, 백트래킹에 대한 개념 이해가 필요한 문제였습니다.\nDFS (깊이 우선 탐색) 완전 탐색을 기본으로 하는 그래프 탐색 알고리즘 중 하나로 모든 노드를 방문하는 것을 목표로 합니다.\n시작 노드부터 하나의 방향을 잡아 끝까지 탐색한 후 분기점으로 돌아가 다시 다른 방향으로 끝까지 탐색하는 변태 같은 기법입니다.\n보통 노드의 깊이를 예측하고자 할 때 사용합니다.\n그림과 같이 DFS는 모든 노드를 방문하는 것을 목표로 하기 때문에 목표지점이 있지 않은 경로까지 탐색하면서 비효율적인 자원을 소모합니다.\n이러한 문제점을 해소함과 동시에 제약 조건에 맞는 해답을 찾기 위해선 DFS와 백트래킹을 혼용해서 사용합니다.\n백트래킹 (퇴각 검색) 백트래킹이란 해을 찾는 과정에서 조건에 부합하지 않은 후보 해가 나타날 경우 이전 단계로 돌아가 다른 후보 해를 찾는 퇴각 검색 기법 입니다.\nDFS의 비효율적인 경로를 차단하고 가능성이 있는 루트를 검사하는 방법(가지치기, Pruning)으로 검색 효율을 극대화합니다.\nDFS과 백트래킹에 대한 개념을 간략하게 잡아보았습니다.\n풀이 n, m = map(int, input().split()) number_list = [1 + i for i in range(n)] output = [] def dfs(): if len(output) == m: print(*output) return for i in number_list: if not i in output: output.append(i) dfs() output.pop() dfs() 재귀 호출 속에서 또 재귀 호출이 이루어지다 보니 이해하기가 쉽지 않았습니다.\n(재귀 호출로 노드를 탐색 한 후 탈출하는 과정에서 pop() 함수가 연속으로 호출된다던가)\n중간 중간 print()을 하나 하나 출력해보면서 미로 찾기 하는 느낌으로 이해했던 것 같습니다.\n보완할 점 number_list = [i + 1 for i in range(n)] 위와 같이 n의 크기만큼 배열을 만들어 풀었더니 순차 탐색으로 인한 시간 복잡도가 O(n) = n와 같이 늘어나는 최악의 경우가 발생했습니다.\n시간 복잡도를 줄이고자 visited로 방문 리스트를 만들어 한번 방문했다고 판단되는 곳은 더 이상 방문하지 않도록 해 선형 탐색 알고리즘을 좀 더 효율적으로 수정하였습니다.\nn, m = map(int, input().split()) visited = [False] * n output = [] def dfs(depth): if depth == m: print(*output) return for i in range(n): if not visited[i]: visited[i] = True output.append(i + 1) dfs(depth + 1) visited[i] = False output.pop() dfs(0) 알게된 점 from itertools import permutations n, m = map(int, input().split()) for i in permutations(range(1, n + 1), m): print(*i) 외장 함수 permutations을 이용해 손쉽게 수열을 출력할 수 있었습니다.\n","permalink":"https://5hdumat.github.io/posts/algorithm/backtracking/15649/","summary":"문제  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열    사전 지식 DFS, 백트래킹에 대한 개념 이해가 필요한 문제였습니다.\nDFS (깊이 우선 탐색) 완전 탐색을 기본으로 하는 그래프 탐색 알고리즘 중 하나로 모든 노드를 방문하는 것을 목표로 합니다.\n시작 노드부터 하나의 방향을 잡아 끝까지 탐색한 후 분기점으로 돌아가 다시 다른 방향으로 끝까지 탐색하는 변태 같은 기법입니다.","title":"15649번: N과 M (1)"},{"content":"언어는 Python으로 하겠습니다. 근데 이제 알고리즘을 곁들인 Python을 선택한 이유 초보자도 쉽게 접근할 수 있는 언어, 수많은 자료구조 모듈, 짧은 코드길이와 가독성, 쉬운 문자열 핸들링, 신경 쓰지 않아도 되는 오버플로우는 Python의 대표적인 장점들 입니다.\n또한 대다수의 기업들이 코딩 인터뷰에서 Python을 지원하고 있습니다.\n코딩 테스트 플랫폼1 에서 언어별 타임아웃 설정이 C++, Java에 비해 굉장히 타이트하기 때문에 동일한 알고리즘임에도 파이썬으로는 풀리지 않는 (억울한) 일이 심심찮게 발생하고 있지만, 알고리즘 최적화에 좀 더 많은 고민이 필요하기 때문에 유연한 사고와 학습을 목표로 하는 저에겐 오히려 좋은 점으로 작용 한 것 같습니다.\nPython 시작하기 (Only Mac) Python을 설치하기에 앞서 Mac OS 패키지 관리 도구인 homebrew부터 설치합니다.\n homebrew 설치\n 하단의 Command를 복사하여 터미널에 붙여넣기 합니다.\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)  pyenv와 pyenv-virtualenv를 이용한 Python 개발 환경 구성\n 인터프리터 환경은 주기적인 업데이트가 이루어집니다.\n그럴때마다 새로운 버전의 개발 환경을 재설치하는 것은 매우 귀찮고 번거로울 것 입니다.\nPython을 버전별로 관리 할 수 있도록 Python Version Manager인 pyenv를 설치합니다.\nbrew update brew install pyenv  이어서 Python 프로젝트를 가상환경을 이용해 분리 운영 할 수 있도록 pyenv-virtualenv를 설치합니다.\n가상환경은 프로젝트 각각에 설치된 패키지들 사이의 충돌을 막아 주기 위해 필요합니다.\nbrew install pyenv-virtualenv  pyenv및 pyenv-virtualenv가 정상동작 할 수 있도록 셀 설정파일에 각 프로그램의 초기화 코드를 추가하여 환경변수를 설정합니다.\n현재 제가 사용하고 있는 Mac OS 버전은 Big Sur입니다.\nCatalina 이후 버전부터 기본 셸이 zsh로 변경되었기 때문에 ~/.zshrc 파일을 수정했습니다.\nvi ~/.zshrc export PATH=$HOME/.pyenv/bin:$PATH eval \u0026#34;$(pyenv init -)\u0026#34; eval \u0026#34;$(pyenv virtualenv-init -)\u0026#34;  설정을 저장합니다.\nsource ~/.zshrc #설정 저장 - zsh exec $SHELL #shell 재실행  버전에 맞게 Python을 설치합니다. 필자는 3.7.7 버전을 설치하기로 했습니다.\npyenv install 3.7.7  Mac OS 버전이 Big sur로 버전업 되면서 XCode 관련 업데이트가 있었는지 BUILD FAILED 에러가 발생했습니다.\n급한대로 하단 명령어를 실행하여 Python을 설치했습니다.\nCFLAGS=\u0026#34;-I$(brew --prefix openssl)/include -I$(brew --prefix bzip2)/include -I$(brew --prefix readline)/include -I$(xcrun --show-sdk-path)/usr/include\u0026#34; LDFLAGS=\u0026#34;-L$(brew --prefix openssl)/lib -L$(brew --prefix readline)/lib -L$(brew --prefix zlib)/lib -L$(brew --prefix bzip2)/lib\u0026#34; pyenv install --patch 3.7.7 \u0026lt; \u0026lt;(curl -sSL https://github.com/python/cpython/commit/8ea6353.patch\\?full_index\\=1)  가상환경 명령어를 상황에 맞게 실행합니다.\npython -V # 2.7.7 출력 pyenv virtualenv 3.7.7 workspace # 가상환경 생성 pyenv virtualenv \u0026lt;version\u0026gt; \u0026lt;virtualenv_name\u0026gt;  pyenv activate workspace python -V # 3.7.7 출력 pyenv deactivate # 가상환경 해제하기   해커랭크 (https://www.hackerrank.com)\n코딜리티 (https://www.codility.com)\n리모트인터뷰 (https://www.remoteinterview.io)\n프로그래머스(국내) (https://www.programmers.co.kr) 등이 있다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/python/python-%EC%9E%85%EB%AC%B8%ED%95%98%EA%B8%B0/","summary":"언어는 Python으로 하겠습니다. 근데 이제 알고리즘을 곁들인 Python을 선택한 이유 초보자도 쉽게 접근할 수 있는 언어, 수많은 자료구조 모듈, 짧은 코드길이와 가독성, 쉬운 문자열 핸들링, 신경 쓰지 않아도 되는 오버플로우는 Python의 대표적인 장점들 입니다.\n또한 대다수의 기업들이 코딩 인터뷰에서 Python을 지원하고 있습니다.\n코딩 테스트 플랫폼1 에서 언어별 타임아웃 설정이 C++, Java에 비해 굉장히 타이트하기 때문에 동일한 알고리즘임에도 파이썬으로는 풀리지 않는 (억울한) 일이 심심찮게 발생하고 있지만, 알고리즘 최적화에 좀 더 많은 고민이 필요하기 때문에 유연한 사고와 학습을 목표로 하는 저에겐 오히려 좋은 점으로 작용 한 것 같습니다.","title":"Python 입문하기"}]