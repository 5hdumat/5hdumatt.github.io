[{"content":"PORT ? PORT는 배가 도착하는 항구라는 뜻이다.\n포트는 마치 항구와 같다. 패킷이 목적지 IP까지 안전하게 도착하도록 도와준다.\n그게 어떤 애플리케이션이든 말이다.\n예를 들면 아래와 같다.\n한번에 둘 이상 연결해야 한다면? 우리는 PC에서 한 작업만 하지 않는다.\nZOOM회의를 하면서 몰래 게임을 켜놓고 웹 브라우저로 쇼핑을 한다고 가정해보자.\n가정대로라면 클라이언트가 여러개의 서버와 통신을 해야한다.\n요청한 모든 응답 패킷들이 클라이언트의 각자의 출발지 IP로 뒤죽박죽 전송될 것이다.\n(이건 클라이언트가 서버로 요청을 보낼때도 마찬가지다.)\n게임 패킷인지, 화상통화 패킷인지, 웹 브라우저의 패킷인지 IP 프로토콜만 가지고는 구분할 수 없다.\n사실 이전에 봤던 TCP/IP 패킷에 PORT 정보가 있다. 사실 TCP/IP 패킷에 출발지와 목적지의 PORT 정보가 포함되어 있어 프로세스를 구분할 수 있었다.\nIP는 목적지 서버를 찾는 것\nPORT는 목적지 서버 안에서 동작하는 프로세스를 구분하는 것이라고 이해하면 된다.\nIP는 아파트 PORT는 동,호수 IP는 아파트 PORT는 동, 호수이다.\nIP(아파트)뿐만 아니라 PORT(동, 호수)까지 열어서 연결하기 때문에\n같은 IP(아파트) 내에서 프로세스를 구분하여 패킷(택배)을 전송 할 수 있다.\n또한 PORT는 할당 범위가 정해져 있으므로 참고하자.\n 0 ~ 65535 할당 가능 0 ~ 1023: 잘 알려진 포트는 사용하지 않는 것이 좋다.  FTP - 20, 21 TELNET - 23 HTTP - 80 HTTPS - 443    ","permalink":"https://5hdumat.github.io/posts/network/port/","summary":"PORT ? PORT는 배가 도착하는 항구라는 뜻이다.\n포트는 마치 항구와 같다. 패킷이 목적지 IP까지 안전하게 도착하도록 도와준다.\n그게 어떤 애플리케이션이든 말이다.\n예를 들면 아래와 같다.\n한번에 둘 이상 연결해야 한다면? 우리는 PC에서 한 작업만 하지 않는다.\nZOOM회의를 하면서 몰래 게임을 켜놓고 웹 브라우저로 쇼핑을 한다고 가정해보자.\n가정대로라면 클라이언트가 여러개의 서버와 통신을 해야한다.\n요청한 모든 응답 패킷들이 클라이언트의 각자의 출발지 IP로 뒤죽박죽 전송될 것이다.\n(이건 클라이언트가 서버로 요청을 보낼때도 마찬가지다.)\n게임 패킷인지, 화상통화 패킷인지, 웹 브라우저의 패킷인지 IP 프로토콜만 가지고는 구분할 수 없다.","title":"PORT"},{"content":"TCP ? IP 프로토콜만으론 해결할 수 없는 문제점들이 있었다.\n 비연결성 (대상이 서비스 불능임에도 패킷 전송) 비신뢰성 패킷 전달 순서의 문제  이러한 문제점을 보완하고자 나온 프로토콜이 TCP, UDP 이다.\n하지만 우리는 인터넷 프로토콜 스택의 계층 구조를 먼저 살펴보아야 한다. 1\n인터넷 프로토콜 스택의 4계층을 단계별로 표현한 예제이다.\n위로갈수록 사용자와 가까운 작업을 아래로 갈수록 기계와 가까운 작업을 담당한다.\n각 계층에는 다양한 프로토콜이 있으며, TCP와 IP 프로토콜도 그중 하나이다.\n계층 구조를 살펴보자.\n 애플리케이션 계층 (Application Layer)\nHTTP, FTP, SMTP, TELNET 등  우리가 평소에도 사용하는 브라우저, 네트워크 게임, 메신저 등이 애플리케이션 계층에 놓여있다.\n이 계층은 애플리케이션에 따라 그에맞게 통신을 수행할 수 있도록 한다.\n  전송 계층 (Transport Layer)\nTCP, UDP  이번 포스트의 주인공이다.\n송신된 데이터를 수신측 애플리케이션에 확실히 전달하기 위한 프로토콜이다.\n  네트워크 계층 (Network Layer)\nIP  수신측 컴퓨터까지 데이터를 전달하기 위한 최소한의 규칙이다.\n하지만 전달된 데이터가 손상됐는지 또는 수신측이 잘 받았는지에는 관여하지 않는다.\n(비연결성, 비신뢰성, 패킷 전달 순서 문제)\n이 문제점은 바로 위 계층에 있는 TCP 프로토콜이 보완한다.\n  네트워크 인터페이스 계층 (Network Interface Layer)\n데이터 링크 계층과 물리계층을 합쳐 네트워크 인터페이스 계층이라고 지칭한다.  데이터 링크 계층은 네트워크 계층(Network Layer)과 물리 계층(Physical Layer) 간의 차이를 완전히 흡수하기 위한 프로토콜이며 대표적인 예로 이더넷(Ehernet)이 있다.\n물리 계층은 데이터를 신호로, 신호를 데이터로 변환하며 통신 매체에 의존하기 때문에 특정 프로토콜이 정해져 있지 않다.\n메신저로 Hello, world! 라는 메시지를 전송해보자 인터넷 프로토콜 스택의 4계층을 이해하기 쉽게 단순화하여 3계층으로 표현한 예제이다.\n내부적으로는 4계층으로 표현되고 있으니 헷갈려 하지 말자.\n메시지 데이터가 어떻게 전송되는지 정리하자면 아래와 같다.\n1. 채팅 프로그램에 Hello, world!를 입력한다. 2. 메시지는 Socket 라이브러리를 통해 전송 계층에 전달된다. 전송 계층에는 이 포스트의 주인공인 TCP / UDP 프로토콜이 있다.\n3. 전송 계층에 전달된 메시지(데이터 계층)에 TCP 정보가 추가된다. TCP 정보가 추가된 데이터는 다시 네트워크 계층에 전달된다.\n4. TCP 정보가 포함된 데이터를 전달받은 네트워크 계층에선 IP 정보가 또다시 추가된다. 이렇게 생성된 패킷을 IP 패킷(Packet)이라고 하며 형태는 아래와 같다. 2\n녹색으로 표시된 부분을 살펴보면 전송 제어, 순서, 검증 정보 등 여러 데이터가 추가되어있다.\n이 정보가 IP 프로토콜의 문제점을 보완해 줄 TCP 정보이다.\n이 때문에 신뢰할 수 있는 프로토콜 이라고도 하며, 전송 제어 프로토콜(Transmission Control Protocol) 이라고도 한다.\nTCP(Transmission Control Protocol)의 특징 TCP의 특징은 아래와 같다.\n 연결지향 - TCP 3 way handshake (가상연결)  TCP/IP 프로토콜로 통신하면 클라이언트 ➡ 서버, 서버 ➡ 클라이언트 양뱡향으로 탐색 과정을 거친다.\n이 탐색 과정을 TCP 3 way handshake 라고 한다.\n탐색이 끝나면 서버와 클라이언트가 논리적인 가상 연결 상태가 되며, 이는 물리적인 연결 상태는 아니다. 3\n즉, TCP는 클라이언트와 서버가 서로 연결됐다고 가정만 한 상태이다.\n 데이터 전달 보증  클라이언트가 데이터를 전송 하면 서버에서 데이터를 잘 받았다는 응답값을 전송한다.\n응답 값 전송 여부에 따라 메시지가 정상적으로 전달되지 않았을때에 대한 문제를 인지할 수 있게 된다.\n 순서 보장  서버에 전달된 패킷이 순서대로 도착하지 않았다면 서버는 문제가 된 패킷부터 재전송 요청한다.\n5. 마지막으로 IP 패킷은 물리적인 정보가 포함된 이더넷 프레임 정보가 추가되어 물리 계층으로 전달된다. UDP ? 사용자 데이터그램 프로토콜(User Datagram Protocol)이라고한다.\n 기능이 거의 X 연결지향 - TCP 3 way handshake (가상연결) X 데이터 전달 보증 X 순서 보장 X  이 프로토콜을 왜 쓰지? 라는 생각이 들 수도 있겠지만 UDP 프로토콜만의 장점이 있다.\nTCP 프로토콜은 TCP 3 Way Handshake로 인한 소요 시간, 신뢰성을 보장하기 위한 여러가지 검증 정보로 인한 데이터의 크기 등의 문제가 있다.\n무엇보다도 가장 중요한 점은 인터넷 통신은 90% 이상 TCP기반 이라는 점이다.\n이전에는 신뢰할 수 있는 데이터에만 사용했던 프로토콜이었지만, 이제는 동영상과 같은 실시간 스트리밍 서비스에서도 TCP를 사용하고 있기 때문이다.\n때문에 TCP 프로토콜을 수정한다는 것은 불가능에 가깝다.\n그렇다면 어떻게 TCP 프로토콜을 최적화 할 수 있을까? UDP 프로토콜의 기능은 IP 프로토콜에 PORT만 추가된 형태로 하얀 도화지와 같다.\n이러한 이유 때문에 전송 계층이 아닌 애플리케이션 계층에서 최적화가 가능하다.\n최근 HTTP3 스펙에서는 TCP 프로토콜을 최적화하고자 UDP 프로토콜을 채택하면서 급부상하고 있는 프로토콜이다.\n  인터넷 프로토콜 스택은 인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는 통신규약(프로토콜)의 모음이다. 인터넷 프로토콜 슈트 중 TCP와 IP가 가장 많이 쓰이기 때문에 TCP/IP 프로토콜 슈트라고도 불린다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 패킷은 소화물을 뜻하는 패키지(package)와 덩어리를 뜻하는 버킷(bucket)의 합성어이다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 물리적으로 연결된다는 표현은 과거 전화국에서 전화 포트를 뽑아 연결하고자 하는 곳에 다시 연결해 주는 것과 같이 전용 랜선이 보장되는 것이다. TCP는 클라이언트와 서버가 서로 연결됐다고 가정만 한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/network/tcp-udp/","summary":"TCP ? IP 프로토콜만으론 해결할 수 없는 문제점들이 있었다.\n 비연결성 (대상이 서비스 불능임에도 패킷 전송) 비신뢰성 패킷 전달 순서의 문제  이러한 문제점을 보완하고자 나온 프로토콜이 TCP, UDP 이다.\n하지만 우리는 인터넷 프로토콜 스택의 계층 구조를 먼저 살펴보아야 한다. 1\n인터넷 프로토콜 스택의 4계층을 단계별로 표현한 예제이다.\n위로갈수록 사용자와 가까운 작업을 아래로 갈수록 기계와 가까운 작업을 담당한다.\n각 계층에는 다양한 프로토콜이 있으며, TCP와 IP 프로토콜도 그중 하나이다.\n계층 구조를 살펴보자.","title":"TCP / UDP"},{"content":"인터넷상에서 컴퓨터 들은 어떻게 통신할까? 클라이언트와 서버가 책상에 나란히 놓여있다고 가정해보자.\n그리고 클라이언트는 서버에게 Hello, world! 라는 메시지를 보내고자 한다.\n물리적으로 가까운 거리의 PC는 서로 연결된 케이블로 간단히 통신이 가능하다. 1\n이처럼 비교적 좁은 공간에 있는 기기끼리 연결한 네트워크를 우리는 LAN (Local Area Netwrok) 이라고 한다. 2\n하지만 메시지를 보내고자하는 서버가 지구 반대편에 있다면 어떻게 해야 할까?\n우리는 여러 개의 LAN이나 WAN을 연결한 전 세계 규모의 네트워크인 인터넷을 이용해야한다. 3\n인터넷 망은 단순하지 않다.\n인터넷은 서버와 서버의 연결이다. 이러한 네트워크 환경속에서 데이터는 수많은 서버를 거치게 된다.\n그렇다면 메시지가 목적지 서버까지 안전하게 전송될 수 있는 이유는 무엇일까?\n우리는 여기서 IP(인터넷 프로토콜) 이 무엇인지 짚고 넘어가야 한다.\nIP(인터넷 프로토콜) 복잡한 인터넷 망에서 데이터를 통신하기 위한 최소한의 규칙을 IP(인터넷 프로토콜) 이라 한다.\nIP(인터넷 프로토콜)을 이용한 통신 순서 1. 클라이언트와 서버에 IP 주소를 부여한다.\n2. IP 패킷을 만든다.\n출발지, 목적지 IP 정보와 함께 Hello, world! 라는 전송 데이터를 감싼다.\n택배에 출발지와 배송지 주소를 적는 것과 같다.\n3. 인터넷 망을 통해 IP 패킷을 전송한다.\n인터넷 망의 노드(서버)들은 모두 IP 프로토콜을 이해할 수 있도록 일련의 규약을 따르고있다.\n중간 노드들은 목적지가 어디있는지 서로 물어가면서 최적의 경로로 패킷을 전달하려고 할 것이다.\n4. 응답을 받은 서버는 동일한 방식으로 클라이언트에게 패킷을 전달한다.\n인터넷 망은 굉장히 복잡한 매커니즘을 따르고 있어 요청할 때와 응답할 때 거치는 노드가 다를 수 있다.\nIP(인터넷 프로토콜)의 한계 단순히 IP 주소를 부여하고 패킷을 전달하는 방식으로는 한계가 있다.\n어떤 한계점이 있을까?\n비연결성 아직까지 우리는 200.200.200.2 라는 서버가 켜져있는지 꺼져있는지 알 수 없다.\n패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷을 전송하는 건 낭비이다.\n비신뢰성 인터넷이라는건 용빼는 재주가 있는게 아니다.\n결국 패킷은 여러 서버를 거쳐 목적지로 전달된다.\n즉, 특정 노드에 문제가 생길 수 있다는 것이고, 패킷이 유실될 수 있다는 의미이다.\n패킷 전달 순서 문제 한번에 전송할 수 있는 메시지의 MTU(최대 전송 단위)는 1500 Byte 이다.\n메시지 패킷의 용량을 3000 Byte 라고 가정한다면 1500 Byte 단위 로 패킷이 나누어진다.\n클라이언트는 나누어진 패킷을 Hello, 와 World! 순으로 전달하게 될 것이다.\n문제는 여기서 발생한다.\n인터넷 망은 굉장히 복잡한 매커니즘을 따르고 있으므로 패킷들이 항상 동일한 노드를 거치지는 않는다.\n즉, 패킷의 요청 순서와 다르게 목적지 서버에 전달될 수 있다는 의미이다.\n마무리 위에 열거한 비연결성, 비신뢰성, 패킷 전달 순서 문제는 IP 프로토콜만으론 해결할 수 없다.\n다음 포스트에서 IP 프로토콜의 문제점을 보완하고자 나온 TCP, UDP 프로토콜을 다루고자 한다.\n  접속에는 주로 가는 구리선을 짜넣은 LAN 케이블을 사용한다. 케이블을 사용하지 않고 전파나 적외선 등을 사용하여 연결한 것을 \u0026lsquo;무선 LAN\u0026rsquo; 이라고 한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 반대로 지리적으로 멀리 떨어진 장소에 있는 기기를 광섬유 케이블이나 공중망(전화 회선) 등을 사용하여 연결한 것을 WAN(Wide Area Network) 이라고 한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 워크스테이션 수준의 고사양 개인용 컴퓨터가 널리 보급되고, LAN과 WAN으로 인터넷이라는 국제적인 통신망이 연결되기 시작했다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/network/internet-protocol/","summary":"인터넷상에서 컴퓨터 들은 어떻게 통신할까? 클라이언트와 서버가 책상에 나란히 놓여있다고 가정해보자.\n그리고 클라이언트는 서버에게 Hello, world! 라는 메시지를 보내고자 한다.\n물리적으로 가까운 거리의 PC는 서로 연결된 케이블로 간단히 통신이 가능하다. 1\n이처럼 비교적 좁은 공간에 있는 기기끼리 연결한 네트워크를 우리는 LAN (Local Area Netwrok) 이라고 한다. 2\n하지만 메시지를 보내고자하는 서버가 지구 반대편에 있다면 어떻게 해야 할까?\n우리는 여러 개의 LAN이나 WAN을 연결한 전 세계 규모의 네트워크인 인터넷을 이용해야한다. 3","title":"IP (인터넷 프로토콜)"},{"content":"시간 복잡도는 왜 필요할까? 알고리즘은 어떤 문제를 해결하기 위한 일련의 과정 입니다.\n알고리즘 문제를 풀다보면 시간초과로 인해 시간복잡도를 생각해야 하는 경우가 자주 생기게되는데 동일한 문제해결 목표를 가진 알고리즘이 존재할 때 가장 시간복잡도가 가장 낮은 알고리즘을 사용 해야 시간초과 오류를 면할 수 있습니다.\n아무리 복잡한 알고리즘이라도 입력의 크기가 작으면 단시간에 끝나버리기 때문에 입력값의 크기가 충분히 클 때 그 효율성이 적나라하게 나타납니다.\n이러한 점근적 실행 시간1을 표기할 때 가장 널리쓰이는 수학적 표기법이 빅오 (big-O)입니다.\n빅오 표기법의 종류는 크게 다음과 같습니다.\nO(1) 상수 시간을 갖는 알고리즘으로 입력값 n이 주어졌을 때, 알고리즘이 문제를 해결하는데 오직 한 단계만 거칩니다. 즉, 입력값이 아무리 커도 실행 시간은 일정합니다.\n최고의 알고리즘이지만 상수값이 무한대로 커진다면 사실상 일정한 시간의 의미는 없어집니다.\nprint(\u0026#34;hello, world!\u0026#34;) a = [1, 2, 3, 4, 5] print(a[2]) # 3 위와 같이 입력값의 길이와 상관없이 데이터를 추출하는데 소요시간에 변함이 없어야합니다.\nPython 함수 및 메소드의 시간 복잡도를 정리해둔 사이트가 있으니 참고합니다.\nComplexity of Python Operations\nO(log n) 실행 시간이 입력값에 영향을 받지만 특정 조건에 따라 입력값 탐색시간이 줄어듭니다.\n아래 예제를 보시면 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어드는 것을 확인하실 수 있습니다.\na = [1, 2, 3, 4, 5, 6, 7, 8, 9] for i in range(0, len(a), 3): print(a[i]) # 1, 4, 7 O(n) 입력값만큼 실행 시간이 영향을 받으며, 알고리즘을 수행하기 위한 단계의 수와 시간이 입력값과 1:1 관계를 가집니다.\n이를 선형 시간(Linear-Time) 알고리즘이라 합니다.\na = [1, 2, 3] for n in a: print(n) # 1 2 3 O(n log n) 병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘이 이에 해당합니다.\n병합 정렬은 주어진 리스트를 하나의 해가 될 때까지 재귀적으로 나누고 다시 작은 수 부터 정렬하여 병합합니다.\n시간 복잡도는 최악의 경우 O(nlogn)으로 나누면서 log n의 시간이 소요되고, 병합하면서 n의 시간이 소요됩니다.\ninput() 데이터를 입력 받습니다.\n# O(N log N) unsorted_list = [int(x) for x in input().split()] merge_sort() n / 2로 나눠 1개의 요소가 남을때까지 재귀호출 합니다.\n# n / 2로 나눠 1개의 요소가 남을때까지 재귀호출 합니다. # 그 다음 2개씩의 요소들을 반복적으로 병합합니다. def merge_sort(unsorted_list): # if 구문을 통해 정렬되지 않은 리스트의 데이터가 1개 이하면 그대로 반환합니다. if len(unsorted_list) \u0026lt;= 1: return unsorted_list mid = len(unsorted_list) // 2 left = unsorted_list[:mid] right = unsorted_list[mid:] left1 = merge_sort(left) ## 재귀를 이용하여 왼쪽 리스트를 다시 나눕니다. right1 = merge_sort(right) ## 오른쪽도 마찬가지로 다시 나눕니다. return merge(left1, right1) merge_sort(unsorted_list)  merge() left와 right 리스트의 0번자리 부터 비교 후 작은 값을 sorted_list에 삽입합니다.\n비교가 끝난 후 남은 값을 sorted_list에 삽입합니다.\ndef merge(left, right): i = 0 j = 0 sorted_list = [] # 둘중 하나가 만족할때까지 append while i \u0026lt; len(left) and j \u0026lt; len(right): if left[i] \u0026lt; right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # 남은 값들을 넣어준다  while i \u0026lt; len(left): sorted_list.append(left[i]) i += 1 while j \u0026lt; len(right): sorted_list.append(right[j]) j += 1 return sorted_list # 리스트 예시 # merge_sort() 8 7 6 5 4 3 2 1 [8765] [4321] [87] [65] [43] [21] [8] [7] [6] [5] [4] [3] [2] [1] # merge()  [8] [7] [6] [5] [4] [3] [2] [1] [78] [56] [34] [12] [5678] [1234] 1 2 3 4 5 6 7 8 O(n²) 버블 정렬과 같은 비효율적인 정렬 알고리즘이 이에 해당합니다.\n이중 loop로 진행되는 알고리즘 이기때문에 시간 복잡도는 O(n²) 입니다.\ndef bubble_sort(l): swap = True while swap: swap = False for i in range(len(l)-1): if l[i] \u0026gt; l[i+1]: l[i], l[i+1] = l[i+1], l[i] swap = True lst = [8, 5, 3, 1, 4, 7, 9] bubble_sort(lst) O(n!) 브루트 포스로 알고리즘 문제를 풀이할 때가 이에 해당합니다.\nn=100만 되어도 n!은 9.332622e+157 입니다.\nfrom math import factorial print(factorial(100)) #933262154439441526816992388562667004907159682643816214685929638952175999932299156089414639761565182862536979208272237582511852109168640000000000000000000000000  마무리 빅오는 시간 복잡도 외에도 공간 복잡도를 표현하는 데에도 널리 쓰입니다.\n알고리즘은 시간과 공간이 트레이드오프 관계입니다. 실행 시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 사용하는 알고리즘은 실행 시간을 많이 사용합니다.\n이처럼 대부분의 경우 시간과 공간은 트레이드오프 관계이며, 이는 알고리즘의 주요한 특징 중 하나입니다.\n  시간 복잡도라고도 하며, 입력값이 무한대를 향할 때 함수 실행 시간 추이를 의미합니다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/datastructure/%EB%B9%85%EC%98%A4/","summary":"시간 복잡도는 왜 필요할까? 알고리즘은 어떤 문제를 해결하기 위한 일련의 과정 입니다.\n알고리즘 문제를 풀다보면 시간초과로 인해 시간복잡도를 생각해야 하는 경우가 자주 생기게되는데 동일한 문제해결 목표를 가진 알고리즘이 존재할 때 가장 시간복잡도가 가장 낮은 알고리즘을 사용 해야 시간초과 오류를 면할 수 있습니다.\n아무리 복잡한 알고리즘이라도 입력의 크기가 작으면 단시간에 끝나버리기 때문에 입력값의 크기가 충분히 클 때 그 효율성이 적나라하게 나타납니다.\n이러한 점근적 실행 시간1을 표기할 때 가장 널리쓰이는 수학적 표기법이 빅오 (big-O)입니다.","title":"빅오 (big-O)"},{"content":"Python 문법 인덴트 (Indent) Python의 공식 가이드 PEP 8에 따라 공백 4칸을 원칙으로 합니다.\n강제는 아니며 얼마든지 선택적으로 적용할 수는 있으나, Python 답게 이 기준을 준수하기로 합니다.\n 네이밍 컨벤션 (Naming Convention) Python의 네이밍 컨벤션은 자바와 달리 각 단어를 밑줄로 구분하는 Snake Case를 따릅니다.\n함수와 변수명 모두 Snake Case를 지향하고 있으며, Python의 철학에 따라 스네이크 코딩 스타일을 지향하도록 합니다.\ncamelCase: int = 1 # Camel Case snake_case: int = 1 # Snake Case  타입 힌트 (Type Hint) Python은 동적 타이핑 언어임에도 타입을 지정할 수 있는 타입 힌트를 지원합니다. (Python 버전 3.5 이상)\n변수 타입 지정 예시 a: str = \u0026#34;1\u0026#34; b: int = 1  타입 힌트를 사용하지 않으면 아래 예시처럼 a에는 숫자를 넘겨야하는지 문자를 넘겨야하는지 알 수 없습니다.\n이는 프로젝트 규모가 커지게 될 경우 좋지않은 가독성과 버그를 유발합니다.\n타입 힌트를 사용하지 않은 함수 예시 def fn(a):  그렇다면 어떻게 해야 타입 힌트를 사용하여 코드를 작관적으로 바꿀 수 있을까요?\n아래와 같이 파리미터가 정수형이면서 리턴값이 boolean값임을 알 수 있도록 타입 힌트를 사용하도록 합니다.\n타입 힌트를 사용한 함수 예시 def fn(a: int) -\u0026gt; bool:  강제 규약은 아니다보니 타입이 달라도 동적 할당이 될 수 있으므로 위와 같이 문자열에 정수를 할당하는 등의 사용 방식은 절대적으로 지양해야합니다.\n잘못된 동적 할당 예시 a: str = 1  추가적으로, mypy를 설치하여 타입 힌트에 오류가 없는지 자동으로 확인할 수 있습니다.\n$ pip install mypy  리스트 컴프리헨션 (List Comprehenshion) Python은 map, filter와 같은 함수형 기능을 지원하며 다음과 같은 람다 표현식도 지원합니다.\n람다 표현식 예시 list(map(lambda x: x+ 10, [1, 2, 3])) # [11, 12, 13]  람다 표현식도 굉장히 좋은 기능이지만 훨씬 더 유용한 기능은 리스트 컴프리헨션입니다.\n기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문으로 홀수인 경우 2를 곱해 출력하도록 하는 리스트 컴프리헨션 예시를 보시겠습니다.\n리스트 컴프리헨션 예시 [n * 2 for n in rnage(1, 11) if n % 2 = 1] # [2, 6, 10, 14, 18]  리스트 컴프리헨션을 사용하지 않는다면 다음과 같이 길게 풀어서 작성해야 합니다.\n리스트 컴프리헨션을 사용하지 않았을 때 예시 a = [] for n in range(1, 11): if n % 2 == 1: a.append(n * 2)  풀어서 작성한 코드는 리스트 컴프리헨션을 사용한 것에 비해 훨씬 더 길어졌고, a라는 별도의 리스트 변수 또한 필요해졌습니다.\n리스트 컴프리헨션과 비교했을 때 라인 수가 많이 증가한 것을 확인하실 수 있습니다.\n또한, 리스트 컴프리헨션이라고 해서 리스트만 지원하는 것은 아닙니다.\n딕셔너리 컴프리헨션을 사용한 예시 # 리스트 컴프리헨션 미사용 a = {} for key, value in original.items(): a[key] = value # 리스트 컴프리헨션 사용 a = {key, value for key, value in original.items()}  이처럼 딕셔너리도 컴프리헨션이 가능합니다. (파이썬 버전 2.7 이상)\n무리하게 사용할 경우 가독성을 떨어뜨릴 수 있으므로 적절히 사용하는 게 중요합니다.\n 제너레이터 (Generaotr) 제너레이터는 루프의 반복동작을 제어할 수 있는 루틴 형태를 의미합니다.\n예를들어 임의의 조건으로 숫자 1억 개를 만들어내 계산하는 프로그램을 작성한다고 가정해봅니다.\n이 경우 제너레이터가 없다면 메모리 어딘가에 만들어낸 숫자 1억 개를 보관하고 있어야하는 소모가 발생합니다.\nyield 구문을 사용하여 제너레이터를 리턴할 수 있는데, 기존의 함수는 return 구문을 맞닥뜨리면 값을 리턴하고 모든 함수의 동작을 종료했습니다.\n그러나 yield는 제너레이터가 실행 중이던 값을 내보낸다는 의미로, 중간값을 리턴한 다음 함수는 종료되지 않고 계속해서 맨 끝에 도달할 때까지 실행됩니다.\n제너레이터 사용 예시 def get_natural_number(): n = 0 while True: n += 1 yield n  제너레이터를 이용하여 100개의 값을 생성하고자 한다면 다음과 같이 100번의 next()를 수행하도록 합니다.\nnext() 사용 예시 g = get_natural_number() for _ in range(0, 100): prnit(next(g))  제너레이터는 여러 타입의 값을 하나의 함수에서 생성하는 것도 가능합니다.\n여러 타입의 값 생성 예시 def generator(): yield 1 yield \u0026#39;string\u0026#39; yield True g = generaotr() print(next(g)) # 1 print(next(g)) # \u0026#39;string\u0026#39; print(next(g)) # True  range 제니레이터의 방식을 활용하는 대표적인 함수로 range()가 존재합니다.\n주로 for 문에서 쓰이는 range() 함수의 쓰임은 다음과 같습니다.\nlist(range(5)) # [0, 1, 2, 3, 4] for i in range(5): print(i) # 0 1 2 3 4   range() 를 사용하는 이유는 메모리 효율때문입니다. 생성 조건만 정해두고 필요할 때 생성해서 꺼내 쓸 수 있기 때문입니다.\n예를들어 100만 개의 숫자를 생성해야한다면 어떻게 될까요? 메모리에서 적지 않은 공간을 차지할 것이고 생성 시간도 오래 걸릴 것입니다.\nrange 사용 예시 a = [n for n in range(1000000)] b = range(100000)  위 코드를 다음과 같이 len()으로 길이 비교를 해보면 둘 다 동일한 100만 개가 출력되며, 비교연산자에서도 True를 리턴합니다.\nrange 비교 예시 len(a) # 1000000 len(b) # 1000000 len(a) == len(b) # True  하지만 둘 사이의 메모리 점유율을 비교해보면 range 클래스를 곧바로 리턴하는 방식이 훨씬 더 적은것을 확인 할 수 있습니다\n메모리 점유율 비교 예시 sys.getsizeof(a) # 8697464 sys.getsizeof(b) # 48  range 클래스를 이용하면 값이 1억 개라도 b 변수의 메모리 점유율은 동일합니다/\n생성 조건만 보관하고 있기 때문입니다.\n게다가 인덱스로 접근 시에는 곧바로 생성하도록 구현되어 있기 때문에 다음과 같이 리스트와 거의 동일한 느낌으로 불편 없이 사용할 수 있습니다.\n인덱스 참조 예시 b[999] # 999  enumerate enumerate()는 \u0026lsquo;열거하다\u0026rsquo;는 뜻의 함수입니다.\n아래와 같이 여러가지 자료형(list, set, tuple 등)을 인덱스를 포함한 enumerate 객체로 리턴합니다.\nenumerate 사용 예시 a = [1, 2, 3, 2, 45, 2, 5] list(enumerate(a)) # [(0, 1), (1, 2), (2, 3), (3, 2), (4, 45), (5, 2), (6, 5)] a = ['a1', 'b2', 'c3']를 key, value형태로 출력하기 위해 enumerate 함수를 활용할 수 있습니다.\nenumerate 활용 예시 a = [\u0026#39;a1\u0026#39;, \u0026#39;b2\u0026#39;, \u0026#39;c3\u0026#39;] for key, value in enumerate(a): print(key, value)  print 코딩 테스트 문제 풀이 과정에서 디버깅을 할 때 가장 많이 쓰이는 명령어는 바로 print() 입니다.\n이를 좀 더 유용하게 활용할 수 있는 방법 몇 가지를 살펴봅니다.\n1) 콤마(,)로 구분하면 띄어쓰기 구분자로 값을 구분하여 출력합니다. print(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;) # A B 2) 콤마(,)를 구분자로 지정하려면 seq를 사용합니다. print(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, seq=\u0026#39;,\u0026#39;) # A,B 3) print()는 항상 줄바꿈을 합니다. 줄바꿈을 하지 않도록 제한 하려면 end를 사용합니다. print(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, end=\u0026#39; \u0026#39;) print(\u0026#39;C\u0026#39;) # A B C 4) 리스트를 한 줄에 출력하고자 할 때는 join()을 사용합니다. a = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;] \u0026#39; \u0026#39;.join(a) # A B 5) 인덱스를 활용하여 변수에 값을 더해 출력 가능합니다. idx = 1 fruit = \u0026#34;Apple\u0026#34; print(\u0026#39;{0}: {1}\u0026#39;.format(idx + 1, fruit)) # 인덱스 생략 가능: print(\u0026#34;{}: {}\u0026#34;.format(idx + 1, fruit)) # 2: Apple 6) f-string(formated string literal)을 사용하면 별도로 변수를 부여할 필요 없이 사용 가능합니다. 템플릿을 사용하듯 인라인으로 삽입할 수 있어 편리하고, .format을 부여하는 방식에 비해 훨씬 간결하고 직관적입니다.\nidx = 1 fruit = \u0026#34;Apple\u0026#34; print(f\u0026#39;{idx +1}: {fruit}\u0026#39;)  locals locals()는 로컬 스코프에 선언된 모든 변수를 조회할 수 있는 명령어입니다.\n코딩 테스트 플랫폼 문제 풀이 중에도 코디 내부에 출력해 활용할 수 있습니다.\nlocals() 호출 예시 import pprint pprint.pprint(locals())  pprint로 출력하게 되면 보기 좋게 줄바끔 처리를 해주기 때문에 가독성높은 출력문 확인이 가능합니다.\n Python의 특징 루프 (Loop) 1부터 10까지의 합을 구하는 간단한 루프 구조 예시입니다.\n예시 1 sum = 0 for i in range(1, 11): sum += i 예시 2 sum = 0 sum = sum(i for i in range(1, 11)) 예시 3 sum = sum(range(1, 11))  생산적인 언어답게 One-Liner로 처리가 가능합니다.\n한 줄 처리의 경우 깔끔하고 생산적입니다만, 지나친 사용은 가독성을 떨어트릴 수 있으므로 적절하게 사용합니다.\n제네릭 (Generic) 1 제네릭이란 클래스 내부에서 사용 할 파라미터의 타입을 외부에서 지정되게 하는 기법입니다.\n즉, 인스턴스를 생성할 때 데이터 타입을 지정하여 객체의 재활용성을 높일 수 있는 프로그래밍 스타일입니다.\ndef are_equal(a, b): return a == b are_equal(10, 10.0)  예시 코드 실행 시 따로 파라미터에 타입을 지정해주지 않았음에도 코드가 정상동작 합니다.\nPython은 동적 타이핑 언어로 제네릭이 필요하지 않기 때문입니다.\n하지만 타입을 명시해주지 않으면 가독성이 떨어지고, 버그 발생 확률이 높아진다는 단점이 있습니다.\n하여 Python 3.5 이상 버전부터 제네릭을 사용 할 수 있게 되어 다음과 같이 타입을 명시할 수 있게 되었습니다.\nfrom typing import List, TypeVar T = TypeVar(\u0026#39;T\u0026#39;, int, str, List[int]) # T는 int, str, List[int] Type 일 수 있습니다. def are_equal(a: T, b: T) -\u0026gt; T: return a + b print(are_equal(1, 3)) # [int, int] -\u0026gt; int print(are_equal(\u0026#39;item\u0026#39;, \u0026#39;4\u0026#39;)) # [str, str] -\u0026gt; str print(are_equal([10], [10.0])) # [List[int], List[int]] -\u0026gt; List[int] print(are_equal(\u0026#39;item\u0026#39;, 4)) # Err 배열 반복 foo = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] for f in foo: print(f)  다른 언어에 비해 자료형이라는 선언이 필요 없는 Python 코드는 매우 간결합니다.\n클래스 from dataclasses import dataclass @dataclass class Rectangle: weight: int price: int def area(self): return self.weight * self.price rect = Rectangle(3, 4) print(rect.area())  Python 3.7부터 dataclass를 지원합니다.\n@dataclass 데코레이션으로 타입 힌트와 함께 활용하여 다음과 같이 class를 정의 할 수 있습니다.\ndataclass를 선언하지 않아도 클래스 구현에는 문제가 없으나 선언하게 되면 여러 가지 내부 함수 기능을 자동으로 구현해주기 때문에 활용하는게 좋습니다.\n  제네릭 프로그래밍(영어: generic programming)은 데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있는 기술에 중점을 두어 재사용성을 높일 수 있는 프로그래밍 방식이다. (위키백과)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/python/python-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/","summary":"Python 문법 인덴트 (Indent) Python의 공식 가이드 PEP 8에 따라 공백 4칸을 원칙으로 합니다.\n강제는 아니며 얼마든지 선택적으로 적용할 수는 있으나, Python 답게 이 기준을 준수하기로 합니다.\n 네이밍 컨벤션 (Naming Convention) Python의 네이밍 컨벤션은 자바와 달리 각 단어를 밑줄로 구분하는 Snake Case를 따릅니다.\n함수와 변수명 모두 Snake Case를 지향하고 있으며, Python의 철학에 따라 스네이크 코딩 스타일을 지향하도록 합니다.\ncamelCase: int = 1 # Camel Case snake_case: int = 1 # Snake Case  타입 힌트 (Type Hint) Python은 동적 타이핑 언어임에도 타입을 지정할 수 있는 타입 힌트를 지원합니다.","title":"Python 살펴보기"},{"content":"언어는 Python으로 하겠습니다. 근데 이제 알고리즘을 곁들인 Python을 선택한 이유 대다수의 코딩 인터뷰에서 Python 지원, 초보자도 쉽게 접근할 수 있는 언어, 수많은 자료구조 모듈, 짧은 코드 길이와 가독성, 쉬운 문자열 핸들링, 임의 정밀도 정수형으로 신경 쓰지 않아도 되는 오버플로는 Python의 대표적인 장점들이다.\n코딩 테스트 플랫폼1 에서 언어별 타임아웃 설정이 C++, Java에 비해 굉장히 타이트하기 때문에 동일한 알고리즘임에도 파이썬으로는 풀리지 않는 (억울한) 일이 심심찮게 발생하고 있지만!\n알고리즘 최적화에 좀 더 많은 고민이 필요하기 때문에 유연한 사고와 학습을 목표로 하는 나에겐 오히려 좋은 점으로 작용하게 될 것 같다.\nPython 시작하기 (Only Mac) Python을 설치하기에 앞서 Mac OS 패키지 관리 도구인 homebrew부터 설치한다.\n homebrew 설치\n 하단의 Command를 터미널에서 실행시킨다.\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)  pyenv와 pyenv-virtualenv를 이용한 Python 개발 환경 구성\n 인터프리터 환경은 주기적인 업데이트가 이루어진다.\n업데이트가 이루어질때마다 새로운 버전의 개발 환경을 재설치하는 것은 매우 귀찮고 번거로운 일 일것이다.\nPython을 버전별로 관리 할 수 있도록 Python Version Manager인 pyenv를 설치하도록 하자.\nbrew update brew install pyenv  이어서 가상환경을 이용해 Python 프로젝트를 분리 운영 할 수 있도록 pyenv-virtualenv를 설치한다.\n프로젝트 마다 설치된 패키지 사이의 충돌을 막아 주기 위함이다.\nbrew install pyenv-virtualenv  pyenv및 pyenv-virtualenv가 정상동작 할 수 있도록 셀 설정파일에 각 프로그램의 초기화 코드를 추가하여 환경변수를 설정한다.\nCatalina 이후 버전부터 기본 셸이 zsh로 변경되었기 때문에 ~/.zshrc 파일을 수정했다.\necho $SHELL 명령어를 사용해 간단히 사용중인 쉘이 무엇인지 간단히 확일 할 수 있으니 참고하자.\nvi ~/.zshrc export PATH=$HOME/.pyenv/bin:$PATH eval \u0026#34;$(pyenv init -)\u0026#34; eval \u0026#34;$(pyenv virtualenv-init -)\u0026#34;  변경사항을 반영한다\n source ~/.zshrc #설정 저장 - zsh exec $SHELL #shell 재실행  Python을 버전에 맞게 설치한다.\n필자는 3.7.7 버전을 설치했다.\npyenv install 3.7.7  Mac OS 가 Big sur로 버전업 되면서 XCode 관련 업데이트가 있었는지 BUILD FAILED 에러가 발생했다.\n급한대로 하단 명령어를 실행하여 Python을 설치했다.\nCFLAGS=\u0026#34;-I$(brew --prefix openssl)/include -I$(brew --prefix bzip2)/include -I$(brew --prefix readline)/include -I$(xcrun --show-sdk-path)/usr/include\u0026#34; LDFLAGS=\u0026#34;-L$(brew --prefix openssl)/lib -L$(brew --prefix readline)/lib -L$(brew --prefix zlib)/lib -L$(brew --prefix bzip2)/lib\u0026#34; pyenv install --patch 3.7.7 \u0026lt; \u0026lt;(curl -sSL https://github.com/python/cpython/commit/8ea6353.patch\\?full_index\\=1)  가상환경 명령어를 상황에 맞게 실행한다.\npython -V # 2.7.7 출력 pyenv virtualenv 3.7.7 workspace # 가상환경 생성 pyenv virtualenv \u0026lt;version\u0026gt; \u0026lt;virtualenv_name\u0026gt;  pyenv activate workspace python -V # 3.7.7 출력 pyenv deactivate # 가상환경 해제하기   해커랭크 (https://www.hackerrank.com)\n코딜리티 (https://www.codility.com)\n리모트인터뷰 (https://www.remoteinterview.io)\n프로그래머스(국내) (https://www.programmers.co.kr) 등이 있다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/python/python-%EC%9E%85%EB%AC%B8%ED%95%98%EA%B8%B0/","summary":"언어는 Python으로 하겠습니다. 근데 이제 알고리즘을 곁들인 Python을 선택한 이유 대다수의 코딩 인터뷰에서 Python 지원, 초보자도 쉽게 접근할 수 있는 언어, 수많은 자료구조 모듈, 짧은 코드 길이와 가독성, 쉬운 문자열 핸들링, 임의 정밀도 정수형으로 신경 쓰지 않아도 되는 오버플로는 Python의 대표적인 장점들이다.\n코딩 테스트 플랫폼1 에서 언어별 타임아웃 설정이 C++, Java에 비해 굉장히 타이트하기 때문에 동일한 알고리즘임에도 파이썬으로는 풀리지 않는 (억울한) 일이 심심찮게 발생하고 있지만!\n알고리즘 최적화에 좀 더 많은 고민이 필요하기 때문에 유연한 사고와 학습을 목표로 하는 나에겐 오히려 좋은 점으로 작용하게 될 것 같다.","title":"Python 입문하기"}]