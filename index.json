[{"content":"HTTP 주요 메서드 종류 HTTP 메서드는 클라이언트가 서버에 요청을 할 때 서버로부터 기대하는 행동이다.\n주로 많이 사용하는 HTTP 메서드는 아래와 같다.\nGET GET은 이름 그대로 리소스를 조회하기 위한 메서드이다.\n서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달한다.\nGET 메서드도 메시지 바디를 통해 데이터를 전달할 수 있지만, 지원하지 않는 서버들이 많아 권장하지 않는다.\n리소스 조회 과정을 살펴보자.\n  리소스 조회 예제\n   GET 메서드와 함께 /members/100 경로(path)의 리소스를 서버에 요청한다.\n    메시지를 전달받은 서버는 DBMS에서 요청받은 조건의 데이터를 조회한다.    특정 형태(예제는 JSON)의 데이터로 파싱 후 응답 메시지를 만들어 클라이언트에 전달한다.\n    클라이언트는 서버로부터 메시지를 전달받는다.    사용자가 보는 화면에 렌더링된다.      POST POST는 클라이언트에서 서버로 요청을 보낼 때 서버로부터 요청 데이터를 처리해달라는 의미이다.\n서버는 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.\n(주로 신규 리소스 등록, 프로세스 처리 등에 사용된다.)\n여기서 주의할 점은 서버와 클라이언트는 서로 요청/응답에 대한 약속이 되어있어야 한다는 것이다.\n신규 리소스 등록 처리 과정을 살펴보자.\n  신규 리소스 등록 예제\n   클라이언트는 POST 방식으로 서버의 /members 경로에 메시지 바디를 전달한다.\n(예제는 신규 리소스 등록에 대한 약속이 되어있음을 전제로 한다.)\n    POST 방식으로 데이터를 전달받은 서버는 100번이라는 신규 리소스 식별자를 생성한다.\n    서버는 생성된 신규 리소스에 대한 정보를 클라이언트에 전송한다.\n   응답 메시지에 포함된 데이터  응답 상태(201 created, 200도 무관)  201 상태값일 경우 보통 Location이라는 자원 생성 경로를 포함한다.   등록된 리소스 데이터        POST에서 요청 데이터를 어떻게 처리한다는 뜻일까? 사실 POST는 의미가 굉장히 많다.\nPOST가 실제로 어떻게 사용되고 있는지 예시를 살펴보자.\n HTML 양식에 입력된 데이터를 서버측 데이터 처리 프로세스에 제공  HTML FORM에 입력한 정보로 회원 가입, 주문 등의 행위를 할 때 사용   게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시  게시판 글쓰기, 댓글 달기 등   서버가 아직 실별하지 않은 새 리소스 생성  신규 주문 생성   기존 자원에 데이터 추가  문서 내용 수정 및 추가    이 예시의 핵심은 (위 예제의 /members와 같은) 리소스 URI에 POST 요청을 전달받은 서버가\n요청 데이터를 어떻게 처리할지 리소스마다 스스로 정해야 한다.\n즉, POST 리소스 처리 방식에 대한 정해진 방법은 없다.\nPOST 정리  새 리소스 생성(등록)  서버가 아직 식별하지 않는 새 리소스 생성   요청 데이터 처리 (굉장히 중요한 부분이다.)  단순히 데이터를 생성하거나, 변경하는 것을 넘어 프로세스를 처리해야 하는 경우에도 사용된다.  예) 주문 -\u0026gt; 결제완료 -\u0026gt; 배달시작 -\u0026gt; 배달완료\n단순히 값 변경을 넘어 프로세스 상태가 지속적으로 변경되는 단계에서도 POST가 쓰인다.   POST의 결과로 새로운 리소스가 생성되지 않을 수도 있다.  예) POST /orders/{orderId}/start-delivery  이전 포스트에서 URI 설계는 분명 리소스를 기준으로 해야한다고 했지만 실무에선 리소스만으로 모든 URI를 설계할 순 없다.\n리소스 만으로 설계된 URI는 굉장히 이상적인 케이스이다.\n예제의 /start-delivery와 같이 어떤 행위(동사)를 포함하는 URI를 컨트롤 URI라고 한다.       다른 메서드로 처리하기 애매한 경우  예) JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우  이런 경우 조회이지만 메시지 바디에 조회용 데이터를 포함하여 POST로 요청해야한다.      POST는 마치 만능인 것 같다.\n하지만 우리는 조회할 땐 GET을 사용해야 한다고 배웠다.\n그 이유는 GET은 조회 데이터가 캐싱되기 때문이다. POST는 캐싱이 어렵다.\nPOST 데이터 조회는 정말 어쩔 수 없을때만 사용하자.\n","permalink":"https://5hdumat.github.io/posts/network/http-method/","summary":"HTTP 주요 메서드 종류 HTTP 메서드는 클라이언트가 서버에 요청을 할 때 서버로부터 기대하는 행동이다.\n주로 많이 사용하는 HTTP 메서드는 아래와 같다.\nGET GET은 이름 그대로 리소스를 조회하기 위한 메서드이다.\n서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달한다.\nGET 메서드도 메시지 바디를 통해 데이터를 전달할 수 있지만, 지원하지 않는 서버들이 많아 권장하지 않는다.\n리소스 조회 과정을 살펴보자.\n  리소스 조회 예제\n   GET 메서드와 함께 /members/100 경로(path)의 리소스를 서버에 요청한다.","title":"HTTP 메서드"},{"content":"API URI 고민 회원 정보 관리 API를 요구사항대로 만든다고 가정해보자.\n요구사항  회원 목록 조회 회원 조회 회원 등록 회원 수정 회원 삭제  URI 설계가 끝난 후 경로가 나왔다.\n 회원 목록 조회 /read-member-list 회원 조회 /read-member-by-id 회원 등록 /create-member 회원 수정 /update-member 회원 삭제 /delete-member  뭔가 그럴듯하다. 실제 현업에서도 위와 같은 설계가 많이 이루어진다.\n하지만 이것은 좋은 URI 설계일까?\n우리는 위와 같이 설계된 URI가 좋은 설계인지에 대해서는 다시한번 고민해 봐야 한다.\n결론부터 말하자면 위와 같은 URI 설계는 좋지 않은 설계이다.\nURI 설계의 기준은 어떤 행위가 아닌 리소스를 기준으로 이루어져야 하기 때문이다.\n리소스가 의미하는게 뭘까? 위 예제처럼 회원을 등록하고 수정하고 조회하는건 리소스가 아니다.\n스타크래프트로 예를 들면 미네랄을 캐는 행위가 아닌 미네랄이 리소스인 것이다.\n즉, 회원이라는 개념 자체가 리소스다.\n리소스를 어떻게 식별하는게 좋을까? 식별하는 방법은 아래와 같다.\n1. 회원을 등록하고 수정하고 조회하는 것을 모두 배제한다.\n2. 회원이라는 리소스만 식별한다.\n3. 회원 리소스를 URI에 매핑한다. -\u0026gt; URI는 리소스만 식별\n위 내용을 토대로 URI를 다시 설계한것을 살펴보자.\n 회원 목록 조회 /members 회원 조회 /members/{id} 회원 등록 /members/{id} 회원 수정 /members/{id} 회원 삭제 /members/{id}\n참고: URI는 계층 구조상 상위를 컬렉션으로 보고 복수단어 사용 권장 (member -\u0026gt; members)  URI는 계층형 구조로 설계해야 하므로 /members 밑에 회원의 id를 넣었다.\n하지만 여기서 또 문제가 발생한다.\n 회원 목록 조회 /members 회원 조회 /members/{id} -\u0026gt; 어떻게 구분하지? 회원 등록 /members/{id} -\u0026gt; 어떻게 구분하지? 회원 수정 /members/{id} -\u0026gt; 어떻게 구분하지? 회원 삭제 /members/{id} -\u0026gt; 어떻게 구분하지?  회원의 조회, 등록, 수정, 삭제와 같은 행위는 구분이 안된다.\n리소스(회원)와 리소스를 대상으로 하는 행위(조회, 등록, 삭제, 변경)는 분리했지만 행위(메서드)는 구분하지 않았기 때문이다.\n이 문제를 해결하기 위한게 HTTP 메서드이다.\n다음 포스트에서 알아보자.\n","permalink":"https://5hdumat.github.io/posts/network/http-api/","summary":"API URI 고민 회원 정보 관리 API를 요구사항대로 만든다고 가정해보자.\n요구사항  회원 목록 조회 회원 조회 회원 등록 회원 수정 회원 삭제  URI 설계가 끝난 후 경로가 나왔다.\n 회원 목록 조회 /read-member-list 회원 조회 /read-member-by-id 회원 등록 /create-member 회원 수정 /update-member 회원 삭제 /delete-member  뭔가 그럴듯하다. 실제 현업에서도 위와 같은 설계가 많이 이루어진다.\n하지만 이것은 좋은 URI 설계일까?\n우리는 위와 같이 설계된 URI가 좋은 설계인지에 대해서는 다시한번 고민해 봐야 한다.","title":"HTTP API 설계"},{"content":"지금은 HTTP 시대! HTTP HyperText Transfer Protocol\nHTTP는 문서간의 링크를 통해 연결할 수 있는 HTML을 전송하기 위한 프로토콜로 시작되었다.1\n하지만 현재는 아래와 같이 거의 모든 데이터를 HTTP 프로토콜에 담아 전송한다.\n HTML, TEXT IMAGE, 음성, 영상, 파일 JSON, XML (API) 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용  즉, 현재는 바야흐로 HTTP의 시대이다.\nHTTP의 역사  HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X HTTP/1.0 1996년: 메서드, 헤더 추가 HTTP/1.1 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전 RFC2068 (1997) -\u0026gt; RFC2616 (1999) -\u0026gt; RFC7230~7235 (2014) HTTP/2 2015년: 성능 개선 HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선  HTTP 특징 HTTP의 특징 크게 4가지로 나눠보자면 아래와 같다.\n 클라이언트 서버 구조 무상태 프로토콜(Stateless) 비연결성 HTTP 메시지  하나씩 차례대로 알아보자.\n1. 클라이언트 서버 구조 HTTP의 첫번째 중요한 특징은 클라이언트/서버 구조(CS) 로 되어있다는 점이다.\n위 예제를 해석하자면 아래와 같다.\n Request Response 구조 클라이언트는 서버에 요청을 보내고 응답 대기 서버는 요청에 대한 결과를 만들어서 응답  표면적으로는 굉장히 단순하지만 근간은 그렇지 않다.\n클라이언트와 서버를 개념적으로 분리하면서 양쪽이 독립적으로 진화할 수 있다는 점은 단순한 일이 아니다.\n이 개념이 적용되면서 비즈니스, 데이터 로직은 서버가 UI(화면)/UX(사용성)와 같은 화면구조는 클라이언트가 담당하게 되었다.\n이제 우리는 트래픽이 폭주해도 서버 아키텍쳐와 백엔드 기술을 얼마나 더 고도화하고 진화시킬수 있는지에 대해서만 고민하면 된다.\n2. 무상태 프로토콜(Statelesss) HTTP는 서버가 클라이언트의 상태를 보존하지 않는다.\n이 말을 이해하려면 우리는 상태 유지(Stateful)와 무상태성(Stateless)의 차이를 알아봐야 한다.\n  상태 유지 - Stateful 고객: 이 노트북 얼마인가요?\n점원: 100만원 입니다.\n 고객: 2개 구매하겠습니다.\n점원: 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매하시겠어요?\n 고객: 신용카드로 구매하겠습니다.\n점원: 200만원 결제 완료되었습니다.\n  너무나 일상적인 대화다. 하지만 예제를 조금 바꿔 점원이 여러명이라고 가정해보자.\n  상태 유지 - Stateful, 점원이 중간에 바뀌면? 고객: 이 노트북 얼마인가요?\n점원A: 100만원 입니다.\n 고객: 2개 구매하겠습니다.\n점원B: ?\n 고객: 신용카드로 구매하겠습니다.\n점원C: ?\n  무언가 이상하다. 고객의 요청은 점원이 바뀜에 따라 문맥이 유지되지 않는다.\n문맥이 유지되지 않는다는건 무슨 의미일까?\n  상태 유지 - Stateful, 정리 고객: 이 노트북 얼마인가요?\n점원: 100만원 입니다. (노트북 상태 유지)\n 고객: 2개 구매하겠습니다.\n점원: 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매하시겠어요 (노트북, 2개 상태 유지)\n 고객: 신용카드로 구매하겠습니다.\n점원: 200만원 결제 완료되었습니다. (노트북, 2개, 신용카드 상태 유지)\n  위 예제처럼 점원이 클라이언트의 요청을 기억하고 기억하고 문맥을 유지는 의미이다.\n문맥을 유지하고 있던 점원이 바뀌게 된다는 건 통신의 관점에선 장애가 발생한다는것과 다름이 없다.\n그럼 무상태성(Stateless)은 뭐가 다른 걸까? 이제 무상태성(Stateless)은 상태 유지(Stateful)와 어떻게 다른지 알아보자.\n무상태 - Stateless 고객: 이 노트북 얼마인가요?\n점원: 100만원 입니다.\n 고객: 노트북 2개 구매하겠습니다.\n점원: 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매하시겠어요?\n 고객: 노트북 2개를 신용카드로 구매하겠습니다.\n점원: 200만원 결제 완료되었습니다ㄴ.\n  위 예제는 점원이 바뀌더라도 고객의 마지막 말로 모든 행위를 판단할 수 있다.\n무상태성(Stateless) 은 말 그대로 점원이 고객의 상태를 유지하지 않아야 하기 때문이다.\n상태 유지와 무상태의 차이가 느껴지는가?\n상태 유지(Stateful), 무상태(Stateless) 차이  상태유지(Stateful)  중간에 다른 점원으로 바뀌면 안된다.\n(중간에 다른 점원으로 바뀔 때 상태 정보를 다른 점원에게 미리 알려줘야 한다.)    그 이유는 아래와 같다.\n예제처럼 서버1은 클라이언트A의 요청 정보를 지속적으로 유지하고 있어야한다.\n상태 유지의 문제점은 여기서 나타난다.\n서버1이 클라이언트A의 정보를 유지하고 있다보니서버1에 장애가 발생하면\n클라이언트A는 다른 서버에 요청을 처음부터 다시 시도해야한다.\n무상태(Stateless)는 어떤 차이점이 있을까?\n 무상태(Stateless)  갑자기 고객이 증가해도 점원을 대거 투입할 수 있다. 무상태는 응답 서버를 쉽게 바꿀 수 있다.  무한한 서버 증설 가능      무상태은 클라이언트A가 애초에 필요한 데이터를 모두 담아서 서버에 요청한다.\n서버는 클라이언트A의 요청에 따라 응답만 하면된다.\n중간에 서버가 장애나면?\n중계서버가 다른 서버에 요청을 똑같이 요청하면된다.\n클라이언트A의 요청에 필요한 데이터가 모두 담겨있기 때문이다.\n이 방식은 큰 장점이 있는데 수평 확장이 유리하다는 점이다.\n무상태성으로 설계가 되어있으면 트래픽이 많이 발생해도 동일한 장비를 추가 증설하여 트래픽을 감당할 수 있다.\n하지만 무상태(Stateless)도 실무 한계가 있다.\n무상태(Stateless) 실무 한계  모든 것을 무상태로 설계 할 수 있는 건 아니다.  무상태  로그인인이 필요 없는 단순한 서비스 소개 화면   상태 유지  브라우저 쿠키와 세션 상태를 유지해야하는 로그인     상태 유지가 필요한 로그인의 경우 무상태성 적용 불가 무상태를 유지하기 위해 클라이언트가 전송해야 할 데이터가 많아진다. 상태 유지는 최소한만 사용  비연결성(Connectionless) TCP/IP 연결의 경우 기본적으로 연결을 유지한다.\n예를들어 클라이언트가 여러개라고 가정해보자.\n서버는 모든 클라이언트의 요청에 따라 TCP/IP 소켓을 연결하고 유지한다.\n이 방식의 단점은 특정 클라이언트가 놀고있어도 서버는 연결 상태를 유지해야하다보니 서버 자원 소모가 많다는 점이다.\n(클라이언트가 수만개라고 가정한다면 서버는 \u0026hellip;)\n연결을 유지하지 않는 모델은?\n이 방식은 TCP/IP 소켓 연결 후 요청을 하고 응답을 받고 볼일을 끝낸 서버는 연결을 종료한다.\n서버 입장에선 연결을 유지할 필요가 없어지므로 최소한의 자원을 유지할 수 있다.\n비 연결성  HTTP는 기본이 연결을 유지하지 않는 모델 일반적으로 초 단위 이하의 빠른 속도로 응답 1시간 동안 수천명이 서비스를 해도 실제 서버에서 동시 처리하는 요청은 수십개 이하로 매우 작음  웹 브라우저에서 연속적으로 검색 버튼을 누르진 않는다.   서버 자원의 가용성을 훨씬 높힐수 있음  비 연결성 방식의 한계와 극복  TCP/IP 연결을 매번 새로 맺어야함 - 3 Way Handshake로 인한 시간 낭비 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 js, image, css 등 수많은 자원을 다운로드한다.  현재는 HTTP 지속 연결(Persistent Comnnections, Keep alive)로 문제 해결    - HTTP 초기 연결\n필요한 정보가 생길때마다 연결을 새로한다. 시간도 오래걸리고 낭비도 심하다.\n- HTTP 지속 연결(Persistent Connections)\n기본적으로 HTTP 지속 연결은 연결을 한 후 요청을 보내고 응답을 받는다.\n그 다음 연결을 유지한 상태에서 필요한 자원을 응답받는다.\n(내부 매커니즘에 따라 다르지만 보통 HTML 문서가 완전히 다운로드될 때까지 연결을 지속한다.)\n무상태(Stateless)를 기억하자 명절 KTX 예약이나 학과 수업 등록, 선착순 쿠폰 이벤트를 예로 들어보자.\n같은 시간에 수만개의 동시 요청을 서버는 감당해야 할 것이다.\n요청이 동시에 몰리기 때문에 최대한 Stateless하게 설계하는게 중요하다.\n(위에서도 언급했지만 무상태는 스케일 아웃이 유리하기 때문에 많은 트래픽이 발생해도 대응하기가 쉽다.)\n번외로 이벤트 참여 전에 로그인도 필요없는 정적인 페이지를 하나 뿌려주고 클라이언트가 어느정도 머물렀다 참여하도록 유도하는 방법도 있다고 한다.\n  하이퍼텍스트(Hypertext)는 참조(하이퍼링크)를 통해 독자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트이다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/network/http/","summary":"지금은 HTTP 시대! HTTP HyperText Transfer Protocol\nHTTP는 문서간의 링크를 통해 연결할 수 있는 HTML을 전송하기 위한 프로토콜로 시작되었다.1\n하지만 현재는 아래와 같이 거의 모든 데이터를 HTTP 프로토콜에 담아 전송한다.\n HTML, TEXT IMAGE, 음성, 영상, 파일 JSON, XML (API) 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용  즉, 현재는 바야흐로 HTTP의 시대이다.\nHTTP의 역사  HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X HTTP/1.0 1996년: 메서드, 헤더 추가 HTTP/1.1 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전 RFC2068 (1997) -\u0026gt; RFC2616 (1999) -\u0026gt; RFC7230~7235 (2014) HTTP/2 2015년: 성능 개선 HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선  HTTP 특징 HTTP의 특징 크게 4가지로 나눠보자면 아래와 같다.","title":"HTTP"},{"content":"웹 브라우저 요청 흐름 위 예제와 같이 구글링 할 경우 브라우저 요청의 흐름을 알아보자.\n  1. 클라이언트는 구글 서버를 찾아야 하므로 DNS 서버를 조회하여 IP와 PORT 정보를 찾아낸다.\n  2. HTTP 요청 메시지를 생성한다. 요청 메시지의 간략한 생김새는 아래와 같다.\n GET /search?q=hello\u0026amp;hl=ko HTTP/1.1\nHOST: www.google.com    3. 생성한 HTTP 요청 메시지는 SOCKET 라이브러리를 통해 TCP/IP 계층에 전달한다.\n 이 과정에서 3 Way Handshake를 통해 구글서버와 가상연결 한다.    4. TCP/IP 계층에서 HTTP 메시지를 IP, PORT 정보와 함께 TCP/IP 패킷으로 캡슐화한다.\n 위 요청의 흐름을 그림으로 표현하면 아래와 같다.     5. 만들어진 TCP/IP 패킷을 인터넷 망을 통해 구글 서버로 전송한다.   6. 구글 서버는 전달 받은 TCP/IP 패킷을 반대로 해석한다.  구글 서버는 해석한 메시지를 읽어들여 검색엔진을 통해 데이터를 찾고 응답 메시지를 만들어낸다.\n위 예제와 같이 응답 패킷에 여러 정보를 담아 클라이언트에 똑같이 메시지를 전송한다.\n 7. 웹 브라우저는 구글서버로 부터 전달받은 HTTP 메시지를 해석하고 렌더링 한 후 사용자에게 보여준다.  ","permalink":"https://5hdumat.github.io/posts/network/web-browser-request/","summary":"웹 브라우저 요청 흐름 위 예제와 같이 구글링 할 경우 브라우저 요청의 흐름을 알아보자.\n  1. 클라이언트는 구글 서버를 찾아야 하므로 DNS 서버를 조회하여 IP와 PORT 정보를 찾아낸다.\n  2. HTTP 요청 메시지를 생성한다. 요청 메시지의 간략한 생김새는 아래와 같다.\n GET /search?q=hello\u0026amp;hl=ko HTTP/1.1\nHOST: www.google.com    3. 생성한 HTTP 요청 메시지는 SOCKET 라이브러리를 통해 TCP/IP 계층에 전달한다.\n 이 과정에서 3 Way Handshake를 통해 구글서버와 가상연결 한다.","title":"웹 브라우저 요청 흐름"},{"content":"URI(Uniform Resource Identifier) URI는 리소스를 식별하는 통합된 방법이라는 의미이다.\n사람을 식별할 때는 주민등록번호를 이용하는 것 처럼 리소스가 어디있는지 식별하는 방법을 URI라고 한다.\n Uniform: 리소스 식별하는 통일된 방식 Resource: 리소스, URI로 식별할 수 있는 모든 자원 (제한 X)\n즉, URI로 식별할 수 있는 모든 정보를 리소스라고 한다. Identifier: 다른 항복과 구분하는 데 필요한 정보\n예) 사람을 식별할 때 사용하는 주민등록번호가 사람의 Identifier가 된다.  \u0026ldquo;URI는 로케이터(locator), 이름(name) 또는 둘다 추가로 분류될 수 있다.\u0026rdquo; URI안에는 URL과 URN 방식이 포함되어 있다.\nURL? URN?  URL(Resource Locator)  우리가 일반적으로 웹 브라우저에서 사용하는 방식 리소스가 있는 위치를 지정하여 검색   URN(Resource Name)  리소스에 이름을 부여\n예) urn:isbn:1234567과 같이 검색하여 특정 서적의 ISBN 정보를 표시 URN은 이름마다 리소스가 매핑되어 있어야 하기 떄문에 실제 리소스를 찾을 수 있는 방법이 보편화 되어있지 않다. 그냥 URN 이란것도 있구나 정도로 인지만하고 넘어가자    URL 분석 scheme scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n 스키마는 주로 프로토콜 사용 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙\nhttp, https, ftp 등 http는 80 포트, https는 443 포트를 주로 사용\n포트는 생략 가능한데 생략시 http는 80 https는 443 포트가 자동 기입된다. https는 http에 강력한 보안 추가 (HTTP Secure)\n현재는 대부분의 웹사이트들이 https로 동작  userinfo scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n URL에 사용자정보를 포함해서 인증 거의 사용하지 않는다.  host scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n 호스트명 이전 포스트에서 배웠던 도메인명 또는 IP 주소를 직접 사용가능  port scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n 포트(PORT) 일반적으로 생갹, 생략시 http는 80, https는 443  path scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n 리소스가 있는 경로(path) 계층적 구조로 설계  /home/file1.jpg /members /members/100 /items/iphone12\npath만 봐도 어떤 행위를 하는지 알 수 있다.    query scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n key=value 형태 ?로 시작, \u0026amp;로 파라미터를 이어 붙일 수 있다.\n?keyA=valueA\u0026amp;keyB=valueB query parameter, query string 등으로 불린다.\n(웹서버에 제공하는 파라미터, 문자 형태)  fragment scheme://[userinfo@]host[:port][/path][?query][#fragment]\nhttps://www.google.com:443/search?q=hello\u0026amp;hl=ko\n html 내부 북마크 등에 사용 서버에 전송하는 정보는 아니다.  ","permalink":"https://5hdumat.github.io/posts/network/uri/","summary":"URI(Uniform Resource Identifier) URI는 리소스를 식별하는 통합된 방법이라는 의미이다.\n사람을 식별할 때는 주민등록번호를 이용하는 것 처럼 리소스가 어디있는지 식별하는 방법을 URI라고 한다.\n Uniform: 리소스 식별하는 통일된 방식 Resource: 리소스, URI로 식별할 수 있는 모든 자원 (제한 X)\n즉, URI로 식별할 수 있는 모든 정보를 리소스라고 한다. Identifier: 다른 항복과 구분하는 데 필요한 정보\n예) 사람을 식별할 때 사용하는 주민등록번호가 사람의 Identifier가 된다.  \u0026ldquo;URI는 로케이터(locator), 이름(name) 또는 둘다 추가로 분류될 수 있다.","title":"URI"},{"content":"DNS? DNS는 무엇이고 왜 사용하는 걸까?\n그 이유는 위 예제처럼 IP는 기억하기 어렵다는 점이고\n또 다른 이유는 IP는 언제든지 변경될 수 있다는 점이다.\n예를 들어 200.200.200.2로 기억해두었던 IP가 200.200.200.3으로 변경되었을 때\n기존 IP는 당연히 접근 불가능하게 된다.\n이를 해결하려면 도메인 네임 시스템(DNS, Domain Name System) 을 이용해야 한다.\nDNS의 특징 DNS는 등록한 도메인 명을 IP 주소로 변환해 준다.\n쉽게말해 중간에서 전화번호부 서버같은 서비스를 제공해 준다고 이해하면 된다.\n기철이한테 전화를 걸면 기철이의 핸드폰번호로 전화가 걸리는 것 처럼 말이다.\n예제를 통하여 더 자세하게 살펴보자.\n1. DNS 서버에 구매한 도메인을 IP와 매핑하여 등록한다. google.com -\u0026gt; 200.200.200.2\naaa.com -\u0026gt; 210.210.210.3\n도메인 명과 IP를 매핑하여 등록\n2. 클라이언트는 도메인으로 DNS 서버에 IP를 요청한다. 3. DNS 서버는 IP 주소를 전달한다. 4. 클라이언트는 전달받은 IP 서버에 접속한다. 이제 더 이상 IP를 기억할 필요도 IP 변경을 신경 쓸 필요도 없어진다.\n","permalink":"https://5hdumat.github.io/posts/network/dns/","summary":"DNS? DNS는 무엇이고 왜 사용하는 걸까?\n그 이유는 위 예제처럼 IP는 기억하기 어렵다는 점이고\n또 다른 이유는 IP는 언제든지 변경될 수 있다는 점이다.\n예를 들어 200.200.200.2로 기억해두었던 IP가 200.200.200.3으로 변경되었을 때\n기존 IP는 당연히 접근 불가능하게 된다.\n이를 해결하려면 도메인 네임 시스템(DNS, Domain Name System) 을 이용해야 한다.\nDNS의 특징 DNS는 등록한 도메인 명을 IP 주소로 변환해 준다.\n쉽게말해 중간에서 전화번호부 서버같은 서비스를 제공해 준다고 이해하면 된다.\n기철이한테 전화를 걸면 기철이의 핸드폰번호로 전화가 걸리는 것 처럼 말이다.","title":"DNS"},{"content":"PORT ? PORT는 배가 도착하는 항구라는 뜻이다.\n포트는 마치 항구와 같다. 패킷이 목적지 IP까지 안전하게 도착하도록 도와준다.\n그게 어떤 애플리케이션이든 말이다.\n예를 들면 아래와 같다.\n한번에 둘 이상 연결해야 한다면? 우리는 PC에서 한 작업만 하지 않는다.\nZOOM회의를 하면서 몰래 게임을 켜놓고 웹 브라우저로 쇼핑을 한다고 가정해보자.\n가정대로라면 클라이언트는 여러개의 서버와 통신 해야한다.\n위와 같은 상황에선 서버의 응답 패킷들이 클라이언트에 뒤죽박죽 도착할 것이다.\n(이건 클라이언트가 서버로 요청을 보낼때도 마찬가지다.)\n게임 패킷인지, 화상통화 패킷인지, 웹 브라우저의 패킷인지 IP 프로토콜만 가지고는 구분할 수 없다.\n사실 이전에 봤던 TCP/IP 패킷에 PORT 정보가 있다. 사실 TCP/IP 패킷에 출발지와 목적지의 PORT 정보가 포함되어 있어 프로세스를 구분할 수 있었다.\nIP는 목적지 서버를 찾는 것\nPORT는 목적지 서버 안에서 동작하는 프로세스를 구분하는 것이라고 이해하면 된다.\nIP는 아파트 PORT는 동,호수 IP는 아파트 PORT는 동, 호수이다.\nIP(아파트)뿐만 아니라 PORT(동, 호수)까지 열어서 연결하기 때문에\n같은 IP(아파트) 내에서 프로세스를 구분하여 패킷(택배)을 전송 할 수 있다.\n또한 PORT는 할당 범위가 정해져 있으므로 참고하자.\n 0 ~ 65535 할당 가능 0 ~ 1023: 잘 알려진 포트는 사용하지 않는 것이 좋다.  FTP - 20, 21 TELNET - 23 HTTP - 80 HTTPS - 443    ","permalink":"https://5hdumat.github.io/posts/network/port/","summary":"PORT ? PORT는 배가 도착하는 항구라는 뜻이다.\n포트는 마치 항구와 같다. 패킷이 목적지 IP까지 안전하게 도착하도록 도와준다.\n그게 어떤 애플리케이션이든 말이다.\n예를 들면 아래와 같다.\n한번에 둘 이상 연결해야 한다면? 우리는 PC에서 한 작업만 하지 않는다.\nZOOM회의를 하면서 몰래 게임을 켜놓고 웹 브라우저로 쇼핑을 한다고 가정해보자.\n가정대로라면 클라이언트는 여러개의 서버와 통신 해야한다.\n위와 같은 상황에선 서버의 응답 패킷들이 클라이언트에 뒤죽박죽 도착할 것이다.\n(이건 클라이언트가 서버로 요청을 보낼때도 마찬가지다.)\n게임 패킷인지, 화상통화 패킷인지, 웹 브라우저의 패킷인지 IP 프로토콜만 가지고는 구분할 수 없다.","title":"PORT"},{"content":"TCP? IP 프로토콜만으론 해결할 수 없는 문제점들이 있었다.\n 비연결성 (대상이 서비스 불능임에도 패킷 전송) 비신뢰성 패킷 전달 순서의 문제  이러한 문제점을 보완하고자 나온 프로토콜이 TCP, UDP 이다.\n하지만 우리는 인터넷 프로토콜 스택의 계층 구조를 먼저 살펴보아야 한다. 1\n인터넷 프로토콜 스택의 4계층을 단계별로 표현한 예제이다.\n위로갈수록 사용자와 가까운 작업을 아래로 갈수록 기계와 가까운 작업을 담당한다.\n각 계층에는 다양한 프로토콜이 있으며, TCP와 IP 프로토콜도 그중 하나이다.\n계층 구조를 살펴보자.\n 애플리케이션 계층 (Application Layer)\nHTTP, FTP, SMTP, TELNET 등  우리가 평소에도 사용하는 브라우저, 네트워크 게임, 메신저 등이 애플리케이션 계층에 놓여있다.\n이 계층은 애플리케이션에 따라 그에맞게 통신을 수행할 수 있도록 한다.\n  전송 계층 (Transport Layer)\nTCP, UDP  이번 포스트의 주인공이다.\n송신된 데이터를 수신측 애플리케이션에 확실히 전달하기 위한 프로토콜이다.\n  네트워크 계층 (Network Layer)\nIP  수신측 컴퓨터까지 데이터를 전달하기 위한 최소한의 규칙이다.\n하지만 전달된 데이터가 손상됐는지 또는 수신측이 잘 받았는지에는 관여하지 않는다.\n(비연결성, 비신뢰성, 패킷 전달 순서 문제)\n이 문제점은 바로 위 계층에 있는 TCP 프로토콜이 보완한다.\n  네트워크 인터페이스 계층 (Network Interface Layer)\n데이터 링크 계층과 물리계층을 합쳐 네트워크 인터페이스 계층이라고 지칭한다.  데이터 링크 계층은 네트워크 계층(Network Layer)과 물리 계층(Physical Layer) 간의 차이를 완전히 흡수하기 위한 프로토콜이며 대표적인 예로 이더넷(Ehernet)이 있다.\n물리 계층은 데이터를 신호로, 신호를 데이터로 변환하며 통신 매체에 의존하기 때문에 특정 프로토콜이 정해져 있지 않다.\n메신저로 Hello, world! 라는 메시지를 전송해보자 인터넷 프로토콜 스택의 4계층을 이해하기 쉽게 단순화하여 3계층으로 표현한 예제이다.\n내부적으로는 4계층으로 표현되고 있으니 헷갈려 하지 말자.\n메시지 데이터가 어떻게 전송되는지 정리하자면 아래와 같다.\n1. 채팅 프로그램에 Hello, world!를 입력한다. 2. 메시지는 Socket 라이브러리를 통해 전송 계층에 전달된다. 전송 계층에는 이 포스트의 주인공인 TCP / UDP 프로토콜이 있다.\n3. 전송 계층에 전달된 메시지(데이터 계층)에 TCP 정보가 추가된다. TCP 정보가 추가된 데이터는 다시 네트워크 계층에 전달된다.\n4. TCP 정보가 포함된 데이터를 전달받은 네트워크 계층에선 IP 정보가 또다시 추가된다. 이렇게 생성된 패킷을 IP 패킷(Packet)이라고 하며 형태는 아래와 같다. 2\n녹색으로 표시된 부분을 살펴보면 전송 제어, 순서, 검증 정보 등 여러 데이터가 추가되어있다.\n이 정보가 IP 프로토콜의 문제점을 보완해 줄 TCP 정보이다.\n이 때문에 신뢰할 수 있는 프로토콜 이라고도 하며, 전송 제어 프로토콜(Transmission Control Protocol) 이라고도 한다.\nTCP(Transmission Control Protocol)의 특징 TCP의 특징은 아래와 같다.\n 연결지향 - TCP 3 way handshake (가상연결)  TCP/IP 프로토콜로 통신하면 클라이언트 ➡ 서버, 서버 ➡ 클라이언트 양뱡향으로 탐색 과정을 거친다.\n이 탐색 과정을 TCP 3 way handshake 라고 한다.\n탐색이 끝나면 서버와 클라이언트가 논리적인 가상 연결 상태가 되며, 이는 물리적인 연결 상태는 아니다. 3\n즉, TCP는 클라이언트와 서버가 서로 연결됐다고 가정만 한 상태이다.\n 데이터 전달 보증  클라이언트가 데이터를 전송 하면 서버에서 데이터를 잘 받았다는 응답값을 전송한다.\n응답 값 전송 여부에 따라 메시지가 정상적으로 전달되지 않았을때에 대한 문제를 인지할 수 있게 된다.\n 순서 보장  서버에 전달된 패킷이 순서대로 도착하지 않았다면 서버는 문제가 된 패킷부터 재전송 요청한다.\n5. 마지막으로 IP 패킷은 물리적인 정보가 포함된 이더넷 프레임 정보가 추가되어 물리 계층으로 전달된다. UDP? 사용자 데이터그램 프로토콜(User Datagram Protocol)이라고한다.\n 기능이 거의 X 연결지향 - TCP 3 way handshake (가상연결) X 데이터 전달 보증 X 순서 보장 X  이 프로토콜을 왜 쓰지? 라는 생각이 들 수도 있겠지만 UDP 프로토콜만의 장점이 있다.\nTCP 프로토콜은 TCP 3 Way Handshake로 인한 소요 시간, 신뢰성을 보장하기 위한 여러가지 검증 정보로 인한 데이터의 크기 등의 문제가 있다.\n무엇보다도 가장 중요한 점은 인터넷 통신은 90% 이상 TCP기반 이라는 점이다.\n이전에는 신뢰할 수 있는 데이터에만 사용했던 프로토콜이었지만, 이제는 동영상과 같은 실시간 스트리밍 서비스에서도 TCP를 사용하고 있기 때문이다.\n때문에 TCP 프로토콜을 수정한다는 것은 불가능에 가깝다.\n그렇다면 어떻게 TCP 프로토콜을 최적화 할 수 있을까? UDP 프로토콜의 기능은 IP 프로토콜에 PORT만 추가된 형태로 하얀 도화지와 같다.\n이러한 이유 때문에 전송 계층이 아닌 애플리케이션 계층에서 최적화가 가능하다.\n최근 HTTP3 스펙에서는 TCP 프로토콜을 최적화하고자 UDP 프로토콜을 채택하면서 급부상하고 있는 프로토콜이다.\n  인터넷 프로토콜 스택은 인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는 통신규약(프로토콜)의 모음이다. 인터넷 프로토콜 슈트 중 TCP와 IP가 가장 많이 쓰이기 때문에 TCP/IP 프로토콜 슈트라고도 불린다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 패킷은 소화물을 뜻하는 패키지(package)와 덩어리를 뜻하는 버킷(bucket)의 합성어이다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 물리적으로 연결된다는 표현은 과거 전화국에서 전화 포트를 뽑아 연결하고자 하는 곳에 다시 연결해 주는 것과 같이 전용 랜선이 보장되는 것이다. TCP는 클라이언트와 서버가 서로 연결됐다고 가정만 한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/network/tcp-udp/","summary":"TCP? IP 프로토콜만으론 해결할 수 없는 문제점들이 있었다.\n 비연결성 (대상이 서비스 불능임에도 패킷 전송) 비신뢰성 패킷 전달 순서의 문제  이러한 문제점을 보완하고자 나온 프로토콜이 TCP, UDP 이다.\n하지만 우리는 인터넷 프로토콜 스택의 계층 구조를 먼저 살펴보아야 한다. 1\n인터넷 프로토콜 스택의 4계층을 단계별로 표현한 예제이다.\n위로갈수록 사용자와 가까운 작업을 아래로 갈수록 기계와 가까운 작업을 담당한다.\n각 계층에는 다양한 프로토콜이 있으며, TCP와 IP 프로토콜도 그중 하나이다.\n계층 구조를 살펴보자.","title":"TCP / UDP"},{"content":"인터넷상에서 컴퓨터 둘은 어떻게 통신할까? 클라이언트와 서버가 책상에 나란히 놓여있다고 가정해보자.\n그리고 클라이언트는 서버에게 Hello, world! 라는 메시지를 보내고자 한다.\n물리적으로 가까운 거리의 PC는 서로 연결된 케이블로 간단히 통신이 가능하다. 1\n이처럼 비교적 좁은 공간에 있는 기기끼리 연결한 네트워크를 우리는 LAN (Local Area Netwrok) 이라고 한다. 2\n하지만 메시지를 보내고자하는 서버가 지구 반대편에 있다면 어떻게 해야 할까?\n우리는 여러 개의 LAN이나 WAN을 연결한 전 세계 규모의 네트워크인 인터넷을 이용해야한다. 3\n인터넷 망은 단순하지 않다.\n인터넷은 서버와 서버의 연결이다. 이러한 네트워크 환경속에서 데이터는 수많은 서버를 거치게 된다.\n그렇다면 메시지가 목적지 서버까지 안전하게 전송될 수 있는 이유는 무엇일까?\n우리는 여기서 IP(인터넷 프로토콜) 이 무엇인지 짚고 넘어가야 한다.\nIP(인터넷 프로토콜) 복잡한 인터넷 망에서 데이터를 통신하기 위한 최소한의 규칙을 IP(인터넷 프로토콜) 이라 한다.\nIP(인터넷 프로토콜)을 이용한 통신 순서 1. 클라이언트와 서버에 IP 주소를 부여한다.\n2. IP 패킷을 만든다.\n출발지, 목적지 IP 정보와 함께 Hello, world! 라는 전송 데이터를 감싼다.\n택배에 출발지와 배송지 주소를 적는 것과 같다.\n3. 인터넷 망을 통해 IP 패킷을 전송한다.\n인터넷 망의 노드(서버)들은 모두 IP 프로토콜을 이해할 수 있도록 일련의 규약을 따르고있다.\n중간 노드들은 목적지가 어디있는지 서로 물어가면서 최적의 경로로 패킷을 전달하려고 할 것이다.\n4. 응답을 받은 서버는 동일한 방식으로 클라이언트에게 패킷을 전달한다.\n인터넷 망은 굉장히 복잡한 매커니즘을 따르고 있어 요청할 때와 응답할 때 거치는 노드가 다를 수 있다.\nIP(인터넷 프로토콜)의 한계 단순히 IP 주소를 부여하고 패킷을 전달하는 방식으로는 한계가 있다.\n어떤 한계점이 있을까?\n비연결성 아직까지 우리는 200.200.200.2 라는 서버가 켜져있는지 꺼져있는지 알 수 없다.\n패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷을 전송하는 건 낭비이다.\n비신뢰성 인터넷이라는건 용빼는 재주가 있는게 아니다.\n결국 패킷은 여러 서버를 거쳐 목적지로 전달된다.\n즉, 특정 노드에 문제가 생길 수 있다는 것이고, 패킷이 유실될 수 있다는 의미이다.\n패킷 전달 순서 문제 한번에 전송할 수 있는 메시지의 MTU(최대 전송 단위)는 1500 Byte 이다.\n메시지 패킷의 용량을 3000 Byte 라고 가정한다면 1500 Byte 단위 로 패킷이 나누어진다.\n클라이언트는 나누어진 패킷을 Hello, 와 World! 순으로 전달하게 될 것이다.\n문제는 여기서 발생한다.\n인터넷 망은 굉장히 복잡한 매커니즘을 따르고 있으므로 패킷들이 항상 동일한 노드를 거치지는 않는다.\n즉, 패킷의 요청 순서와 다르게 목적지 서버에 전달될 수 있다는 의미이다.\n마무리 위에 열거한 비연결성, 비신뢰성, 패킷 전달 순서 문제는 IP 프로토콜만으론 해결할 수 없다.\n다음 포스트에서 IP 프로토콜의 문제점을 보완하고자 나온 TCP, UDP 프로토콜을 다루고자 한다.\n  접속에는 주로 가는 구리선을 짜넣은 LAN 케이블을 사용한다. 케이블을 사용하지 않고 전파나 적외선 등을 사용하여 연결한 것을 \u0026lsquo;무선 LAN\u0026rsquo; 이라고 한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 반대로 지리적으로 멀리 떨어진 장소에 있는 기기를 광섬유 케이블이나 공중망(전화 회선) 등을 사용하여 연결한 것을 WAN(Wide Area Network) 이라고 한다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 워크스테이션 수준의 고사양 개인용 컴퓨터가 널리 보급되고, LAN과 WAN으로 인터넷이라는 국제적인 통신망이 연결되기 시작했다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/network/internet-protocol/","summary":"인터넷상에서 컴퓨터 둘은 어떻게 통신할까? 클라이언트와 서버가 책상에 나란히 놓여있다고 가정해보자.\n그리고 클라이언트는 서버에게 Hello, world! 라는 메시지를 보내고자 한다.\n물리적으로 가까운 거리의 PC는 서로 연결된 케이블로 간단히 통신이 가능하다. 1\n이처럼 비교적 좁은 공간에 있는 기기끼리 연결한 네트워크를 우리는 LAN (Local Area Netwrok) 이라고 한다. 2\n하지만 메시지를 보내고자하는 서버가 지구 반대편에 있다면 어떻게 해야 할까?\n우리는 여러 개의 LAN이나 WAN을 연결한 전 세계 규모의 네트워크인 인터넷을 이용해야한다. 3","title":"IP (인터넷 프로토콜)"},{"content":"시간 복잡도는 왜 필요할까? 알고리즘은 어떤 문제를 해결하기 위한 일련의 과정 입니다.\n알고리즘 문제를 풀다보면 시간초과로 인해 시간복잡도를 생각해야 하는 경우가 자주 생기게되는데 동일한 문제해결 목표를 가진 알고리즘이 존재할 때 가장 시간복잡도가 가장 낮은 알고리즘을 사용 해야 시간초과 오류를 면할 수 있습니다.\n아무리 복잡한 알고리즘이라도 입력의 크기가 작으면 단시간에 끝나버리기 때문에 입력값의 크기가 충분히 클 때 그 효율성이 적나라하게 나타납니다.\n이러한 점근적 실행 시간1을 표기할 때 가장 널리쓰이는 수학적 표기법이 빅오 (big-O)입니다.\n빅오 표기법의 종류는 크게 다음과 같습니다.\nO(1) 상수 시간을 갖는 알고리즘으로 입력값 n이 주어졌을 때, 알고리즘이 문제를 해결하는데 오직 한 단계만 거칩니다. 즉, 입력값이 아무리 커도 실행 시간은 일정합니다.\n최고의 알고리즘이지만 상수값이 무한대로 커진다면 사실상 일정한 시간의 의미는 없어집니다.\nprint(\u0026#34;hello, world!\u0026#34;) a = [1, 2, 3, 4, 5] print(a[2]) # 3 위와 같이 입력값의 길이와 상관없이 데이터를 추출하는데 소요시간에 변함이 없어야합니다.\nPython 함수 및 메소드의 시간 복잡도를 정리해둔 사이트가 있으니 참고합니다.\nComplexity of Python Operations\nO(log n) 실행 시간이 입력값에 영향을 받지만 특정 조건에 따라 입력값 탐색시간이 줄어듭니다.\n아래 예제를 보시면 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어드는 것을 확인하실 수 있습니다.\na = [1, 2, 3, 4, 5, 6, 7, 8, 9] for i in range(0, len(a), 3): print(a[i]) # 1, 4, 7 O(n) 입력값만큼 실행 시간이 영향을 받으며, 알고리즘을 수행하기 위한 단계의 수와 시간이 입력값과 1:1 관계를 가집니다.\n이를 선형 시간(Linear-Time) 알고리즘이라 합니다.\na = [1, 2, 3] for n in a: print(n) # 1 2 3 O(n log n) 병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘이 이에 해당합니다.\n병합 정렬은 주어진 리스트를 하나의 해가 될 때까지 재귀적으로 나누고 다시 작은 수 부터 정렬하여 병합합니다.\n시간 복잡도는 최악의 경우 O(nlogn)으로 나누면서 log n의 시간이 소요되고, 병합하면서 n의 시간이 소요됩니다.\ninput() 데이터를 입력 받습니다.\n# O(N log N) unsorted_list = [int(x) for x in input().split()] merge_sort() n / 2로 나눠 1개의 요소가 남을때까지 재귀호출 합니다.\n# n / 2로 나눠 1개의 요소가 남을때까지 재귀호출 합니다. # 그 다음 2개씩의 요소들을 반복적으로 병합합니다. def merge_sort(unsorted_list): # if 구문을 통해 정렬되지 않은 리스트의 데이터가 1개 이하면 그대로 반환합니다. if len(unsorted_list) \u0026lt;= 1: return unsorted_list mid = len(unsorted_list) // 2 left = unsorted_list[:mid] right = unsorted_list[mid:] left1 = merge_sort(left) ## 재귀를 이용하여 왼쪽 리스트를 다시 나눕니다. right1 = merge_sort(right) ## 오른쪽도 마찬가지로 다시 나눕니다. return merge(left1, right1) merge_sort(unsorted_list)  merge() left와 right 리스트의 0번자리 부터 비교 후 작은 값을 sorted_list에 삽입합니다.\n비교가 끝난 후 남은 값을 sorted_list에 삽입합니다.\ndef merge(left, right): i = 0 j = 0 sorted_list = [] # 둘중 하나가 만족할때까지 append while i \u0026lt; len(left) and j \u0026lt; len(right): if left[i] \u0026lt; right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # 남은 값들을 넣어준다  while i \u0026lt; len(left): sorted_list.append(left[i]) i += 1 while j \u0026lt; len(right): sorted_list.append(right[j]) j += 1 return sorted_list # 리스트 예시 # merge_sort() 8 7 6 5 4 3 2 1 [8765] [4321] [87] [65] [43] [21] [8] [7] [6] [5] [4] [3] [2] [1] # merge()  [8] [7] [6] [5] [4] [3] [2] [1] [78] [56] [34] [12] [5678] [1234] 1 2 3 4 5 6 7 8 O(n²) 버블 정렬과 같은 비효율적인 정렬 알고리즘이 이에 해당합니다.\n이중 loop로 진행되는 알고리즘 이기때문에 시간 복잡도는 O(n²) 입니다.\ndef bubble_sort(l): swap = True while swap: swap = False for i in range(len(l)-1): if l[i] \u0026gt; l[i+1]: l[i], l[i+1] = l[i+1], l[i] swap = True lst = [8, 5, 3, 1, 4, 7, 9] bubble_sort(lst) O(n!) 브루트 포스로 알고리즘 문제를 풀이할 때가 이에 해당합니다.\nn=100만 되어도 n!은 9.332622e+157 입니다.\nfrom math import factorial print(factorial(100)) #933262154439441526816992388562667004907159682643816214685929638952175999932299156089414639761565182862536979208272237582511852109168640000000000000000000000000  마무리 빅오는 시간 복잡도 외에도 공간 복잡도를 표현하는 데에도 널리 쓰입니다.\n알고리즘은 시간과 공간이 트레이드오프 관계입니다. 실행 시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 사용하는 알고리즘은 실행 시간을 많이 사용합니다.\n이처럼 대부분의 경우 시간과 공간은 트레이드오프 관계이며, 이는 알고리즘의 주요한 특징 중 하나입니다.\n  시간 복잡도라고도 하며, 입력값이 무한대를 향할 때 함수 실행 시간 추이를 의미합니다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/datastructure/%EB%B9%85%EC%98%A4/","summary":"시간 복잡도는 왜 필요할까? 알고리즘은 어떤 문제를 해결하기 위한 일련의 과정 입니다.\n알고리즘 문제를 풀다보면 시간초과로 인해 시간복잡도를 생각해야 하는 경우가 자주 생기게되는데 동일한 문제해결 목표를 가진 알고리즘이 존재할 때 가장 시간복잡도가 가장 낮은 알고리즘을 사용 해야 시간초과 오류를 면할 수 있습니다.\n아무리 복잡한 알고리즘이라도 입력의 크기가 작으면 단시간에 끝나버리기 때문에 입력값의 크기가 충분히 클 때 그 효율성이 적나라하게 나타납니다.\n이러한 점근적 실행 시간1을 표기할 때 가장 널리쓰이는 수학적 표기법이 빅오 (big-O)입니다.","title":"빅오 (big-O)"},{"content":"Python 문법 인덴트 (Indent) Python의 공식 가이드 PEP 8에 따라 공백 4칸을 원칙으로 합니다.\n강제는 아니며 얼마든지 선택적으로 적용할 수는 있으나, Python 답게 이 기준을 준수하기로 합니다.\n 네이밍 컨벤션 (Naming Convention) Python의 네이밍 컨벤션은 자바와 달리 각 단어를 밑줄로 구분하는 Snake Case를 따릅니다.\n함수와 변수명 모두 Snake Case를 지향하고 있으며, Python의 철학에 따라 스네이크 코딩 스타일을 지향하도록 합니다.\ncamelCase: int = 1 # Camel Case snake_case: int = 1 # Snake Case  타입 힌트 (Type Hint) Python은 동적 타이핑 언어임에도 타입을 지정할 수 있는 타입 힌트를 지원합니다. (Python 버전 3.5 이상)\n변수 타입 지정 예시 a: str = \u0026#34;1\u0026#34; b: int = 1  타입 힌트를 사용하지 않으면 아래 예시처럼 a에는 숫자를 넘겨야하는지 문자를 넘겨야하는지 알 수 없습니다.\n이는 프로젝트 규모가 커지게 될 경우 좋지않은 가독성과 버그를 유발합니다.\n타입 힌트를 사용하지 않은 함수 예시 def fn(a):  그렇다면 어떻게 해야 타입 힌트를 사용하여 코드를 작관적으로 바꿀 수 있을까요?\n아래와 같이 파리미터가 정수형이면서 리턴값이 boolean값임을 알 수 있도록 타입 힌트를 사용하도록 합니다.\n타입 힌트를 사용한 함수 예시 def fn(a: int) -\u0026gt; bool:  강제 규약은 아니다보니 타입이 달라도 동적 할당이 될 수 있으므로 위와 같이 문자열에 정수를 할당하는 등의 사용 방식은 절대적으로 지양해야합니다.\n잘못된 동적 할당 예시 a: str = 1  추가적으로, mypy를 설치하여 타입 힌트에 오류가 없는지 자동으로 확인할 수 있습니다.\n$ pip install mypy  리스트 컴프리헨션 (List Comprehenshion) Python은 map, filter와 같은 함수형 기능을 지원하며 다음과 같은 람다 표현식도 지원합니다.\n람다 표현식 예시 list(map(lambda x: x+ 10, [1, 2, 3])) # [11, 12, 13]  람다 표현식도 굉장히 좋은 기능이지만 훨씬 더 유용한 기능은 리스트 컴프리헨션입니다.\n기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문으로 홀수인 경우 2를 곱해 출력하도록 하는 리스트 컴프리헨션 예시를 보시겠습니다.\n리스트 컴프리헨션 예시 [n * 2 for n in rnage(1, 11) if n % 2 = 1] # [2, 6, 10, 14, 18]  리스트 컴프리헨션을 사용하지 않는다면 다음과 같이 길게 풀어서 작성해야 합니다.\n리스트 컴프리헨션을 사용하지 않았을 때 예시 a = [] for n in range(1, 11): if n % 2 == 1: a.append(n * 2)  풀어서 작성한 코드는 리스트 컴프리헨션을 사용한 것에 비해 훨씬 더 길어졌고, a라는 별도의 리스트 변수 또한 필요해졌습니다.\n리스트 컴프리헨션과 비교했을 때 라인 수가 많이 증가한 것을 확인하실 수 있습니다.\n또한, 리스트 컴프리헨션이라고 해서 리스트만 지원하는 것은 아닙니다.\n딕셔너리 컴프리헨션을 사용한 예시 # 리스트 컴프리헨션 미사용 a = {} for key, value in original.items(): a[key] = value # 리스트 컴프리헨션 사용 a = {key, value for key, value in original.items()}  이처럼 딕셔너리도 컴프리헨션이 가능합니다. (파이썬 버전 2.7 이상)\n무리하게 사용할 경우 가독성을 떨어뜨릴 수 있으므로 적절히 사용하는 게 중요합니다.\n 제너레이터 (Generaotr) 제너레이터는 루프의 반복동작을 제어할 수 있는 루틴 형태를 의미합니다.\n예를들어 임의의 조건으로 숫자 1억 개를 만들어내 계산하는 프로그램을 작성한다고 가정해봅니다.\n이 경우 제너레이터가 없다면 메모리 어딘가에 만들어낸 숫자 1억 개를 보관하고 있어야하는 소모가 발생합니다.\nyield 구문을 사용하여 제너레이터를 리턴할 수 있는데, 기존의 함수는 return 구문을 맞닥뜨리면 값을 리턴하고 모든 함수의 동작을 종료했습니다.\n그러나 yield는 제너레이터가 실행 중이던 값을 내보낸다는 의미로, 중간값을 리턴한 다음 함수는 종료되지 않고 계속해서 맨 끝에 도달할 때까지 실행됩니다.\n제너레이터 사용 예시 def get_natural_number(): n = 0 while True: n += 1 yield n  제너레이터를 이용하여 100개의 값을 생성하고자 한다면 다음과 같이 100번의 next()를 수행하도록 합니다.\nnext() 사용 예시 g = get_natural_number() for _ in range(0, 100): prnit(next(g))  제너레이터는 여러 타입의 값을 하나의 함수에서 생성하는 것도 가능합니다.\n여러 타입의 값 생성 예시 def generator(): yield 1 yield \u0026#39;string\u0026#39; yield True g = generaotr() print(next(g)) # 1 print(next(g)) # \u0026#39;string\u0026#39; print(next(g)) # True  range 제니레이터의 방식을 활용하는 대표적인 함수로 range()가 존재합니다.\n주로 for 문에서 쓰이는 range() 함수의 쓰임은 다음과 같습니다.\nlist(range(5)) # [0, 1, 2, 3, 4] for i in range(5): print(i) # 0 1 2 3 4   range() 를 사용하는 이유는 메모리 효율때문입니다. 생성 조건만 정해두고 필요할 때 생성해서 꺼내 쓸 수 있기 때문입니다.\n예를들어 100만 개의 숫자를 생성해야한다면 어떻게 될까요? 메모리에서 적지 않은 공간을 차지할 것이고 생성 시간도 오래 걸릴 것입니다.\nrange 사용 예시 a = [n for n in range(1000000)] b = range(100000)  위 코드를 다음과 같이 len()으로 길이 비교를 해보면 둘 다 동일한 100만 개가 출력되며, 비교연산자에서도 True를 리턴합니다.\nrange 비교 예시 len(a) # 1000000 len(b) # 1000000 len(a) == len(b) # True  하지만 둘 사이의 메모리 점유율을 비교해보면 range 클래스를 곧바로 리턴하는 방식이 훨씬 더 적은것을 확인 할 수 있습니다\n메모리 점유율 비교 예시 sys.getsizeof(a) # 8697464 sys.getsizeof(b) # 48  range 클래스를 이용하면 값이 1억 개라도 b 변수의 메모리 점유율은 동일합니다/\n생성 조건만 보관하고 있기 때문입니다.\n게다가 인덱스로 접근 시에는 곧바로 생성하도록 구현되어 있기 때문에 다음과 같이 리스트와 거의 동일한 느낌으로 불편 없이 사용할 수 있습니다.\n인덱스 참조 예시 b[999] # 999  enumerate enumerate()는 \u0026lsquo;열거하다\u0026rsquo;는 뜻의 함수입니다.\n아래와 같이 여러가지 자료형(list, set, tuple 등)을 인덱스를 포함한 enumerate 객체로 리턴합니다.\nenumerate 사용 예시 a = [1, 2, 3, 2, 45, 2, 5] list(enumerate(a)) # [(0, 1), (1, 2), (2, 3), (3, 2), (4, 45), (5, 2), (6, 5)] a = ['a1', 'b2', 'c3']를 key, value형태로 출력하기 위해 enumerate 함수를 활용할 수 있습니다.\nenumerate 활용 예시 a = [\u0026#39;a1\u0026#39;, \u0026#39;b2\u0026#39;, \u0026#39;c3\u0026#39;] for key, value in enumerate(a): print(key, value)  print 코딩 테스트 문제 풀이 과정에서 디버깅을 할 때 가장 많이 쓰이는 명령어는 바로 print() 입니다.\n이를 좀 더 유용하게 활용할 수 있는 방법 몇 가지를 살펴봅니다.\n1) 콤마(,)로 구분하면 띄어쓰기 구분자로 값을 구분하여 출력합니다. print(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;) # A B 2) 콤마(,)를 구분자로 지정하려면 seq를 사용합니다. print(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, seq=\u0026#39;,\u0026#39;) # A,B 3) print()는 항상 줄바꿈을 합니다. 줄바꿈을 하지 않도록 제한 하려면 end를 사용합니다. print(\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, end=\u0026#39; \u0026#39;) print(\u0026#39;C\u0026#39;) # A B C 4) 리스트를 한 줄에 출력하고자 할 때는 join()을 사용합니다. a = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;] \u0026#39; \u0026#39;.join(a) # A B 5) 인덱스를 활용하여 변수에 값을 더해 출력 가능합니다. idx = 1 fruit = \u0026#34;Apple\u0026#34; print(\u0026#39;{0}: {1}\u0026#39;.format(idx + 1, fruit)) # 인덱스 생략 가능: print(\u0026#34;{}: {}\u0026#34;.format(idx + 1, fruit)) # 2: Apple 6) f-string(formated string literal)을 사용하면 별도로 변수를 부여할 필요 없이 사용 가능합니다. 템플릿을 사용하듯 인라인으로 삽입할 수 있어 편리하고, .format을 부여하는 방식에 비해 훨씬 간결하고 직관적입니다.\nidx = 1 fruit = \u0026#34;Apple\u0026#34; print(f\u0026#39;{idx +1}: {fruit}\u0026#39;)  locals locals()는 로컬 스코프에 선언된 모든 변수를 조회할 수 있는 명령어입니다.\n코딩 테스트 플랫폼 문제 풀이 중에도 코디 내부에 출력해 활용할 수 있습니다.\nlocals() 호출 예시 import pprint pprint.pprint(locals())  pprint로 출력하게 되면 보기 좋게 줄바끔 처리를 해주기 때문에 가독성높은 출력문 확인이 가능합니다.\n Python의 특징 루프 (Loop) 1부터 10까지의 합을 구하는 간단한 루프 구조 예시입니다.\n예시 1 sum = 0 for i in range(1, 11): sum += i 예시 2 sum = 0 sum = sum(i for i in range(1, 11)) 예시 3 sum = sum(range(1, 11))  생산적인 언어답게 One-Liner로 처리가 가능합니다.\n한 줄 처리의 경우 깔끔하고 생산적입니다만, 지나친 사용은 가독성을 떨어트릴 수 있으므로 적절하게 사용합니다.\n제네릭 (Generic) 1 제네릭이란 클래스 내부에서 사용 할 파라미터의 타입을 외부에서 지정되게 하는 기법입니다.\n즉, 인스턴스를 생성할 때 데이터 타입을 지정하여 객체의 재활용성을 높일 수 있는 프로그래밍 스타일입니다.\ndef are_equal(a, b): return a == b are_equal(10, 10.0)  예시 코드 실행 시 따로 파라미터에 타입을 지정해주지 않았음에도 코드가 정상동작 합니다.\nPython은 동적 타이핑 언어로 제네릭이 필요하지 않기 때문입니다.\n하지만 타입을 명시해주지 않으면 가독성이 떨어지고, 버그 발생 확률이 높아진다는 단점이 있습니다.\n하여 Python 3.5 이상 버전부터 제네릭을 사용 할 수 있게 되어 다음과 같이 타입을 명시할 수 있게 되었습니다.\nfrom typing import List, TypeVar T = TypeVar(\u0026#39;T\u0026#39;, int, str, List[int]) # T는 int, str, List[int] Type 일 수 있습니다. def are_equal(a: T, b: T) -\u0026gt; T: return a + b print(are_equal(1, 3)) # [int, int] -\u0026gt; int print(are_equal(\u0026#39;item\u0026#39;, \u0026#39;4\u0026#39;)) # [str, str] -\u0026gt; str print(are_equal([10], [10.0])) # [List[int], List[int]] -\u0026gt; List[int] print(are_equal(\u0026#39;item\u0026#39;, 4)) # Err 배열 반복 foo = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] for f in foo: print(f)  다른 언어에 비해 자료형이라는 선언이 필요 없는 Python 코드는 매우 간결합니다.\n클래스 from dataclasses import dataclass @dataclass class Rectangle: weight: int price: int def area(self): return self.weight * self.price rect = Rectangle(3, 4) print(rect.area())  Python 3.7부터 dataclass를 지원합니다.\n@dataclass 데코레이션으로 타입 힌트와 함께 활용하여 다음과 같이 class를 정의 할 수 있습니다.\ndataclass를 선언하지 않아도 클래스 구현에는 문제가 없으나 선언하게 되면 여러 가지 내부 함수 기능을 자동으로 구현해주기 때문에 활용하는게 좋습니다.\n  제네릭 프로그래밍(영어: generic programming)은 데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있는 기술에 중점을 두어 재사용성을 높일 수 있는 프로그래밍 방식이다. (위키백과)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/python/python-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/","summary":"Python 문법 인덴트 (Indent) Python의 공식 가이드 PEP 8에 따라 공백 4칸을 원칙으로 합니다.\n강제는 아니며 얼마든지 선택적으로 적용할 수는 있으나, Python 답게 이 기준을 준수하기로 합니다.\n 네이밍 컨벤션 (Naming Convention) Python의 네이밍 컨벤션은 자바와 달리 각 단어를 밑줄로 구분하는 Snake Case를 따릅니다.\n함수와 변수명 모두 Snake Case를 지향하고 있으며, Python의 철학에 따라 스네이크 코딩 스타일을 지향하도록 합니다.\ncamelCase: int = 1 # Camel Case snake_case: int = 1 # Snake Case  타입 힌트 (Type Hint) Python은 동적 타이핑 언어임에도 타입을 지정할 수 있는 타입 힌트를 지원합니다.","title":"Python 살펴보기"},{"content":"언어는 Python으로 하겠습니다. 근데 이제 알고리즘을 곁들인 Python을 선택한 이유 대다수의 코딩 인터뷰에서 Python 지원, 초보자도 쉽게 접근할 수 있는 언어, 수많은 자료구조 모듈, 짧은 코드 길이와 가독성, 쉬운 문자열 핸들링, 임의 정밀도 정수형으로 신경 쓰지 않아도 되는 오버플로는 Python의 대표적인 장점들이다.\n코딩 테스트 플랫폼1 에서 언어별 타임아웃 설정이 C++, Java에 비해 굉장히 타이트하기 때문에 동일한 알고리즘임에도 파이썬으로는 풀리지 않는 (억울한) 일이 심심찮게 발생하고 있지만!\n알고리즘 최적화에 좀 더 많은 고민이 필요하기 때문에 유연한 사고와 학습을 목표로 하는 나에겐 오히려 좋은 점으로 작용하게 될 것 같다.\nPython 시작하기 (Only Mac) Python을 설치하기에 앞서 Mac OS 패키지 관리 도구인 homebrew부터 설치한다.\n homebrew 설치\n 하단의 Command를 터미널에서 실행시킨다.\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)  pyenv와 pyenv-virtualenv를 이용한 Python 개발 환경 구성\n 인터프리터 환경은 주기적인 업데이트가 이루어진다.\n업데이트가 이루어질때마다 새로운 버전의 개발 환경을 재설치하는 것은 매우 귀찮고 번거로운 일 일것이다.\nPython을 버전별로 관리 할 수 있도록 Python Version Manager인 pyenv를 설치하도록 하자.\nbrew update brew install pyenv  이어서 가상환경을 이용해 Python 프로젝트를 분리 운영 할 수 있도록 pyenv-virtualenv를 설치한다.\n프로젝트 마다 설치된 패키지 사이의 충돌을 막아 주기 위함이다.\nbrew install pyenv-virtualenv  pyenv및 pyenv-virtualenv가 정상동작 할 수 있도록 셀 설정파일에 각 프로그램의 초기화 코드를 추가하여 환경변수를 설정한다.\nCatalina 이후 버전부터 기본 셸이 zsh로 변경되었기 때문에 ~/.zshrc 파일을 수정했다.\necho $SHELL 명령어를 사용해 간단히 사용중인 쉘이 무엇인지 간단히 확일 할 수 있으니 참고하자.\nvi ~/.zshrc export PATH=$HOME/.pyenv/bin:$PATH eval \u0026#34;$(pyenv init -)\u0026#34; eval \u0026#34;$(pyenv virtualenv-init -)\u0026#34;  변경사항을 반영한다\n source ~/.zshrc #설정 저장 - zsh exec $SHELL #shell 재실행  Python을 버전에 맞게 설치한다.\n필자는 3.7.7 버전을 설치했다.\npyenv install 3.7.7  Mac OS 가 Big sur로 버전업 되면서 XCode 관련 업데이트가 있었는지 BUILD FAILED 에러가 발생했다.\n급한대로 하단 명령어를 실행하여 Python을 설치했다.\nCFLAGS=\u0026#34;-I$(brew --prefix openssl)/include -I$(brew --prefix bzip2)/include -I$(brew --prefix readline)/include -I$(xcrun --show-sdk-path)/usr/include\u0026#34; LDFLAGS=\u0026#34;-L$(brew --prefix openssl)/lib -L$(brew --prefix readline)/lib -L$(brew --prefix zlib)/lib -L$(brew --prefix bzip2)/lib\u0026#34; pyenv install --patch 3.7.7 \u0026lt; \u0026lt;(curl -sSL https://github.com/python/cpython/commit/8ea6353.patch\\?full_index\\=1)  가상환경 명령어를 상황에 맞게 실행한다.\npython -V # 2.7.7 출력 pyenv virtualenv 3.7.7 workspace # 가상환경 생성 pyenv virtualenv \u0026lt;version\u0026gt; \u0026lt;virtualenv_name\u0026gt;  pyenv activate workspace python -V # 3.7.7 출력 pyenv deactivate # 가상환경 해제하기   해커랭크 (https://www.hackerrank.com)\n코딜리티 (https://www.codility.com)\n리모트인터뷰 (https://www.remoteinterview.io)\n프로그래머스(국내) (https://www.programmers.co.kr) 등이 있다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://5hdumat.github.io/posts/python/python-%EC%9E%85%EB%AC%B8%ED%95%98%EA%B8%B0/","summary":"언어는 Python으로 하겠습니다. 근데 이제 알고리즘을 곁들인 Python을 선택한 이유 대다수의 코딩 인터뷰에서 Python 지원, 초보자도 쉽게 접근할 수 있는 언어, 수많은 자료구조 모듈, 짧은 코드 길이와 가독성, 쉬운 문자열 핸들링, 임의 정밀도 정수형으로 신경 쓰지 않아도 되는 오버플로는 Python의 대표적인 장점들이다.\n코딩 테스트 플랫폼1 에서 언어별 타임아웃 설정이 C++, Java에 비해 굉장히 타이트하기 때문에 동일한 알고리즘임에도 파이썬으로는 풀리지 않는 (억울한) 일이 심심찮게 발생하고 있지만!\n알고리즘 최적화에 좀 더 많은 고민이 필요하기 때문에 유연한 사고와 학습을 목표로 하는 나에겐 오히려 좋은 점으로 작용하게 될 것 같다.","title":"Python 입문하기"}]