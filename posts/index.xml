<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on 5hdumat</title><link>https://5hdumat.github.io/posts/</link><description>Recent content in Posts on 5hdumat</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 28 Jun 2021 00:49:00 +0900</lastBuildDate><atom:link href="https://5hdumat.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>빅오 (big-O)</title><link>https://5hdumat.github.io/posts/datastructure/%EB%B9%85%EC%98%A4/</link><pubDate>Mon, 28 Jun 2021 00:49:00 +0900</pubDate><guid>https://5hdumat.github.io/posts/datastructure/%EB%B9%85%EC%98%A4/</guid><description>시간 복잡도는 왜 필요할까? 알고리즘은 어떤 문제를 해결하기 위한 일련의 과정 입니다.
알고리즘 문제를 풀다보면 시간초과로 인해 시간복잡도를 생각해야 하는 경우가 자주 생기게되는데 동일한 문제해결 목표를 가진 알고리즘이 존재할 때 가장 시간복잡도가 가장 낮은 알고리즘을 사용 해야 시간초과 오류를 면할 수 있습니다.
아무리 복잡한 알고리즘이라도 입력의 크기가 작으면 단시간에 끝나버리기 때문에 입력값의 크기가 충분히 클 때 그 효율성이 적나라하게 나타납니다.
이러한 점근적 실행 시간1을 표기할 때 가장 널리쓰이는 수학적 표기법이 빅오 (big-O)입니다.</description></item><item><title>Python 살펴보기</title><link>https://5hdumat.github.io/posts/python/python-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/</link><pubDate>Sun, 20 Jun 2021 20:46:38 +0900</pubDate><guid>https://5hdumat.github.io/posts/python/python-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/</guid><description>Python 문법 인덴트 (Indent) Python의 공식 가이드 PEP 8에 따라 공백 4칸을 원칙으로 합니다.
강제는 아니며 얼마든지 선택적으로 적용할 수는 있으나, Python 답게 이 기준을 준수하기로 합니다.
네이밍 컨벤션 (Naming Convention) Python의 네이밍 컨벤션은 자바와 달리 각 단어를 밑줄로 구분하는 Snake Case를 따릅니다.
함수와 변수명 모두 Snake Case를 지향하고 있으며, Python의 철학에 따라 스네이크 코딩 스타일을 지향하도록 합니다.
camelCase: int = 1 # Camel Case snake_case: int = 1 # Snake Case 타입 힌트 (Type Hint) Python은 동적 타이핑 언어임에도 타입을 지정할 수 있는 타입 힌트를 지원합니다.</description></item><item><title>1475번: 방 번호</title><link>https://5hdumat.github.io/posts/algorithm/implementation/1475/</link><pubDate>Tue, 08 Jun 2021 23:29:12 +0900</pubDate><guid>https://5hdumat.github.io/posts/algorithm/implementation/1475/</guid><description>문제 다솜이는 은진이의 옆집에 새로 이사왔다. 다솜이는 자기 방 번호를 예쁜 플라스틱 숫자로 문에 붙이려고 한다.
다솜이의 옆집에서는 플라스틱 숫자를 한 세트로 판다. 한 세트에는 0번부터 9번까지 숫자가 하나씩 들어있다. 다솜이의 방 번호가 주어졌을 때, 필요한 세트의 개수의 최솟값을 출력하시오. (6은 9를 뒤집어서 이용할 수 있고, 9는 6을 뒤집어서 이용할 수 있다.) 풀이 이 문제의 키 포인트는 6과 9를 공통적으로 사용 할 수 있다는 점입니다.</description></item><item><title>15663번: N과 M (9)</title><link>https://5hdumat.github.io/posts/algorithm/backtracking/15663/</link><pubDate>Mon, 07 Jun 2021 00:09:12 +0900</pubDate><guid>https://5hdumat.github.io/posts/algorithm/backtracking/15663/</guid><description>문제 N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수 중에서 M개를 고른 수열 중복되는 수열을 한번만 출력하도록 하는 경우의 수를 보여줘야하는 문제였습니다.
풀이 n, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n temp_list = [] output = [] def dfs(depth): if depth == m: if not tuple(temp_list) in output: output.</description></item><item><title>15657번: N과 M (8)</title><link>https://5hdumat.github.io/posts/algorithm/backtracking/15657/</link><pubDate>Sun, 06 Jun 2021 19:10:38 +0900</pubDate><guid>https://5hdumat.github.io/posts/algorithm/backtracking/15657/</guid><description>문제 N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다. N개의 자연수 중에서 M개를 고른 수열 같은 수를 여러 번 골라도 된다. 고른 수열은 비내림차순이어야 한다. 길이가 K인 수열 A가 A1 ≤ A2 ≤ &amp;hellip; ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다. 풀이 방문 체크 리스트 visited 관련 문구를 제거하여 자기 자신도 포함 할 수 있게합니다.</description></item><item><title>15656번: N과 M (7)</title><link>https://5hdumat.github.io/posts/algorithm/backtracking/15656/</link><pubDate>Sun, 06 Jun 2021 18:10:38 +0900</pubDate><guid>https://5hdumat.github.io/posts/algorithm/backtracking/15656/</guid><description>문제 N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다. N개의 자연수 중에서 M개를 고른 수열 같은 수를 여러 번 골라도 된다. 풀이 방문 체크 리스트 visited 관련 문구를 제거한 후 쉽게 해결할 수 있었습니다.
n, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() output = [] def dfs(depth): if depth == m: # 탈출 조건 print(*output) # *: list Unpacking 후 출력 return for i in range(n): output.</description></item><item><title>15655번: N과 M (6)</title><link>https://5hdumat.github.io/posts/algorithm/backtracking/15655/</link><pubDate>Sun, 06 Jun 2021 18:02:38 +0900</pubDate><guid>https://5hdumat.github.io/posts/algorithm/backtracking/15655/</guid><description>문제 N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다. N개의 자연수 중에서 M개를 고른 수열 고른 수열은 오름차순이어야 한다. 풀이 number_list 변수를 리스트로 입력받아 오름차순 정렬을 해주었습니다.
기존의 output.append(i) 구문을 output.append(number_list[i])로 변경하여 number_list 인자 값을 출력 리스트 output에 추가하였습니다.
idx 변수를 추가하여 재귀 호출 시 idx 이하의 값은 입력받지 않도록 하였습니다.
두 번째 문제풀이 이후 비슷한 패턴의 문제가 반복되는 것 같습니다.</description></item><item><title>15654번: N과 M (5)</title><link>https://5hdumat.github.io/posts/algorithm/backtracking/15654/</link><pubDate>Sun, 06 Jun 2021 17:54:38 +0900</pubDate><guid>https://5hdumat.github.io/posts/algorithm/backtracking/15654/</guid><description>문제 N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다. N개의 자연수 중에서 M개를 고른 수열 풀이 number_list 변수를 리스트로 입력받아 오름차순 정렬을 해주었습니다.
기존의 output.append(i) 구문을 output.append(number_list[i])로 변경하여 number_list 인자 값을 출력 리스트에 입력하여 손쉽게 해결할 수 있었습니다.
n, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n output = [] def dfs(depth): if depth == m: print(*output) return for i in range(n): if not visited[i]: visited[i] = True output.</description></item><item><title>15652번: N과 M (4)</title><link>https://5hdumat.github.io/posts/algorithm/backtracking/15652/</link><pubDate>Sun, 06 Jun 2021 17:37:38 +0900</pubDate><guid>https://5hdumat.github.io/posts/algorithm/backtracking/15652/</guid><description>문제 자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 같은 수를 여러 번 골라도 된다. 고른 수열은 비내림차순이어야 한다. 길이가 K인 수열 A가 A1 ≤ A2 ≤ &amp;hellip; ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다. 풀이 방문 체크 리스트 visited 관련 문구를 제거한 후 idx 변수를 추가하여 재귀 호출 시 idx 이하의 값은 입력받지 않도록 하였습니다.</description></item><item><title>15651번: N과 M (3)</title><link>https://5hdumat.github.io/posts/algorithm/backtracking/15651/</link><pubDate>Sun, 06 Jun 2021 17:18:38 +0900</pubDate><guid>https://5hdumat.github.io/posts/algorithm/backtracking/15651/</guid><description>문제 자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 같은 수를 여러 번 골라도 된다. 풀이 방문 체크 리스트 visited 관련 문구를 제거한 후 쉽게 해결할 수 있었습니다.
n, m = map(int, input().split()) output = [] def dfs(depth): if depth == m: print(*output) return for i in range(n): output.append(i + 1) dfs(depth + 1) output.</description></item><item><title>15650번: N과 M (2)</title><link>https://5hdumat.github.io/posts/algorithm/backtracking/15650/</link><pubDate>Sun, 06 Jun 2021 16:31:38 +0900</pubDate><guid>https://5hdumat.github.io/posts/algorithm/backtracking/15650/</guid><description>문제 자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 고른 수열은 오름차순이어야 한다. 이 문제의 핵심은 1부터 N까지의 자연수 중 오름차순이면서 중복 없이 M개를 나열한 수열을 출력하는 것 이었습니다.
예제 출력 3에서 4 4를 입력받아 자연수를 1부터 4까지 오름차순으로 그리고 중복 없이 1 2 3 4가 출력 되고 있는 것을 확인하실 수 있습니다.</description></item><item><title>15649번: N과 M (1)</title><link>https://5hdumat.github.io/posts/algorithm/backtracking/15649/</link><pubDate>Thu, 03 Jun 2021 01:13:38 +0900</pubDate><guid>https://5hdumat.github.io/posts/algorithm/backtracking/15649/</guid><description>문제 자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 사전 지식 DFS, 백트래킹에 대한 개념 이해가 필요한 문제였습니다.
DFS (깊이 우선 탐색) 완전 탐색을 기본으로 하는 그래프 탐색 알고리즘 중 하나로 모든 노드를 방문하는 것을 목표로 합니다.
시작 노드부터 하나의 방향을 잡아 끝까지 탐색한 후 분기점으로 돌아가 다시 다른 방향으로 끝까지 탐색하는 변태 같은 기법입니다.</description></item><item><title>Python 입문하기</title><link>https://5hdumat.github.io/posts/python/python-%EC%9E%85%EB%AC%B8%ED%95%98%EA%B8%B0/</link><pubDate>Sun, 16 May 2021 01:13:38 +0900</pubDate><guid>https://5hdumat.github.io/posts/python/python-%EC%9E%85%EB%AC%B8%ED%95%98%EA%B8%B0/</guid><description>언어는 Python으로 하겠습니다. 근데 이제 알고리즘을 곁들인 Python을 선택한 이유 대다수의 기업들이 코딩 인터뷰 Python 지원, 초보자도 쉽게 접근할 수 있는 언어, 수많은 자료구조 모듈, 짧은 코드 길이와 가독성, 쉬운 문자열 핸들링, 임의 정밀도 정수형으로 신경 쓰지 않아도 되는 오버플로는 Python의 대표적인 장점들입니다.
코딩 테스트 플랫폼1 에서 언어별 타임아웃 설정이 C++, Java에 비해 굉장히 타이트하기 때문에 동일한 알고리즘임에도 파이썬으로는 풀리지 않는 (억울한) 일이 심심찮게 발생하고 있습니다.
하지만 알고리즘 최적화에 좀 더 많은 고민이 필요하기 때문에 유연한 사고와 학습을 목표로 하는 저에겐 오히려 좋은 점으로 작용하게 된 것 같습니다.</description></item></channel></rss>