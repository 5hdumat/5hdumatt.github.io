<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>15663번: N과 M (9) | 5hdumat</title><meta name=keywords content="python,algorithm,Backtracking,dfs,백준"><meta name=description content="문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  N개의 자연수 중에서 M개를 고른 수열    중복되는 수열을 한번만 출력하도록 하는 경우의 수를 보여줘야하는 문제였습니다.
풀이 n, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n temp_list = [] output = [] def dfs(depth): if depth == m: if not tuple(temp_list) in output: output."><meta name=author content="서민규"><link rel=canonical href=https://5hdumat.github.io/posts/algorithm/backtracking/15663/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><link rel=preload href=/resources/images/CinemaGraphy/giphy.gif as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://5hdumat.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://5hdumat.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://5hdumat.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://5hdumat.github.io/apple-touch-icon.png><link rel=mask-icon href=https://5hdumat.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.0"><meta property="og:title" content="15663번: N과 M (9)"><meta property="og:description" content="문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  N개의 자연수 중에서 M개를 고른 수열    중복되는 수열을 한번만 출력하도록 하는 경우의 수를 보여줘야하는 문제였습니다.
풀이 n, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n temp_list = [] output = [] def dfs(depth): if depth == m: if not tuple(temp_list) in output: output."><meta property="og:type" content="article"><meta property="og:url" content="https://5hdumat.github.io/posts/algorithm/backtracking/15663/"><meta property="og:image" content="https://5hdumat.github.io/resources/images/PostBanner/baekjoon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-07T00:09:12+09:00"><meta property="article:modified_time" content="2021-06-07T00:09:12+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://5hdumat.github.io/resources/images/PostBanner/baekjoon.png"><meta name=twitter:title content="15663번: N과 M (9)"><meta name=twitter:description content="문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  N개의 자연수 중에서 M개를 고른 수열    중복되는 수열을 한번만 출력하도록 하는 경우의 수를 보여줘야하는 문제였습니다.
풀이 n, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n temp_list = [] output = [] def dfs(depth): if depth == m: if not tuple(temp_list) in output: output."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://5hdumat.github.io/posts/"},{"@type":"ListItem","position":3,"name":"15663번: N과 M (9)","item":"https://5hdumat.github.io/posts/algorithm/backtracking/15663/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"15663번: N과 M (9)","name":"15663번: N과 M (9)","description":"문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  N개의 자연수 중에서 M개를 고른 수열    중복되는 수열을 한번만 출력하도록 하는 경우의 수를 보여줘야하는 문제였습니다.\n풀이 n, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n temp_list = [] output = [] def dfs(depth): if depth == m: if not tuple(temp_list) in output: output.","keywords":["python","algorithm","Backtracking","dfs","백준"],"articleBody":"문제  N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  N개의 자연수 중에서 M개를 고른 수열    중복되는 수열을 한번만 출력하도록 하는 경우의 수를 보여줘야하는 문제였습니다.\n풀이 n, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n temp_list = [] output = [] def dfs(depth): if depth == m: if not tuple(temp_list) in output: output.append(tuple(temp_list)) return for i in range(n): if not visited[i]: visited[i] = True temp_list.append(number_list[i]) dfs(depth + 1) visited[i] = False temp_list.pop() dfs(0) for i in output: print(*i)  묻지도 따지지도 않고 값이 맞게 출력되길래 제출했더니 시간 초과가 반환되었습니다.\nif not tuple(temp_list) in output: 값의 포함 관계 여부를 따지는 if a in b 구문과 중복 수열로 인한 성능 이슈였습니다.\n포함 관계 여부를 따지는 과정에서 급증된 소요시간은 hash 기반으로 만들어진 set()을 사용하여 중복 데이터를 제거한 후 시간 초과를 해결할 수 있었습니다.\nhash에 대해선 차 후 블로그에 정리해두도록 하겠습니다.\nn, m = map(int, input().split()) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n temp_list = [] output = [] def dfs(depth): if depth == m: output.append(tuple(temp_list)) return for i in range(n): if not visited[i]: visited[i] = True temp_list.append(number_list[i]) dfs(depth + 1) visited[i] = False temp_list.pop() dfs(0) output = list(set(output)) output.sort() for i in output: print(*i) 보완할 점 그럼에도 불구하고 중복 수열이슈는 해결되지 않았습니다.\noverlap이란 변수를 만들어 전에 쓰인 변수 값과 비교하도록 했습니다. (초기값 0, 자연수가 아니므로)\n위치는 탈출문 바로 아래쪽에 위치하게 했는데, 이유는 깊이가 다를 때마다 변수를 초기화해야하기 때문입니다.\n방문 여부를 확인함과 동시에 값도 이전에 쓰인 변수 값과 같은지 확인하여 dfs를 진행하기 직전에 현재의 변수 값을 넘겨주었습니다.\nn, m = list(map(int, input().split())) number_list = list(map(int, input().split())) number_list.sort() visited = [False] * n output = [] def dfs(depth): if depth == m: print(*output) return overlap = 0 for i in range(n): if not visited[i] and overlap != number_list[i]: visited[i] = True output.append(number_list[i]) overlap = number_list[i] dfs(depth + 1) visited[i] = False output.pop() dfs(0) ","wordCount":"313","inLanguage":"en","image":"https://5hdumat.github.io/resources/images/PostBanner/baekjoon.png","datePublished":"2021-06-07T00:09:12+09:00","dateModified":"2021-06-07T00:09:12+09:00","author":{"@type":"Person","name":"서민규"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://5hdumat.github.io/posts/algorithm/backtracking/15663/"},"publisher":{"@type":"Organization","name":"5hdumat","logo":{"@type":"ImageObject","url":"https://5hdumat.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://5hdumat.github.io accesskey=h title="5hdumat (Alt + H)">5hdumat</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://5hdumat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://5hdumat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://5hdumat.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://5hdumat.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://5hdumat.github.io>Home</a>&nbsp;»&nbsp;<a href=https://5hdumat.github.io/posts/>Posts</a></div><h1 class=post-title>15663번: N과 M (9)</h1><div class=post-meta>June 7, 2021&nbsp;·&nbsp;서민규</div></header><figure class=entry-cover><img loading=lazy src=https://5hdumat.github.io/resources/images/PostBanner/baekjoon.png alt></figure><div class=post-content><h2 id=문제httpswwwacmicpcnetproblem15663><a href=https://www.acmicpc.net/problem/15663>문제</a><a hidden class=anchor aria-hidden=true href=#문제httpswwwacmicpcnetproblem15663>#</a></h2><ul><li>N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.<ul><li>N개의 자연수 중에서 M개를 고른 수열</li></ul></li></ul><p><img loading=lazy src=/resources/images/baekjoon/Backtracking/15663.png alt=15663></p><p>중복되는 수열을 한번만 출력하도록 하는 경우의 수를 보여줘야하는 문제였습니다.</p><h2 id=풀이>풀이<a hidden class=anchor aria-hidden=true href=#풀이>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>n, m <span style=color:#f92672>=</span> map(int, input()<span style=color:#f92672>.</span>split())
number_list <span style=color:#f92672>=</span> list(map(int, input()<span style=color:#f92672>.</span>split()))
number_list<span style=color:#f92672>.</span>sort()

visited <span style=color:#f92672>=</span> [<span style=color:#66d9ef>False</span>] <span style=color:#f92672>*</span> n
temp_list <span style=color:#f92672>=</span> []
output <span style=color:#f92672>=</span> []

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dfs</span>(depth):
    <span style=color:#66d9ef>if</span> depth <span style=color:#f92672>==</span> m: 
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> tuple(temp_list) <span style=color:#f92672>in</span> output:
            output<span style=color:#f92672>.</span>append(tuple(temp_list))
            <span style=color:#66d9ef>return</span>

    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> visited[i]:
            visited[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
            
            temp_list<span style=color:#f92672>.</span>append(number_list[i])
            dfs(depth <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
            
            visited[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
            temp_list<span style=color:#f92672>.</span>pop()
            
dfs(<span style=color:#ae81ff>0</span>)

<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> output:
    print(<span style=color:#f92672>*</span>i)
</code></pre></div><h1 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h1><p><img loading=lazy src=/resources/images/baekjoon/Backtracking/15663-fail.png alt=15663></p><p>묻지도 따지지도 않고 값이 맞게 출력되길래 제출했더니 시간 초과가 반환되었습니다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> tuple(temp_list) <span style=color:#f92672>in</span> output:
</code></pre></div><p>값의 포함 관계 여부를 따지는 <code>if a in b</code> 구문과 중복 수열로 인한 성능 이슈였습니다.</p><p>포함 관계 여부를 따지는 과정에서 급증된 소요시간은 <code>hash</code> 기반으로 만들어진 <code>set()</code>을 사용하여 중복 데이터를 제거한 후 시간 초과를 해결할 수 있었습니다.</p><p><code>hash</code>에 대해선 차 후 블로그에 정리해두도록 하겠습니다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>n, m <span style=color:#f92672>=</span> map(int, input()<span style=color:#f92672>.</span>split())
number_list <span style=color:#f92672>=</span> list(map(int, input()<span style=color:#f92672>.</span>split()))
number_list<span style=color:#f92672>.</span>sort()

visited <span style=color:#f92672>=</span> [<span style=color:#66d9ef>False</span>] <span style=color:#f92672>*</span> n
temp_list <span style=color:#f92672>=</span> []
output <span style=color:#f92672>=</span> []

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dfs</span>(depth):
    <span style=color:#66d9ef>if</span> depth <span style=color:#f92672>==</span> m: 
        output<span style=color:#f92672>.</span>append(tuple(temp_list))
        <span style=color:#66d9ef>return</span>

    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> visited[i]:
            visited[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
            
            temp_list<span style=color:#f92672>.</span>append(number_list[i])
            dfs(depth <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
            
            visited[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
            temp_list<span style=color:#f92672>.</span>pop()
            
dfs(<span style=color:#ae81ff>0</span>)

output <span style=color:#f92672>=</span> list(set(output))

output<span style=color:#f92672>.</span>sort()

<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> output:
    print(<span style=color:#f92672>*</span>i)
</code></pre></div><h2 id=보완할-점>보완할 점<a hidden class=anchor aria-hidden=true href=#보완할-점>#</a></h2><p>그럼에도 불구하고 중복 수열이슈는 해결되지 않았습니다.</p><p>overlap이란 변수를 만들어 전에 쓰인 변수 값과 비교하도록 했습니다. (초기값 0, 자연수가 아니므로)</p><p>위치는 탈출문 바로 아래쪽에 위치하게 했는데, 이유는 깊이가 다를 때마다 변수를 초기화해야하기 때문입니다.</p><p>방문 여부를 확인함과 동시에 값도 이전에 쓰인 변수 값과 같은지 확인하여 dfs를 진행하기 직전에 현재의 변수 값을 넘겨주었습니다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>n, m <span style=color:#f92672>=</span> list(map(int, input()<span style=color:#f92672>.</span>split()))

number_list <span style=color:#f92672>=</span> list(map(int, input()<span style=color:#f92672>.</span>split()))
number_list<span style=color:#f92672>.</span>sort()

visited <span style=color:#f92672>=</span> [<span style=color:#66d9ef>False</span>] <span style=color:#f92672>*</span> n 
output <span style=color:#f92672>=</span> []

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dfs</span>(depth):
    <span style=color:#66d9ef>if</span> depth <span style=color:#f92672>==</span> m:
        print(<span style=color:#f92672>*</span>output)
        <span style=color:#66d9ef>return</span>
    
    overlap <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> visited[i] <span style=color:#f92672>and</span> overlap <span style=color:#f92672>!=</span> number_list[i]:
            visited[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
            
            output<span style=color:#f92672>.</span>append(number_list[i])
            overlap <span style=color:#f92672>=</span> number_list[i]
            
            dfs(depth <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
            visited[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
            output<span style=color:#f92672>.</span>pop()
        
dfs(<span style=color:#ae81ff>0</span>)
</code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://5hdumat.github.io/tags/python/>python</a></li><li><a href=https://5hdumat.github.io/tags/algorithm/>algorithm</a></li><li><a href=https://5hdumat.github.io/tags/backtracking/>Backtracking</a></li><li><a href=https://5hdumat.github.io/tags/dfs/>dfs</a></li><li><a href=https://5hdumat.github.io/tags/%EB%B0%B1%EC%A4%80/>백준</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://5hdumat.github.io>5hdumat</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>