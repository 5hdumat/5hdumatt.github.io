<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>15649번: N과 M (1) | 5hdumat</title><meta name=keywords content="python,algorithm,Backtracking,dfs,백준"><meta name=description content="문제  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열    사전 지식 DFS, 백트래킹에 대한 개념 이해가 필요한 문제였습니다.
DFS (깊이 우선 탐색) 완전 탐색을 기본으로 하는 그래프 탐색 알고리즘 중 하나로 모든 노드를 방문하는 것을 목표로 합니다.
시작 노드부터 하나의 방향을 잡아 끝까지 탐색한 후 분기점으로 돌아가 다시 다른 방향으로 끝까지 탐색하는 변태 같은 기법입니다."><meta name=author content="서민규"><link rel=canonical href=https://5hdumat.github.io/posts/algorithm/backtracking/15649/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><link rel=preload href=/resources/images/CinemaGraphy/giphy.gif as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://5hdumat.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://5hdumat.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://5hdumat.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://5hdumat.github.io/apple-touch-icon.png><link rel=mask-icon href=https://5hdumat.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.1"><meta property="og:title" content="15649번: N과 M (1)"><meta property="og:description" content="문제  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열    사전 지식 DFS, 백트래킹에 대한 개념 이해가 필요한 문제였습니다.
DFS (깊이 우선 탐색) 완전 탐색을 기본으로 하는 그래프 탐색 알고리즘 중 하나로 모든 노드를 방문하는 것을 목표로 합니다.
시작 노드부터 하나의 방향을 잡아 끝까지 탐색한 후 분기점으로 돌아가 다시 다른 방향으로 끝까지 탐색하는 변태 같은 기법입니다."><meta property="og:type" content="article"><meta property="og:url" content="https://5hdumat.github.io/posts/algorithm/backtracking/15649/"><meta property="og:image" content="https://5hdumat.github.io/resources/images/postbanner/baekjoon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-03T01:13:38+09:00"><meta property="article:modified_time" content="2021-06-03T01:13:38+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://5hdumat.github.io/resources/images/postbanner/baekjoon.png"><meta name=twitter:title content="15649번: N과 M (1)"><meta name=twitter:description content="문제  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열    사전 지식 DFS, 백트래킹에 대한 개념 이해가 필요한 문제였습니다.
DFS (깊이 우선 탐색) 완전 탐색을 기본으로 하는 그래프 탐색 알고리즘 중 하나로 모든 노드를 방문하는 것을 목표로 합니다.
시작 노드부터 하나의 방향을 잡아 끝까지 탐색한 후 분기점으로 돌아가 다시 다른 방향으로 끝까지 탐색하는 변태 같은 기법입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://5hdumat.github.io/posts/"},{"@type":"ListItem","position":3,"name":"15649번: N과 M (1)","item":"https://5hdumat.github.io/posts/algorithm/backtracking/15649/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"15649번: N과 M (1)","name":"15649번: N과 M (1)","description":"문제  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열    사전 지식 DFS, 백트래킹에 대한 개념 이해가 필요한 문제였습니다.\nDFS (깊이 우선 탐색) 완전 탐색을 기본으로 하는 그래프 탐색 알고리즘 중 하나로 모든 노드를 방문하는 것을 목표로 합니다.\n시작 노드부터 하나의 방향을 잡아 끝까지 탐색한 후 분기점으로 돌아가 다시 다른 방향으로 끝까지 탐색하는 변태 같은 기법입니다.","keywords":["python","algorithm","Backtracking","dfs","백준"],"articleBody":"문제  자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열    사전 지식 DFS, 백트래킹에 대한 개념 이해가 필요한 문제였습니다.\nDFS (깊이 우선 탐색) 완전 탐색을 기본으로 하는 그래프 탐색 알고리즘 중 하나로 모든 노드를 방문하는 것을 목표로 합니다.\n시작 노드부터 하나의 방향을 잡아 끝까지 탐색한 후 분기점으로 돌아가 다시 다른 방향으로 끝까지 탐색하는 변태 같은 기법입니다.\n보통 노드의 깊이를 예측하고자 할 때 사용합니다.\n그림과 같이 DFS는 모든 노드를 방문하는 것을 목표로 하기 때문에 목표지점이 있지 않은 경로까지 탐색하면서 비효율적인 자원을 소모합니다.\n이러한 문제점을 해소함과 동시에 제약 조건에 맞는 해답을 찾기 위해선 DFS와 백트래킹을 혼용해서 사용합니다.\n백트래킹 (퇴각 검색) 백트래킹이란 해을 찾는 과정에서 조건에 부합하지 않은 후보 해가 나타날 경우 이전 단계로 돌아가 다른 후보 해를 찾는 퇴각 검색 기법 입니다.\nDFS의 비효율적인 경로를 차단하고 가능성이 있는 루트를 검사하는 방법(가지치기, Pruning)으로 검색 효율을 극대화합니다.\nDFS과 백트래킹에 대한 개념을 간략하게 잡아보았습니다.\n풀이 n, m = map(int, input().split()) number_list = [1 + i for i in range(n)] output = [] def dfs(): if len(output) == m: print(*output) return for i in number_list: if not i in output: output.append(i) dfs() output.pop() dfs() 재귀 호출 속에서 또 재귀 호출이 이루어지다 보니 이해하기가 쉽지 않았습니다.\n(재귀 호출로 노드를 탐색 한 후 탈출하는 과정에서 pop() 함수가 연속으로 호출된다던가)\n중간 중간 print()을 하나 하나 출력해보면서 미로 찾기 하는 느낌으로 이해했던 것 같습니다.\n보완할 점 number_list = [i + 1 for i in range(n)] 위와 같이 n의 크기만큼 배열을 만들어 풀었더니 순차 탐색으로 인한 시간 복잡도가 O(n) = n와 같이 늘어나는 최악의 경우가 발생했습니다.\n시간 복잡도를 줄이고자 visited로 방문 리스트를 만들어 한번 방문했다고 판단되는 곳은 더 이상 방문하지 않도록 해 선형 탐색 알고리즘을 좀 더 효율적으로 수정하였습니다.\nn, m = map(int, input().split()) visited = [False] * n output = [] def dfs(depth): if depth == m: print(*output) return for i in range(n): if not visited[i]: visited[i] = True output.append(i + 1) dfs(depth + 1) visited[i] = False output.pop() dfs(0) 알게된 점 from itertools import permutations n, m = map(int, input().split()) for i in permutations(range(1, n + 1), m): print(*i) 외장 함수 permutations을 이용해 손쉽게 수열을 출력할 수 있었습니다.\n","wordCount":"354","inLanguage":"en","image":"https://5hdumat.github.io/resources/images/postbanner/baekjoon.png","datePublished":"2021-06-03T01:13:38+09:00","dateModified":"2021-06-03T01:13:38+09:00","author":{"@type":"Person","name":"서민규"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://5hdumat.github.io/posts/algorithm/backtracking/15649/"},"publisher":{"@type":"Organization","name":"5hdumat","logo":{"@type":"ImageObject","url":"https://5hdumat.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://5hdumat.github.io accesskey=h title="5hdumat (Alt + H)">5hdumat</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://5hdumat.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://5hdumat.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://5hdumat.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://5hdumat.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://5hdumat.github.io>Home</a>&nbsp;»&nbsp;<a href=https://5hdumat.github.io/posts/>Posts</a></div><h1 class=post-title>15649번: N과 M (1)</h1><div class=post-meta>June 3, 2021&nbsp;·&nbsp;서민규</div></header><figure class=entry-cover><img loading=lazy src=https://5hdumat.github.io/resources/images/postbanner/baekjoon.png alt></figure><div class=post-content><h2 id=문제httpswwwacmicpcnetproblem15649><a href=https://www.acmicpc.net/problem/15649>문제</a><a hidden class=anchor aria-hidden=true href=#문제httpswwwacmicpcnetproblem15649>#</a></h2><ul><li>자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.<ul><li>1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열</li></ul></li></ul><p><img loading=lazy src=/resources/images/baekjoon/Backtracking/15649.png alt=15649></p><h2 id=사전-지식>사전 지식<a hidden class=anchor aria-hidden=true href=#사전-지식>#</a></h2><p><code>DFS, 백트래킹</code>에 대한 개념 이해가 필요한 문제였습니다.</p><h3 id=dfs-깊이-우선-탐색>DFS (깊이 우선 탐색)<a hidden class=anchor aria-hidden=true href=#dfs-깊이-우선-탐색>#</a></h3><p>완전 탐색을 기본으로 하는 그래프 탐색 알고리즘 중 하나로 <code>모든 노드를 방문하는 것을 목표</code>로 합니다.</p><p>시작 노드부터 <code>하나의 방향을 잡아 끝까지 탐색한 후 분기점으로 돌아가 다시 다른 방향으로 끝까지 탐색</code>하는 변태 같은 기법입니다.</p><p>보통 노드의 깊이를 예측하고자 할 때 사용합니다.</p><p><img loading=lazy src=/resources/images/baekjoon/Backtracking/dfs.gif alt=DFS></p><p>그림과 같이 <code>DFS</code>는 <code>모든 노드를 방문하는 것</code>을 목표로 하기 때문에 목표지점이 있지 않은 경로까지 탐색하면서 비효율적인 자원을 소모합니다.</p><p>이러한 문제점을 해소함과 동시에 제약 조건에 맞는 해답을 찾기 위해선 <code>DFS</code>와 <code>백트래킹</code>을 혼용해서 사용합니다.</p><h3 id=백트래킹-퇴각-검색>백트래킹 (퇴각 검색)<a hidden class=anchor aria-hidden=true href=#백트래킹-퇴각-검색>#</a></h3><p><code>백트래킹</code>이란 해을 찾는 과정에서 조건에 부합하지 않은 후보 해가 나타날 경우 이전 단계로 돌아가 다른 후보 해를 찾는 <code>퇴각 검색 기법</code> 입니다.</p><p><code>DFS</code>의 비효율적인 경로를 차단하고 가능성이 있는 루트를 검사하는 방법(가지치기, Pruning)으로 검색 효율을 극대화합니다.</p><p><code>DFS</code>과 <code>백트래킹</code>에 대한 개념을 간략하게 잡아보았습니다.</p><h2 id=풀이>풀이<a hidden class=anchor aria-hidden=true href=#풀이>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>n, m <span style=color:#f92672>=</span> map(int, input()<span style=color:#f92672>.</span>split())

number_list <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> i <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n)]
output <span style=color:#f92672>=</span> []

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dfs</span>():
    <span style=color:#66d9ef>if</span> len(output) <span style=color:#f92672>==</span> m:
        print(<span style=color:#f92672>*</span>output) 
        <span style=color:#66d9ef>return</span>

    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> number_list: 
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> i <span style=color:#f92672>in</span> output:
            output<span style=color:#f92672>.</span>append(i)
            dfs()
            output<span style=color:#f92672>.</span>pop()
             
dfs()
</code></pre></div><p>재귀 호출 속에서 또 재귀 호출이 이루어지다 보니 이해하기가 쉽지 않았습니다.<br>(재귀 호출로 노드를 탐색 한 후 탈출하는 과정에서 pop() 함수가 연속으로 호출된다던가)</p><p>중간 중간 <code>print()</code>을 하나 하나 출력해보면서 미로 찾기 하는 느낌으로 이해했던 것 같습니다.</p><h2 id=보완할-점>보완할 점<a hidden class=anchor aria-hidden=true href=#보완할-점>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>number_list <span style=color:#f92672>=</span> [i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n)]
</code></pre></div><p>위와 같이 <code>n</code>의 크기만큼 배열을 만들어 풀었더니 순차 탐색으로 인한 시간 복잡도가 <code>O(n) = n</code>와 같이 늘어나는 최악의 경우가 발생했습니다.</p><p>시간 복잡도를 줄이고자 <code>visited</code>로 방문 리스트를 만들어 한번 방문했다고 판단되는 곳은 더 이상 방문하지 않도록 해 선형 탐색 알고리즘을 좀 더 효율적으로 수정하였습니다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>n, m <span style=color:#f92672>=</span> map(int, input()<span style=color:#f92672>.</span>split())

visited <span style=color:#f92672>=</span> [<span style=color:#66d9ef>False</span>] <span style=color:#f92672>*</span> n
output <span style=color:#f92672>=</span> []

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dfs</span>(depth):
    <span style=color:#66d9ef>if</span> depth <span style=color:#f92672>==</span> m: 
        print(<span style=color:#f92672>*</span>output) 
        <span style=color:#66d9ef>return</span>

    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n): 
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> visited[i]:
            visited[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>

            output<span style=color:#f92672>.</span>append(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
            dfs(depth <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
            
            visited[i] <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
            output<span style=color:#f92672>.</span>pop()
             
dfs(<span style=color:#ae81ff>0</span>)
</code></pre></div><h2 id=알게된-점>알게된 점<a hidden class=anchor aria-hidden=true href=#알게된-점>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> itertools <span style=color:#f92672>import</span> permutations

n, m <span style=color:#f92672>=</span> map(int, input()<span style=color:#f92672>.</span>split())

<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> permutations(range(<span style=color:#ae81ff>1</span>, n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>), m):
    print(<span style=color:#f92672>*</span>i)
</code></pre></div><p><code>외장 함수 permutations</code>을 이용해 손쉽게 수열을 출력할 수 있었습니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://5hdumat.github.io/tags/python/>python</a></li><li><a href=https://5hdumat.github.io/tags/algorithm/>algorithm</a></li><li><a href=https://5hdumat.github.io/tags/backtracking/>Backtracking</a></li><li><a href=https://5hdumat.github.io/tags/dfs/>dfs</a></li><li><a href=https://5hdumat.github.io/tags/%EB%B0%B1%EC%A4%80/>백준</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://5hdumat.github.io>5hdumat</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>